# 一、HTML

## 1 基本

HTML 标签无法识别大写，遇到大写会转化成 -小写 ，如 \<xxx\-yyy\> ，不过打包工具可以解决。

（1）基本

```
<!DOCTYPE html>
<!-- 使用 HTML5,必须在最顶部 -->

<!-- 根元素 -->
<html lang="en">
  <!-- head 中用来设置页面、引入资源等 -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>标题</title>
  </head>

  <!-- 页面主体 -->
  <body>
    <!-- 注释 -->

    <!-- 特殊字符，分别是空格，小于号、大于号 -->
      < >

    <!-- 换行 -->
    <br />

    <!-- 行内元素，一行多个 -->
    <span>文本</span>
    <strong>加粗</strong>
    <b>加粗</b>
    <em>倾斜</em>
    <i>倾斜</i>
    <ins>下划线</ins>
    <u>下划线</u>
    <del>删除线</del>
    <s>删除线</s>

    <!-- 块级元素，独占一行 -->
    <div>独占一行</div>
    <p>p 比 div 在多了上下 margin</p>

    <!-- 行内快元素，一行多个 -->
    <a href="">link</a>
    <img src="" alt="" />
    <input type="text" />

    <!-- 属性没有顺序之分，多个属性用空格隔开 -->
    <div id="app" class="box"></div>

    <!-- 布尔属性，value 只有有或没有两种情况，可以简写 -->
    <button disabled="disabled"></button>
    <button disabled></button>

    <!-- 双标签 -->
    <div></div>
    <!-- 单标签，/ 不加，但最好加上 -->
    <input />
  </body>
</html>
```

html 内容默认不换行。多个空格默认只显示一个。

书写在不同行的标签会多出一个空格，在同一行在不书写空格前提下，不会有空格。

（2）图片、超链接

都是行内快元素：

```
<img src="" alt="" /> 单标签，不换行
```

| 属性           | 描述                                           |
| ------------ | -------------------------------------------- |
| src          | 图像路径，必选属性                                    |
| alt          | 替换文本，图片不能正常显示时，显示的文本                         |
| title        | 显示文本，鼠标移动到图片时显示的文本                           |
| border       | 设置边框                                         |
| width、height | width和height只修改一个时另一个等比缩放，两个都改可能会扭曲图片，一般只改一个 |

超链接：

分为：外部链接，内部链接，空链接，下载链接，锚点链接五种和一种元素链接
被a标签包含的标签（如img标签）整个元素成为超链接，称为元素链接

```
<a href="#">超链接</a>  不换行
```

| 属性     | 描述                                                                                       |
| ------ | ---------------------------------------------------------------------------------------- |
| href   | 必选属性，跳转网址(外部链接)或自己html路径(内部链接)，#表示不跳转(空链接),文件或者压缩包(下载链接)。#id(锚点链接，需要在待跳转的标签中添加 id=”id名”) |
| target | 跳转方式，默认为_self当前页面打开，_blank为新窗口打开                                                         |

（3）表格

* 块级元素：table 、tr 、thead 、tbody

* 行内快元素：th 、td

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      table {
        /* 设置 table border 后，默认每个单元格都有，这个属性可以合并重叠 border */
        border-collapse: collapse;
      }
    </style>
  </head>

  <body>
    <!-- thead、tbody 不是必须得 -->
    <table cellpadding="20" border="1" align="center">
      <thead>
        <th>name</th>
        <th>age</th>
      </thead>
      <tbody>
        <tr>
          <td>asdf</td>
          <td>18</td>
        </tr>
        <tr>
          <td>qwer</td>
          <td>20</td>
        </tr>
      </tbody>
    </table>

    <!-- 合并单元格 -->
    <table cellpadding="20" border="1">
      <tr>
        <td colspan="2">1</td>
        <td rowspan="2">2</td>
      </tr>
      <tr>
        <td>3</td>
        <td>4</td>
      </tr>
    </table>

    <!-- 合并前 -->
    <!-- 
    <table cellpadding="20" border="1">
      <tr>
        <td>1</td>
        <td></td>
        <td>2</td>
      </tr>
      <tr>
        <td>3</td>
        <td>4</td>
        <td></td>
      </tr>
    </table> 
    -->
  </body>
</html>
```

table 属性（在 HTML5 中，更推荐直接使用 CSS 设置 table 样式）：

| table 属性                 | 描述                                                                |
| ------------------------ | ----------------------------------------------------------------- |
| align                    | 整个表格在页面的对齐位置，left ，center ，right ，默认 left                         |
| cellspacing 、cellpadding | 单元格 margin 、 padding ；cellspacing 仅在 CSS 未设置 border\-collapse 时有效 |
| border                   | 单元格边框                                                             |
| width 、height            | 宽、高                                                               |

（4）列表

都是块级元素：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 无序列表 -->
    <ul>
      <li>1</li>
      <li>2</li>
    </ul>

    <!-- 有序列表 -->
    <ol>
      <li>1</li>
      <li>2</li>
    </ol>

    <!-- 自定义列表 -->
    <dl>
      <dt>title</dt>
      <dd>1</dd>
      <dd>2</dd>
    </dl>
  </body>
</html>
```

（5）表单

一个表单由表单域、表单控件、提示信息组成。表单域 from 是包含所有表单控件和提示信息的区域。

- 块级元素：form、select、option

- 行内快元素：input、button、textarea

form ：

* 可以绑定 submit 、reset 事件，就算不绑定也会有默认行为：
  
  * submit：点击 submit 按钮或回车，将表单信息用 POST 请求发送给 action 的地址，并刷新页面（阻止默认行为可以阻止 POST 请求和刷新页面，其他功能保留）
    
    * 所有表单都应该放在 form 中，可以避免很多问题，如中文输入回车问题，直接绑定 submit 并阻止默认行为就可以解决
    
    reset：清空 from 中所有表单的信息

* form 按钮：
  
  * 普通 button 、或 type 为 submit 的 button 、input 都是 submit 按钮
  
  * type 为 reset 的 button 、input 都是 reset 按钮
  
  * type 为 button 的 button 、input 就是普通按钮
  
  * form 外的 button 都是普通按钮

示例：

```
<!DOCTYPE html>
<html lang="en">
  <body>
    <!-- form 表单 -->
    <form class="my-form" action="">
      <div>
        <input type="text" />
      </div>

      <div>
        <textarea rols="50" cols="50"></textarea>
      </div>

      <!-- label 效果是只要点击了 label 的内容就能选中 radip 、checkbox -->
      <div>
        <label for="radio-id-1">
          <input type="radio" id="radio-id-1" name="radios" />
          <span>radio 1</span>
        </label>

        <label for="radio-id-2">
          <input type="radio" id="radio-id-2" name="radios" />
          <span>radio 1</span>
        </label>
      </div>

      <div>
        <label for="checkbox-id-1">
          <input type="checkbox" id="checkbox-id-1" />
          <span>agree</span>
        </label>
      </div>

      <select>
        <option value="1">options 1</option>
        <option value="2" selected>options 2</option>
      </select>

      <!-- form 中的按钮比较特殊，除了触发 click 事件外，还会冒泡触发 submit 、reset -->
      <div>
        <button>submit1</button>
        <button type="submit">submit2</button>
        <input type="submit" value="submit3" />
      </div>
      <div>
        <button type="reset">reset1</button>
        <input type="reset" value="reset2" />
      </div>
      <div>
        <button type="button">button1</button>
        <input type="button" value="button2" />
      </div>
    </form>

    <!-- form 外的 button 就是独立的，只会触发绑定的 click 事件 -->
    <p>
      <button>click</button>
      <button disabled>disabled</button>
    </p>
  </body>

  <script>
    const form = document.querySelector(".my-form");

    form.addEventListener("submit", (e) => {
      e.preventDefault();
      console.log("submit");
    });

    form.addEventListener("reset", () => console.log("reset"));

    document.querySelectorAll("button").forEach((btn) => {
      btn.addEventListener("click", (e) => console.log("click", e.target));
    });
  </script>
</html>
```

| form 属性 | 描述         |
| ------- | ---------- |
| action  | 提交的后端 url  |
| method  | 提交的 method |
| name    | form name  |

| input type | 描述      |
| ---------- | ------- |
| text       | 文本框     |
| password   | 密码框     |
| hidden     | 隐藏的文本框  |
| radio      | 单选框     |
| checkbox   | 复选框     |
| button     | 普通按钮    |
| submit     | 提交按钮    |
| reset      | 重置按钮    |
| image      | 图片形式的按钮 |
| file       | 文件上传按钮  |

| input 属性         | 描述                              |
| ---------------- | ------------------------------- |
| value            | 表单值                             |
| name             | 只有相同 name 的 radio 才能实现单选        |
| id               | 唯一 id ，通常配合 \<label\>           |
| checked、selected | radio、checkbox 是否选中、option 是否选中 |
| disabled         | 是否禁用、\<button\> 也有该属性           |

## 2 HTML5

（1）语义化标签

和 div 一模一样，只是语义化不同，利于 SEO ：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <header>header</header>
    <main>main</main>
    <footer>footer</footer>

    <nav>导航栏</nav>
    <aside>侧边栏</aside>

    <article>文章</article>
    <section>某段内容</section>
  </body>
</html>
```

（2）多媒体标签

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
      <!-- 视频，只支持 MP4，WebM，Ogg 三种格式，各浏览器支持不同，但几乎都支持 MP4 -->
      <video src=""></video>

      <!-- 由于各个浏览器支持的格式不同，可以这样处理 -->
       <video>
        <source src="xx.mp4" type=”video/mp4”></source>
          <source src="xx.ogg" type=”video/ogg”></source>
          <h3>浏览器不支持该格式</h3>
       </video>

       <!-- 音频，只支持 MP3、Wav、Ogg 三种格式，各浏览器支持的也不同，但几乎都支持 MP3 -->
       <audio src="">
       </audio>

       由于各个浏览器支持的格式不同，可以这样处理：
       <audio>
         <source src="xx.mp3" type=”audio/mpeg”>
         <source src="xx.ogg" type=”audio/ogg”>
         <h3>浏览器不支持该格式</h3>
       </audio>
</body>
</html>
```

| video 属性      | 描述                                                                         |
| ------------- | -------------------------------------------------------------------------- |
| src           | 资源路径                                                                       |
| width、height  | 宽、高，单位 px 或 %                                                              |
| autoplay      | 是否自动播放（默认不）                                                                |
| muted         | 是否静音播放（默认不静音），可以解决谷歌浏览器强制不能自动播放的问题                                         |
| controls      | 是否显示播放控件，即播放，音量，全屏等按钮                                                      |
| loop          | 是否循环播放（默认只播放一次的                                                            |
| preload       | 是否预先加载视频，设置了autoplay则忽略该属性（auto：预加载，none：不预加载，metadata：只预加载元数据如大小、时间、第一帧等） |
| poster=“图片路径” | 视频等待加载时的封面                                                                 |

audio 属性：没有 width、height。autoplay 谷歌浏览器无效，需要 JS 解决，其他属性与视频一样。

JS 操作，视频、音频一样：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <video class=".mp4" src=""></video>
  </body>
  <script>
    var mp4 = document.querySelector(".mp4");

    // 播放
    mp4.play();
    // 暂停
    mp4.pause();
    // 重新加载
    mp4.load();

    // 是否已暂停
    console.log(mp4.paused);
    // src
    console.log(mp4.currentSrc);

    // 设置 src
    mp4.src = "";

    /**网络状态
     * 0 初始
     * 1 空闲 （此时还未建立网络连接）
     * 2 正在加载
     * 3 没找到或不支持
     */
    console.log(mp4.networkState);

    /**当前就绪状态
     * 0 还未获取任何数据
     * 1 已获得元数据，但未获得媒体数据，无法播放
     * 2 已获得当前位置媒体数据，但未获得下一位置媒体数据，或当前位置是最后
     * 3 当前/下一位置美体数据都获得
     * 4 获得
     */
    console.log(mp4.readyState);
  </script>
</html>
```

（3）input 新特性

type 新类型，若输入的格式不一致，会自动报错：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <form action="">
      <input type="email" />
      <input type="url" />
      <input type="tel" />
      <input type="email" />
      <input type="number" />

      <input type="date" />
      <input type="time" />
      <input type="month" />
      <input type="week" />

      <input type="search" />
      <input type="color" />
    </form>
  </body>
</html>
```

新属性：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <form action="">
      <!-- 必填，在 submit 时验证 -->
      <input required />

      <!-- 自动聚焦 -->
      <input autofocus />

      <!-- input::placeholder 可修改样式 -->
      <input placeholder="请输入..." />

      <!-- submit 时是否记录历史，默认 on，必须有 name 属性才有效 -->
      <input autocomplete="off" />

      <!-- 多选，一般用于 file -->
      <input type="file" multiple />
    </form>
  </body>
</html>
```

（4）绘图

canvas，用 JS 绘制 2D 图，依赖分辨率，可保存为 jpg、png，适合做游戏：

```
html中：
<canvas id=”can” width=”500px” height=”500px”></canvas>     //给id，设置画板宽高
Js中：
let c=document.getElementById('can')
    //初始化
    let ctx = c.getContext('2d')
    //1.填充
    ctx.fillStyle="red" //填充色
    //画填充矩形
    ctx.fillRect(0,0,100,100) //起始x，y和终点x，y
    //填充文字
    ctx.font="50px 微软雅黑"  //字体
    ctx.fillText("abcd",0,400)

    //2、画直线，圆形，空心文字
    //设置画笔
    ctx.lineWidth="2"     //画笔粗细
    ctx.strokeStyle="blue"  //画笔颜色
    ctx.lineCap="round"  //原有的基础上在两端加上圆角
    //直线
    ctx.moveTo(150,150)   //起始xy
    ctx.lineTo(200,200)   //重点xy
    ctx.stroke()          //画线
    //圆形
    ctx.beginPath() 
    ctx.arc(300,300,25,5,2*Math.PI,false) //圆心xy，半径，距起点长度，画多长，顺时针false（起点在3点钟方向）
    ctx.stroke()
    ctx.closePath()
    //空心文字,可设置字体，若画笔过粗会变成实心
ctx.strokeText('123',400,400)
//3、裁剪图片
    let pic=document.getElementById('pic')  //获取img标签
    //图片加载完后再裁剪
    pic.onload=function(){
      //待裁剪图，裁剪起始xy宽高，裁剪后放的xy宽高（这个宽高设置不好会缩放图片）
      ctx.drawImage(pic,0,0,260,500,100,100,200,500)
    }


fill() 填充颜色
当绘的2d图发生变化时，需要清空整个画板，再重画
ctx.clearRect(x1,y1,w,h) 画板起始xy，画板宽高
当画时钟，转盘这种大圆形时,为了方便：
ctx.transition(x,y) 将起始点从左上角，移动到xy，xy一般是圆心
c.width  c.height 获得画板宽高，以计算半径
整个画板可用圆角边框设置为圆形，设置背景色
典型案例：数字时钟
注意点：
*圆形边缘坐标 x=r*cos角度 y=r*sin角度
*Math.cos(弧度)  弧度=(角度/180)*PI
*电脑xy是左下正，数学xy是左上正
*0度是三点钟方向，0点是12点钟方向，需要加减法，取余转化
```

vg，用 xml 描述 2D 图，不依赖分辨率（即缩放不失真），可使用事件监听，适合做高清地图：

```
可以引入svg文件，也可以<img src=”xxx.svg”>
也可以：
<svg>
    <!-- 圆形，圆心xy，半径，画笔颜色，画笔粗细，填充色 -->
    <circle cx="50" cy="50" r="20" stroke="red" stroke-width="10" fill="blue"></circle>
    <!-- 椭圆，圆心xy，xy半径，画笔颜色，画笔粗细，填充色 -->
    <ellipse cx="200" cy="50" rx="20" ry="20" stroke="red" stroke-width="10" fill="blue"></ellipse>
    <!-- 矩形，起始xy，宽高,圆角边框半径，画笔颜色，画笔粗细，填充色 -->
    <rect x="50" y="100" width="20" height="20" rx="5" ry="5" stroke="red" stroke-width="10" fill="blue"></rect>
    <!-- 直线 起始xy，终点xy -->
    <line x1="100" y1="200" x2="200" y2="500" stroke="red" stroke-width="10"></line>
    <!-- 由各点连成的折线 各个点的xy -->
    <polyline points="10 10 20 20 30 30" stroke="red" stroke-width="5"></polyline>


  </svg>
```

# 二、CSS

## 1 基础

html 标签只是一个语义化的功能，而盒子类型、样式都是由浏览器默认样式决定的，如 div ，p 就是因为默认样式是 display: block; 才会是块盒，p 默认样式由上下的 margin

CSS，层叠样式表，分为：

- 行内样式表：也叫内联样式表，在 html 元素中用 style 属性编写

- 内部样式表；在 \<style\> 中编写

- 外部样式表：\<link\> 导入的外部 .css 文件

- 浏览器默认样式表：各个浏览器的默认样式

优先级：默认 \< 外部 \< 内部 \< 行内 。

CSS 只有多行注释：

```
/* 多行注释 */
```

.css 文件导入另一个 .css 文件：

```
@import "./1.css";
```

### 1.1 盒子模型

（1）盒子模型

盒子由 margin 、border 、padding 、content 构成，分类：

- W3C 标准盒子模型：所有 html 元素都是盒子，浏览器默认样式就是这种模型：
  
  ```
  .box {
    /* 默认值，不需要特意编写 */
    /* box-sizing: content-box; */
  
    /* 特点：width 、height 设置的是 content 的宽高度 */
    /* 总宽高: 142px ，content 宽高: 100px */
    margin: 10px;
    border: 1px solid #000f;
    padding: 10px;
    width: 100px;
    height: 100px;
  }
  ```

- CSS3 盒子模型：CSS3 提出，也叫 IE 怪异盒子模型：
  
  ```
  .box {
    box-sizing: border-box;
  
    /* 特点：width 、height 设置的是 border、padding、content 的宽高度 */
    /* 总宽高: 142px ，content 高度: 78px */
    margin: 10px;
    border: 1px solid #000f;
    padding: 10px;
    width: 100px;
    height: 100px;
  }
  ```

可以继承父盒子的盒子模型：

```
.box {
  box-sizing: inherit;
}
```

JS ：

```
console.log(box.offsetWidth, "content + 2 * padding + 2 * border");
console.log(box.clientWidth, "content + 2 * padding");
```

（2）盒子类型

行内元素、块级元素的说法是老标准，准确的说法是行盒、块盒

主要有行盒、块盒、行内块盒，由 display 指定：

```
div {
  display: block;
}

span {
  display: inline;
}

a {
  display: inline-block;
}
```

特点：

- 只有块盒，行内快盒才可以设置 width ，height ；行盒不能设置 width、height，但可以设置 margin、border、padding，但是需要注意：
  
  - 行盒的 margin 只有左右有效
  
  - 行盒的 padding ，水平垂直都会撑开行盒自己，也会撑开父盒的宽度，但父盒的高度不会撑开

- 行盒、行内块多个占一行、块盒独占一行；行盒、行内快盒内不能放快盒

- 行盒内只能是行盒、行内块盒、内容；行盒和块盒不能在同一界，如果出现了这些情况，浏览器会使用匿名行盒、匿名块盒，匿名盒子不会被渲染出来；最好按规范来，避免不必要的麻烦

常见标签：

- 行盒：a span

- 行内快盒：a image input

- 块盒：div p ul li ol dl table

### 1.2 属性

属性顺序规范：布局、盒子、背景、文本、字体 。

（1）字体

```
.box {
  /* 默认 normal ，文本的特性，如倾斜 italic */
  font-size: italic;

  /* 文本粗细，string ，number 都行，默认 400 或 normal ，常用的是 700 或 bold  */
  font-weight: bold;

  /* 字体大小 */
  font-size: 20px;

  /* 行高 px、无单位、% 都行，无单位时字体大小的倍数，% 时字体大小百分比 */
  line-height: 20px;

  /* 字体 */
  font-family: "Microsort Yahei";

  /**符合写法
   * 需要按顺序，且 font-size ，font-family 不能省略
   * line-height 前需要加 /
   */
   /* font: italic bold 20px/20px "Microsort Yahei"; */
}
```

（2）文本

```
.box {
  /**字体颜色
   * 只要是颜色属性，就有 4 种形式：rgb(n, n, n) ，"color" ，"#ffffff" ，"#fff"
   * color: transparent; 全透明
   * CSS3 新增 rgba(n, n, n, opecity) 透明度颜色
   */
  color: red;

  /* 首行缩进 */
  text-indent: 2em;

  /* 水平对齐方式 */
  text-align: left;

  /**行盒垂直对齐的基准线，类似英文单词的 4 条线
   * top
   * middle
   * baseline 基线，默认值
   * bottom   可以让垂直排列的 img 没有空隙
   */
  vertical-align: baseline;

  /* 一般默认 none ，不过 <a> 不是，一般也是用来去除 a 的样式 */
  text-decoration-color: none;

  /* 一般默认 none ，不过 li 不是，一般也用来去除 li 的样式 */
  list-style: none;

  /**文本引用，CSS3 新属性
   * 分别是水平偏移，垂直偏移，半径，颜色，前两个必须有
   */
  text-shadow: 2px 2px 5px #000;
}
```

（3）背景

```
.box1 {
  /* 背景颜色 */
  background-color: #000;

  /* 背景图 */
  background-image: url(./1.jpg);

  /* 背景图是否需要平铺，默认会 */
  background-repeat: no-repeat;

    /* 背景图滚动还是固定，scroll | fixed ，默认 scroll */
    background-attachment: fixed;

  /* 距离左上角的 px ，或方位名词（如 center），若只写一个，另一个默认是 center */
  background-position: center center;

  /* 符合写法，顺序随意 */
  /* background: #000 url(./1.jpg) no-repeat fixed center center; */
}

.box2 {
  width: 200px;
  height: 200px;

  /**渐变背景，CSS3 新特性
   * 百分比可以不写
   */
  background-image: linear-gradient(
    to right,
    red 0%,
    blue 50%,
    #000 100%
  );
}
```

（4）盒子属性

```
.box {
  display: block;
  box-sizing: border-box;

  /**margin、padding 4 种写法
   * margin: 10px;                 全部
   * margin: 10px 10px;            上下 左右
   * margin: 10px 10px 10px;       上 左右 下
   * margin: 10px 10px 10px 10px;  上 右 下 左
   */
  /* margin、border、padding 都可以单独设置一个方向，如 margin-left */

  /**
   * 设置了左右 margin，且 auto 的 width，会压缩 content
   * margin: 0 auto; 水平居中
   */
  margin: 10px 20px 10px;

  /**
   * 顺序随意，也可以拆开写 
   * auto 的 width 的 content 会被压缩 
   * auto 的 height，块盒的高度会撑开
   */
  border: 1px solid #000;
  /* 合并多余的单元格 */
  /* border-collapse: collapse; */

  /**CSS3 新属性，圆角边框
   * value 为圆角半径
   * 和 margin、padding 一样的 4 种写法，从左上角开始
   * 也可以拆开写，如 border-top-left-radius
   */
  border-radius: 10px;

  /**
   * auto 的 width 的 content 会被压缩 
   * auto 的 height，块盒的高度会撑开
   */
  padding: 10px 20px;

  /**width ，height 默认是 auto
   * width: auto;  块盒撑满包含块（行盒，行内块盒是内容宽度）
   * height: auto; height 即最高的子元素的 height
   */
  width: 100px;
  height: 100px;

  /**盒子引用，CSS3 新属性
   * 分别是水平偏移，垂直偏移，半径，颜色，内部，前两个必须有，默然阴影在外部，内部可设 inset
   */
   box-shadow: 2px 2px 5px #000 inset;
}

/* margin 为负数时，时向反方向移动 */
.box {
  margin-left: -50px;
}
```

5）CSS API

如 rgb() ，CSS3 也新增了 API：

```
.box {
  /* 计算 */
  width: calc(100% - 80px);
}
```

### 1.3 选择器

（1）基础选择器

```
/* 通配符选择器，选择全部 html 元素 */
* {}

/* 元素选择器，也叫标签选择器，选择所有此类标签元素 */
div {}

/* id 选择器，选择 html 标签对饮 id 的元素 */
#app {}

/* 类选择器，选择 html 元素对饮 class 的元素 */
.box {}
```

（2）赋合选择器

基础选择器互相组合：

```
/* 后代选择器，选择 a 所有后代层级的 b ， */
.box .text {}

/* 子选择器，只选择 a 下一级中的 b */
.list > .item {}

/* 并集选择器，只要其中一个符合，就选中 */
.big, .small {}

/* 一般兄弟选择器，选择 a 之后的所有兄弟 b */
div ~ p {}

/* 相邻兄弟选择器，只选中 a 的下一个兄弟 b */
span + img {}

/**属性选择器
 * 可单独使用，也可以结合其他选择器
 * ^*& 分贝是模糊匹配开头、中间、结尾
 */
[href] {}
.btn[disable] {}
.box[data-id = "1"] {}
.img[src &= ".jpg"] {}
```

（3）伪元素、伪类

伪元素选择器，在 html 中在的选中元素里，生成一个子元素，放在最前面或最后面，但伪元素不会出现在 html 中：

```
/**
 * 默认是行盒
 * content 必须指定，"" 也可以
 * CSS3 之后也可以使用 :
 */
.box::before,
.box::after {
  display: block;
  border: 1px solid #000;
  width: 10px;
  height: 10px;
  background-color: #000;;
  content: "";
}
```

伪类选择器，用于在特定的状态下展示特定的样式：

```
/* 鼠标经过时的样式 */
.box:hover {}

/* input 聚焦的样式 */
input:focus {}

/**链接伪类
 * link    未访问
 * visiter 已访问
 * active  点击
 */
a:link {}
a:visiter {}
a:active {}
```

伪元素使用伪类：

```
.box:hover::before {}
```

（4）CSS3 新选择器

```
/* 多类选择器，选中同时具备这些 class 的元素，只限于 class */
.box.big {}

/**结构伪类选择器
 * E:nth-child() 找到 E 的父元素，并按规则找 E 最近一级子元素
 * n 从 0 开始，但是没有第 0 个元素
 * -child 和 E 无关，-of-type 和 E 有关
 */
.item:first-child {}
.item:first-of-type {}
.item:last-child {}
.item:last-of-type {}
.item:nth-child(1) {}
.item:nth-of-type(1) {}
.item:nth-child(n) {}
.item:nth-of-type(n) {}
/* 奇数 */
.item:nth-child(odd) {}
.item:nth-child(2n + 1) {}
/* 偶数 */
.item:nth-child(even) {}
.item:nth-child(2n) {}

/* 否定伪类选择器，选择不符合条件的元素 */
/* 选中 .item 且不是 .title 的元素 */
.item:not(.title)
```

### 1.4 显示模式

（1）显示、隐藏

隐藏时不删除元素，保留位置，只会引起 repaint ：

```
.box {
  /* 默认值，继承父盒子的 visibility */
  visibility: inherit;

  /* 隐藏、显示 */
  /* visibility: hidden; */
  /* visibility: visible; */

  /* 隐藏表格行或列 */
  /* visibility: collapse; */
}

/* 设置透明度实现，0 完全隐藏 ，1 完全显示 */
.box {
  opacity: 0;
  /* opacity: 1; */
}

/* 也可以用绝对定位，放在最下面 */
```

不删除元素，不保留位置，会引起 reflow ：

```
.box {
  display: block;
  /* display: none; */
}
```

删除元素，用 JS 实现，不保留位置，引起 reflow 。

（2）溢出

盒子溢出：

```
.box {
  /* 默认值 */
  overflow: visible;

  /* 引出的隐藏 */
  /* overflow: hidden; */

  /* 引出的用滚动实现，auto 会在适合时添加滚动条，scroll 强制添加滚动条 */
  /* overflow: auto; */
  /* overflow: scroll; */
}
```

文本溢出：

```
/* 单行 */
.box {
  /* 溢出文本不换行，并隐层 */
  white-space: nowrap;      
  overflow: hidden;       

  /* 省略号 */  
  text-overflow: ellipsis;
}

.box2 {
  display: -webkit-box;
  -webkit-box-orient: vertical;

  /* 多少行后开始隐藏 */
  overflow: hidden;
  -webkit-line-clamp: 3;

  /* 省略号 */
  text-overflow: ellipsis;
}
```

图片溢出：

```
/* box 宽高不固定 */
.box > img {
  width: 100%;
  height: 100%;
}

/* box 宽高其中一个固定，若 box width 固定则 img width 100% ，反之 height 100% */
.box > img {
  width: 100%;
}

/* box 宽高固定，裁剪 img 的宽或高 */
.box {
  overflow: hidden;
}

,box > img {
  width: 100%;
}

/* box 宽高不固定，不裁剪 img ，则 img 的 width ，height 更大的设置为 100% */
.box > img {
  width: 100%;
}
```

### 1.5 变换

CSS3 新特性。

transform 不会 reflow 和 repaint ，运行在合成线程，所以性能很高，不会阻塞 JS 。

不会影响其他盒子的布局，因为会脱离标准流，但 transform 元素的所有后代元素都会一起变换。

2D：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        border: 1px solid #000;
        width: 100px;
        height: 100px;
        background-color: #000;
        color: #fff;
        line-height: 100px;
        text-align: center;
        font-size: 30px;
      }

      /* 2D */
      .box1 {
        /* 默认值 */
        transform: none;

        /**移动
         * 参数为 x，y，可以是 number ，负数，也可以是 %
         * 可以只写 x ，y 默认为 0
         * 也可以用 translateX() translateY()
         */
        /* transform: translate(200px, 200px); */

        /**缩放
         * 大于 1 时放大，小于 1 是缩小
         * 只有一个值时作用于 x，y，两个值时分别设置 x，y 的缩放
         * 也可以用 scaleX() scaleY()
         * 浏览器字体大小有最小限制，可以用 scale 解决
         */
        /* transform: scale(2); */

        /**旋转
         * 只能传一个参数，按 Z 周顺时针旋转
         * 2d 只能 Z 轴旋转，rotateX() 这些是 3d 用的
         */
        /* transform: rotate(45deg); */
        /* transform-origin: left bottom; */

        /**倾斜
         * 也可以用 skewX() skewY()
         */
        /* transform: skew(45deg); */
        /* transform: skew(0, 45deg); */

        /* 多重变换时，需要写成如下形式，否则后面的 transform 会覆盖前面的 */
        transform: translate(0200px, 200px) scale(2) rotate(45deg)
          skew(0, 45deg);
      }
    </style>
  </head>
  <body>
    <div class="box box1">2D</div>
  </body>
</html>
```

3D：

Z 轴在屏幕内部：

```
Y
|
|
|------>X
```

### 1.6 其他

（1）用户界面样式

```
.box {
  /* 光标样式 */
  cursor: pointer;
}
```

（2）CSS 三角

```
.item1 {
  border: 50px solid transparent;
  border-left-color: black;
  width: 0;
  height: 0;
}
```

（3）精灵图：

将大量小图片合到一张大图片，一次请求就能获取大量图片，能减少对服务器的请求，减少服务器压力。

盒子的宽高，背景图为精灵图，再通过设置背景图的偏移达到裁剪精灵图的目的。

```
<style>
  .sprite {
    background: url("../1.png") no-repeat;
    display: inline-block;
  }
</style>

<body>
  <div class="sprite" style="background-position: 0 0; width: 100px; height: 100px"></div>
  <div class="sprite" style="background-position: -50 -50; width: 100px; height: 100px"></div>
</body>
```

（4）字体图标

看似是图标，实际是文字，可以设置字体文本类样式。

图标库：[https://icomoon.io/](https://icomoon.io/) [https://www.iconfont.cn/](https://www.iconfont.cn/)

引入使用示例：

```
<style>
@font-face {
    font-family: 'FontAwesome';
    src: url('/fonts/fontawesome-webfont.eot');
    src: url('/fonts/fontawesome-webfont.eot?#iefix') format('embedded-opentype'),
         url('/fonts/fontawesome-webfont.woff2') format('woff2'),
         url('/fonts/fontawesome-webfont.woff') format('woff'),
         url('/fonts/fontawesome-webfont.ttf') format('truetype'),
         url('/fonts/fontawesome-webfont.svg#fontawesomeregular') format('svg');
    font-weight: normal;
    font-style: normal;
}
</style>

<body>
    <i class="fa fa-star"></i>
</body>
```

### 1.6 属性计算

样式计算只与 CSS 有关，和 HTML 的 class 顺序无关。

计算后，每个元素所有的 CSS 属性都会有 value ，且 value 都是绝对单位，如 em 变 px ，颜色都变成 rgb() 。

根据默认样式表、作者样式表计算，过程：

- 确定声明值：没有冲突的属性直接是结果

- 层叠冲突：
  
  - 比较虫咬行：行内样式表 > 内部样式表 > 外部样式表 > 默认样式表，此外一些属性重要性也有区别，如使用 flex: 1; 后 width 失效
  
  - 比较优先级：根据权重比较选择器的优先级
  
  - 比较源次序：若还是有冲突，则后面的属性、选择器覆盖前面的

- 继承：若还有无 value 的属性，就继承，一般文字、文本属性可以继承
  
  - line-height 继承：px 和比例直接继承，百分比会在父元素计算成 px 后再继承

- 使用默认值：若还有无 value 的属性，就使用默认值
  
  - 复合属性会覆盖前面的属性，如：
    
    ```
    .box {
      font-weight: 700;
    
      /* 符合属性没有写 font-weight ，所以使用默认值 400 覆盖前面的 700 */
      font: 50px "Microsort Yahei";
    }
    ```

（1）选择器的权重

Specificity，也叫特殊性、特定性，权重从高位开始比较，如 0100 大于 0010 。

符合选择器的权重计算：各个位分开计算，十进制求和，且无进位。

```
/* 0 0 0 0 ，* > + ~ */
* {}

/* 0 0 0 1 ，标签，伪元素 */
#app {}

/* 0 0 1 0 ，类、伪类、属性 */
.box {}
:hover {}
[href] {}

/* 0 1 0 0 ，id */
div {}

/* 1 0 0 0 ，行内样式 */

/**1 0 0 0 0 或无穷大
 * 应当尽量避免使用、不好维护
 * important 互相冲突了，就比较权重，用权重大的 important
 * 子元素继承时，只会继承 value ，不继承 important 
 */
.box {
  color: red !important;
}
```

```
/* 0 0 2 0 */
.box:hover {}
.box > .item {}
.box[href] {}

/* 0 1 1 0 */
#app > .box {}

/* 0 0 12 0 */
.a .b .c .d .e .f .g .h .i .j .k .l .m {}
```

## 2 视觉格式化模型

根据各个盒子的几何信息（大小、位置）进行布局。

### 2.1 包含块

包含块（container block），设置百分比的 margin、border、padding、width 时，是基于包含块的宽度，百分比 height 基于包含块的高度；浮动、绝对定位也是基于包含块的。

分为两类：

- 初始包含块：inital container block ，即根元素 <html> 所在的包含块，即视口 viewport，左上角是浮动、定位的参照物

- 非根元素包含块，有以下几种情况：
  
  - 标准流、浮动、定位（static、relative、sticky）的包含块是最近的祖先块盒的 content
  
  - 定位 fixed 的包含块是 viewport
  
  - 定位 absolute 的包含块是最近的非 static 祖先块盒的 padding 区（根元素 <html> 默认定位 relative）

absoulte 、fixed 在找到包含块之前，遇到了以下情况的盒子，则这个盒子的 padding 就成为包含块：

- transform 或 perspective 不为 none

- will-change 为 transform 或 perspective

- contain: paint;

- filter 不为 none，或 will-change 为 filter （只在 firefox 有效）

### 2.2 布局

（1）常规流

也叫标准流、普通流、流式布局、百分比布局，即快盒独占一行，行盒、行内快盒一行多个：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        border: 1px solid #000;
        width: 300px;
        height: 100px;
        background-color: #000;
      }

      .item {
        border: 1px solid red;
        width: 30%;
        height: 30%;
        background-color: red;
      }
    </style>
  </head>
  <body>
    <div class="box">
      <div class="item"></div>
      <div class="item"></div>
    </div>
  </body>
</html>
```

（2）浮动

浮动元素会脱离标准流，浮动起来，不保留原位置，浮动元素按顺序排列在包含块中，若包含块宽度不够放，则浮动元素会排列至下一行。

虽然会脱标，但不会压住一上来的文本和图片。

浮动元素会自动转为 inline-block ：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        border: 1px solid #000;
        width: 300px;
        height: 100px;
        background-color: #000;
      }

      .item {
        float: left;
        border: 1px solid red;
        width: 30px;
        height: 30px;
        background-color: red;
      }
    </style>
  </head>
  <body>
    <div class="box">
      <div class="item">123</div>
      <div class="item">123</div>
    </div>
  </body>
</html>
```

通常都是希望父元素不设置 height ，而由子元素决定父元素的 height ，但设置浮动后，父元素的 height 会变为 0 ，所以这时候就需要清除浮动（清除浮动元素造成的影响）：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        /* 兼容低版本 IE */
        *zoom: 1;

        border: 1px solid #000;
        width: 300px;
        background-color: #000;
      }

      /**
       * 也可以只用一个伪元素，用两个更严谨
       * 也可以直接在 html 写一个标签并设置 clear ，但不推荐
       */
      .box::before,
      .box::after {
        display: block;
        /* 清除左右浮动，也可以只清除仪表，如 clear: left; */
        clear: left;
        visibility: hidden;
        content: "";
      }

      .item {
        float: left;
        border: 1px solid red;
        width: 30px;
        height: 30px;
        background-color: red;
      }
    </style>
  </head>
  <body>
    <div class="box">
      <div class="item">123</div>
      <div class="item">123</div>
    </div>
  </body>
</html>
```

也可以直接把父元素变成 BFC ，就能清除浮动。

（3）定位

将盒子定到某一位置不动，由定位模式和边偏移两部分组成：

- 定位通过 position 指定，默认为 static ，即静态定位

- 边偏移通过 top、right、bottom、left 指定，表示距包含块的距离

代码：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <style>
    .box {
      position: relative;
      border: 1px SOLID #000;
      width: 500px;
      height: 3000px;
      background-color: #000;
    }

    .item {
      border: 1px SOLID RED;
      width: 100px;
      height: 50px;
      line-height: 50px;
      text-align: center;
      font-size: 20px;
      background-color: RED;
    }

    /* 相对定位，保留位置，不脱标 */
    .item1 {
      position: relative;
      top: 50px;
      left: 50px;
    }

    /**绝对定位
     * 不保留位置，脱标，会转为 block 盒
     * auto 的 width 为内容宽度
     * 包含块为最近的非 static 盒子，所以一般父元素会设置 relative ，即子绝父相
     */
    .item2 {
      position: absolute;
      top: 50px;
      right: 50px;
    }

    /**固定定位
     * 不保留位置，脱标，会转为 block 盒
     * auto 的 width 为内容宽度
     * 包含块为浏览器 viewport
     */
    .item3 {
      position: fixed;
      top: 0;
      right: 0;
    }

    /**粘性定位
     * relative 基础上，在父元素内 fixed
     * 必须设置 top 才有效
     */
    .item4 {
      position: sticky;
      top: 0;
      left: 15%;
    }
  </style>
  <body>
    <div class="box">
      <div class="item item1">relative</div>
      <div class="item item2">absolute</div>
      <div class="item item3">fixed</div>
      <div class="item item4">sticky</div>
    </div>
  </body>
</html>
```

z-index ：

当定位元素层叠到一起时，可以用 z-index 设置层叠的优先级：

```
/**
 * 只有设置了非 static 的 position ，z-index 才有效
 * 若设置了浮动，需要清除浮动 z-index 才有效
 * 若父元素 position 为 relative ，则子元素 z-index 失效
 */
.item {
  position: absolute;
  z-index: 999;
}
```

层得上下文：

z-index 时基于包含块的，若包含块的祖先元素也设置了 z-index ，可以看成两个 z-index 相加。

（4）flex 布局

又叫弹性布局，伸缩布局等。父元素是弹性容器，子元素是弹性盒子。

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        margin: 50px 0;
        border: 1px solid #000;
        padding: 10px;
      }

      .item {
        border: 1px solid #000;
        width: 60px;
        height: 30px;
        line-height: 30px;
        text-align: center;
      }

      .box1 {
        /**
         * 子元素会转换成 block 盒，水平显示，但 width，height 会默认设置为内容宽高
         * 设置 display: flex; 后，float、clear、vertical-align 失效
         * 若没有设置 align-items ，且子元素也没有设置 height ，则子元素 height 会撑满父元素
         * 上述情况若父元素也没有设置 height ，则父元素 height 时子元素内容高度
         */
        display: flex;

        /**主轴排列方式
         * flex-start     左排列，默认值
         * flex-end       右编列
         * center         居中
         * space-around   均分
         * space-evenly   均分，且空隙一样大
         * space-between  两边到边缘，中间均分
         */
        justify-content: center;

        /**侧轴排列方式
         * stretch  默认值，撑满父元素
         * flex-start ，flex-end，center
         * 子元素中可用 align-self 单独设置
         */
        align-items: center;

        /**轴向
         * 默 x 为主轴，y 周为侧轴
         * 设置主轴，默然为 row
         */
        /* flex-direction: column; */
      }

      .box2 {
        display: flex;
      }

      .box2 > .item-flex {
        /**
         * 只要设置了 flex ，width，flex-wrap 就无效
         * 设置 flex 的盒子，均分剩余的 content width ，value 为占用的份数
         * flex: none; 去掉 flex
         */
        flex: 1;
      }

      .box2 > .item-fixed {
        /* 设置排列优先级，默认 0 ，大的会排列在小的后面 */
        order: 1;
      }

      .box3 {
        display: flex;
        height: 100px;

        /**换行
         * flex 布局默认不换行，空间不够会压缩子元素的 width
         * 若不换行，又不想压缩 width ，可以在子元素设置 flex-shrink: 0;
         */
        flex-wrap: wrap;

        /* direction，wrap 符合写法 */
        /* flex-flow: column wrap; */

        /**多行的侧轴排列方式
         * stretch  默认值
         * 其他和 justify-content 一样
         */
        align-content: space-around;
      }

      .box3 > .item-big {
        width: 40%;
      }
    </style>
  </head>
  <body>
    <div class="box box1">
      <div class="item">1</div>
      <div class="item">2</div>
      <div class="item">3</div>
    </div>

    <div class="box box2">
      <div class="item item-fixed">1</div>
      <div class="item item-flex">2</div>
      <div class="item item-flex">3</div>
    </div>

    <div class="box box3">
      <div class="item item-big">1</div>
      <div class="item item-big">2</div>
      <div class="item item-big">3</div>
      <div class="item item-big">4</div>
    </div>
  </body>
</html>
```

（5）grid 布局

也叫网格布局、栅格布局。

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        margin: 50px 0;
        border: 1px solid #000;
        height: 300px;
      }

      .item {
        border: 1px solid #000;
        line-height: 50px;
        text-align: center;
        font-size: 30px;
      }

      .box1 {
        /* 子元素转为 block 盒子 */
        display: grid;

        /**列栅格
         * 1 个 value ，排列 1 个
         * 可以使用 repeat(3, 1fr)
         * 子元素可以不用设置 width ，会自动沾满整个栅格，而栅格的高是内容高度
         * 可以设置 px ，其他的 fr 均分，fr 的 value 是占用的份数
         */
        /* grid-template-columns: 1fr 1fr 1fr; */
        /* grid-template-columns: 1fr 200px 1fr; */
        grid-template-columns: repeat(3, 1fr);

        /**行栅各
         * 格rid-template-rows 优先级高，剩余未指定的 grid-auto-rows 才生效 
         * 子元素可以不用设置 height ，会自动沾满整个栅格，而栅格的宽是内容宽度
         */
        /* grid-template-rows: repeat(3, 1fr); */
        /* grid-auto-rows: 10px 10px 10px; */

        /* 栅格水平、水质排列方式，没有设置 grid-template-columns、grid-template-rows 才需要考虑 */
        /* justify-content: center; */
        /* align-content: center; */

        /**
         * 除了四个边缘外，栅格之间的间距
         * gap 是简写
         * gap: row col;
         * gap: row-and-col;
         */
        gap: 10px;
        /* grid-row-gap: 10px; */
        /* grid-column-gap: 10px; */
        /* grid-gap: 10px; */
      }

      .box2 {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;

        /* grid-template-areas:
          "areaname areaname"
          "areaname areaname"; */
      }

      .box2 > .item:first-child {
        /**合并栅格
         * 左闭右开，只差 1 可以只写简写成 grid-column; 2;
         * grid-column 是 grid-column-start 、grid-column-end 的简写
         */
        /* 布局到第 2 列并不合并，布局到第 1 行并合并一个栅格 */
        grid-column: 2 / 3;
        grid-row: 1 / 3;

        /* 也可以命名，在父元素中布局合并栅格 */
        /* grid-area: areaname; */
      }

      .box3 {
        /* 响应式布局，minmax() 为栅格的最小、最大宽度 */
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 10px;
      }
    </style>
  </head>
  <body>
    <div class="box box1">
      <div class="item">1</div>
      <div class="item">2</div>
      <div class="item">3</div>
      <div class="item">4</div>
      <div class="item">5</div>
    </div>

    <div class="box box2">
      <div class="item">1</div>
      <div class="item">2</div>
      <div class="item">3</div>
      <div class="item">4</div>
      <div class="item">5</div>
    </div>

    <div class="box box3">
      <div class="item">1</div>
      <div class="item">2</div>
      <div class="item">3</div>
      <div class="item">4</div>
      <div class="item">5</div>
    </div>
  </body>
</html>
```

### 2.3 BFC

块级格式化上下文（block formating context），让标准流的块盒形成独立的渲染区域，

<html> 默认是 BFC 。

同一个 BFC 中的垂直排列块盒，上下 margin 会合并：

- 若两个盒子的最近一个祖先 BFC 元素是同一个，就属于同一个 BFC 中

- 若某个 BFC 脱离了标准流，那这个 BFC 就从最近一个祖先 BFC 中脱离出来了

设置 BFC ：

```
/**
 * 只要有其中一个，就能形成 BFC
 * 还有喝多属性可以设置，不过这些最常用
 */
 .box {
  /* 不为 none、block */
  /* display: inline-block; */

  /* 绝对定位 */
  /* overflow: hidden; */

  /* 不为 static、relative */
  /* position: absolute; */
}
```

（1）非父子块盒上下 margin 合并

两个垂直相邻的块盒，上面的 margin-bottom 会和下面的 margin-top 合并，原因是两个块盒都处于 <html> 的 BFC 中；

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        border: 1px solid #000;
        width: 50px;
        height: 50px;
        background-color: #000;
      }

      /**margin 合并规则
      * 两个正数：Math.max(a, b)
      * 两个负数：Math.min(a, b)
      * 一正一负：a + b
      */
      .box1 {
        margin-bottom: 50px;
        /* margin-bottom: -40px; */
        /* margin-bottom: 30px; */
      }

      .box2 {
        margin-top: 50px;
        /* margin-top: -40px; */
        /* margin-top: -20px; */
      }
    </style>
  </head>
  <body>
    <div class="box box1"></div>
    <div class="box box2"></div>
  </body>
</html>
```

解决方法是，可以把其中一个块盒用 BFC 容器包裹，这样一个在 <html> 的 BFC 中，另一个在新的 BFC 中，就不会合并 margin 了：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .container {
        overflow: hidden;
        background-color: #000;
      }

      .box {
        width: 50px;
        height: 50px;
        background-color: red;
      }

      .box1 {
        margin-bottom: 50px;
      }

      .box2 {
        margin-top: 50px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="box box1"></div>
    </div>
    <div class="box box2"></div>
  </body>
</html>
```

（2）父子块盒的上下 margin 塌陷问题

若父元素 border，padding 都没有设置，会造成父子盒子同事设置 margin-top 时，父元素的 margin-top 塌陷的情况，margin-bottom 同理：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      /**margin 塌陷
       * 子元素 margin-top 无效
       * 父元素的 margin-top 和 子元素的 margin-top 合并，规则和上下块盒 margin 合并一样
       * 即使父元素没有设置 margin-top ，只要子元素设置了，就会塌陷
       **/
      .box {
        margin-top: 50px;
        width: 100px;
        height: 100px;
        background-color: #000;
      }

      .item {
        margin-top: 20px;
        width: 50px;
        height: 50px;
        background-color: red;
      }
    </style>
  </head>
  <body>
    <div class="box">
      <div class="item"></div>
    </div>
  </body>
</html>
```

两种解决方法：

- 父元素设置 BFC ，这样子元素和父元素所处的 <html> 的 BFC 就不是同一个了

- 子元素设置浮动或绝对定位实现 BFC ，脱离标准流，和父元素 BFC 就不是同一个了

（3）浮动和 BFC

标准流中，父元素 auto 的 height 不会计算浮动元素的 height ，而 BFC 会，所以 BFC 可以清除浮动。

BFC 也不会覆盖浮动元素压住：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        overflow: hidden;
        background-color: #000;
        color: #fff;
      }

      .nav {
        float: left;
        width: 50px;
        height: 50px;
        background-color: red;
      }

      /**content 设置 BFC 后
       * content 就不会被浮动的 nav 压住
       * 此时 content 会自带 margin-left ，即 content 到父元素左边缘的距离
       * 若自己设置的 margin-left 小于到父元素左边缘的距离，是无效的，如果像控制 margin ，可以设置浮动元素的 margin-right ，更方便
       */
      .content {
        overflow: hidden;
        height: 100px;
        background-color: blue;
      }
    </style>
  </head>
  <body>
    <div class="box">
      <div class="nav"></div>
      <div class="content"></div>
    </div>
  </body>
</html>
```

### 2.4 居中

（1）行盒、行内快盒

```
.box {
  width: 100px;
  height: 50px;
  line-height: 50px;
  text-align: center;
}

/* border-box ，line-height 需要减去 border、 padding */
.box {
  box-sizing: border-box;
  border: 1px solid #000;
  padding: 10px 0;
  width: 100px;
  height: 50px;
  line-height: 28px;
  text-align: center;
}

/* border-box 计算 line-height 比较麻烦，也可以直接用 flex */
.box {
  box-sizing: border-box;
  border: 1px solid #000;
  padding: 10px 0;
  width: 100px;
  height: 50px;
  display: flex;
  justify-content: center;
}
```

（2）块盒

```
/* flex 单行水平垂直居中 */
.box1 {
  display: flex;
  justify-content: center;
  align-items: center;
}

/* flex 多行水平垂直居中 */
.box2 {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-content: center;
}

/* 相对于父元素，只有水平居中，适合 PC 端版心居中 */
.box3 {
  margin: 0 auto;
}

/* 绝对定位 */
.box4 {
  position: relative;
  border: 1px solid #000;
  width: 200px;
  height: 100px;
}

.box > .item {
  position: absolute;
  top: 50%;
  left: 50%;
  border: 1px solid #000;
  width: 50px;
  height: 50px;

  /* 方式一，推荐 */
  transform: translate((-50%, -50%));

  /* 方式二，写死，不推荐 */
  /* margin-top: -25px; */
  /* margin-left: -25px; */

  /* 方式三，不推荐 */
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: auto;
}
```

### 2.5 响应式布局

（1）视口

视口（viewport），浏览器显示页面的屏幕区域。手机默认都有一个布局视口，是尽量显示整个PC端页面，手指缩放的形式，很不方便，后来就有了视觉视口，显示部分 PC 端页面，手指左右滑动的形式。

现在使用的是理想视口，页面宽度即视口宽度，通过视口标签指定：

```
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

指定视口宽度为设备宽度，其他属性可以设置缩放比例以及是否可缩放。

（2）分辨率

屏幕真实的分辨率是物理分辨率，px 是逻辑分辨率，PC端是 1 : 1 的，而移动端中，物理 : px = n : 1，这叫物理像素比：

```
// 获取当前的物理像素比
console.log(window.devicePixelRatio);
```

因此，图片放到移动端中，会放大 n 倍而模糊，所以在开发中，拿到图片先要将它缩小 n 倍再放到页面中，它会自动方放大 n 倍，就能不营销图片清晰度。因此，准备图片应当按照物理像素比来，叫n倍图。

缩小图片是用软件工具缩小，而不是写代码。

（2）单位

em：

当前元素 font-size 的倍数：

```
.box {
  /* 2em === 40px */
  width: 2em;
  font-size: 20px;
}
```

rem：

root em，CSS3 新增，与 em 不同的是只基于 <html> 的 font-size ，可配合多媒体查询实现进一步适配。

```
html {
  /* 浏览器默认一般是 16px */
  font-size: 16px;;
}

.box {
  /* 32px */
  width: 2rem;
}
```

vw，vh：

viewport 宽度为 100vw ，vh同理，会随着 viewport 的变化自动适配，通常 vw 用的比较多。

```
.box {
  width: 50vw;
  height: 50vw;
}
```

（3）布局

一般用流式布局、flex 布局。

为了避免过多的缩放，可以限制最大最小的 width ：

```
body {
  max-width: 1920px;
  min-width: 360px;
}

.box {
  max-width: 100px;
  min-width: 50px;
}
```

多媒体查询，可以根据不同视口宽度，设置不同的样式：

```
/* 视口宽度在 350px 到 750px 之间时，以下样式适用 */
@media screen and (min-width: 375px) and (max-width: 750px) {
  body {
      background-color: red;
  }
}
```

（4）移动端的历史遗留问题

移动端click事件300ms延迟

原因：移动端浏览器一般都有双击缩放或双击xxx的场景，为了监听出双击，在点击第一次后，若300ms内再次点击，就是双击。
但是大部分情况下，300ms都是很难被用户接受的

解决：有很多方法，其中一种：

```
npm install fastclick --save
// main.js
import FastClick from 'fastclick'
FastClick.attack(document.body)
```

## 3 CSS 预处理器

有 less 和 sass：

- 区别是定义变量，less 用 @ ，sass 用 $

- scss 时 sass 的高版本

以下就以 less 为例：

```
npm install -g less
```

解析成 .css ：

```
lessc ./1.less ./1.css
```

less 中导入其他 less 和 css ：

```
@import "./1.less";
```

注释：

```
// 单行注释不会出现在生成的 css 中
/* 多行注释会保留 */
```

变量：

```
// less
@my-color: #000;
@pre: .box;

.box {
  color: @my-color;
}

@{pre}-title {
  color: @my-color;
}
```

```
/* css */
.box {
  color: #000;
}
.box-title {
  color: #000;
}
```

变量运算，最终单位是最早出现的单位：

```
// less
@my-width: 10 + 20px;
@my-height: 20em + 20 + 40px;

.box {
  width: @my-width;
  height: @my-height;
}
```

```
/* css */
.box {
  width: 30px;
  height: 80em;
}
```

选择器嵌套：

```
// less
// & 时上一级选择器，选择器中 & 只能出现一次
.box {
  font-size: 20px;

  .item {
    color: #000f
  }

  &:hover {
    color: #000f
  }

  &.big {
    color: #000f
  }
}
```

```
/* css */
.box {
  font-size: 20px;
}
.box .item {
  color: #000f;
}
.box:hover {
  color: #000f;
}
.box.big {
  color: #000f;
}
```

函数：

```
// less
// 没有参数时，括号可以省略
.my-flex(@width) {
  display: flex;
  justify-content: center;
  align-items: center;
  width: @width;
}

.my-border(@a, @b, @c) {
  border: @arguments;
}

.my-height(@type) when(@type = big) {
  height: 100px;
}

.my-height(@type) when(@type = small) {
  height: 50px;
}

.box {
  // 调用时必须加上括号
  .my-flex(200px);
  .my-border(1px, solid, #000);
  .my-height(big);
}
```

```
/* css */
.box {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 200px;
  border: 1px solid #000;
  height: 100px;
}
```

循环：

```
// less
.my-for(@i) when (@i > 0) {
  .my-padding-@{i} {
    padding: @i * 10px;
  }
  .my-for(@i - 1);
}

.my-for(3);
```

```
/* css */
.my-padding-3 {
  padding: 30px;
}
.my-padding-2 {
  padding: 20px;
}
.my-padding-1 {
  padding: 10px;
}
```

多媒体查询：

```
// less
.box {
  @media screen and (max-width: 750px) {
    .nav {
      display: none;
    }
  }
}
```

```
/* css */
@media screen and (max-width: 750px) {
  .box .nav {
    display: none;
  }
}
```

## 4 CSS 原子化

# 三、JS

（1）ES5

JS 是面向对象的脚本语言，组成：

* ECMAScript（ES，JS的语法）

* DOM（页面文档对象模型，对标签进行操作实现动态效果）。

* BOM（浏览器对象模型，操作浏览器窗口）

JS 书写位置：

* 行内式，标签内书写 事件=””

* 内嵌式，<script>JS代码</script>

* 外部式，<script src=”xxx.js”>此处不能写代码</script>，

（2）ES6

这里说的 ES6 语法，包含 ES6 之后各个新版本的特性（ES6 - ES13）。

需要考虑浏览器的兼容性，若 node 不支持，就升级更高版本的 node 。

babel ：奖惩 ES6 以上语法和 TypeScript 转化为 ES5 代码的工具。

关于新特性：

自从 TC39 进程指定以来，新特性提案阶段就比 ECMA 版本更为重要，因为某个 ECMA 版本发布的新特性不一定全部能用，未正式发布的新特性也可能可以使用，能不能用得看这个新特性是否处于第4个提案阶段。

ECMA 新特性的指定分为 4 个阶段，当处于第 4 阶段的新特性才能正式使用。如果想看这些正式可用的新特性有哪些，可访问：

```
https://github.com/tc39/proposals/blob/main/finished-proposals.md
```

如果想看正在开发测试中的新特性，可以访问：

```
https://github.com/tc39/ecma262/blob/main/README.md
```

## 1 基本

注释、输入输出

```
// 单行注释
/* 多行注释 */
/**
 * 文档注释
 */

// 单引号、双引号都可以，分号加不加都可以
var str = "asdf";

// 输入
// var a = prompt("请输入");

// 输出，浏览器有时候输出时机不一定对，需要注意
var aaa = [{ a: 123 }];
// 可能有时候会输出修改后的 456
console.log(aaa);
aaa[0].value = 456;
```

### 1.1 变量

作用域：

- 全局作用域

- 局部作用域，即函数内部

- 块级作用域，if 、for 等内部，let 、const 具有块级作用域，而 var 没有。

var 以及 ES6 的 let 、const ：

```
/**预编译（预解析）会有提升，提升到当前作用域最前面 --------------------------------------------
 * var 和保存在变量的匿名函数的声明会提升，但不提升值，所以使用不报错且值为 undefined
 * 具名函数也会提升且保留值
 * let 、cosnt 、class 等也会提升，但是在声明之前是暂时性死区（TDZ），不允许使用
 */
// undefined
console.log(a);

// err
try {
  console.log(b, c);
} catch {
  console.log("err");
}

// hasNameFunc undefined
console.log(hasNameFunc, notNameFunc);

// err ，只会提升到当前作用域
try {
  console.log(testVar);
} catch {
  console.log("err");
}

function test() {
  // undefined func
  console.log(testVar, func, "\n");

  var testVar = "test";
  function func() {}
}
test();

/**声明 -----------------------------------------------------------------------------------
 * let 变量、const 敞亮，const 由于不能修改所以必须初始化
 * 未初始化的 var 、let 为 undefined
 * const 声明的引用类型自己的引用无法修改，但是堆内存的数据可以修改
 */
var a = 1;
let b = 2;
const c = 3;

// 标识符命名与 C 语言唯一不同是还可以用 $
var a_1$;

// 具名函数、匿名函数
function hasNameFunc() {}
var notNameFunc = function () {};

/**重复声明 ---------------------------------------------------------------------------------
 * var 设计缺陷，重复声明不报错
 * 用了 let 、const 就不能重复声明，即使是 let 声明之前的 var
 */
// ok
var a = 1;

// err
// let b = 22;
// let a = 11;
// var b = 222;

// 块级作用域 -----------------------------------------------------------------------------
for (var i = 0; i < 10; i++);
for (let j = 0; j < 10; j++);

// 10 err ，var 设计缺陷，没有快级作用域，而 let 、const 都有
console.log(i);
// console.log(j);
```

全局污染：

```
<!DOCTYPE html>
<html lang="en">
  <body></body>

  <script>
    /**全局污染
     * 全局作用域中的 var 和具名函数会加入到 window 中，let 、cosnt 则不会
     * node 则不会加到 node 全局对象中
     */
    var a = 1;
    let b = 2;
    const c = 3;

    function func1() {}
    var func2 = function () {};
    let func3 = function () {};
    const func4 = function () {};

    // 1 undefined unfined func1 func2 undefined unfined
    try {
      // 浏览器环境
      console.log(
        window.a,
        window.b,
        window.c,
        window.func1,
        window.func2,
        window.func3,
        window.func4
      );
    } catch {
      // undefined ，node 环境
      console.log(
        globalThis.a,
        globalThis.b,
        globalThis.c,
        globalThis.func1,
        globalThis.func2,
        globalThis.func3,
        globalThis.func4
      );
    }
  </script>

  <script>
    // 但是 var 、let 、const 、函数都会跨 script 标签
    console.log(a, b, c, func1, func2);
  </script>

  <script>
    /**若变量未使用 var 、let 、cosnt 声明
     * 此时必须赋值，否则 err
     * 不管哪一个作用域，浏览器都会放到 window ，node 都会放到 node 全局对象
     * 严格模式下，不允许这种情况，直接 err
     */
    // 下面的情况等价于 window.xxx = value 或 globalThis.xxx = value
    aa = 1;
    ff2 = function () {};

    function ff1() {
      bb = 2;
    }
    // 必须运行 ff1 ， bb 才会加入到 window 和 node 全局对象
    ff1();

    // 1 2 func ，当然调用时 globalThis 可以省略
    console.log(globalThis.aa, globalThis.bb, globalThis.ff2);
  </script>
</html>
```

### 1.2 数据类型

（1）ES5 类型

数据类型只有 8 种，7 个基本类型 \+ 1 个引用类型；

* 基本类型：number、string、boolean、null、undefined、以及 ES6 以后的 Symbol、BigInt

* 引用类型：Object、数组、函数等都是对象

null 和 undefined 区别：

* null 是关键字，而 undefined 不是

* null 通常表示空引用，而 undefined 表示未定义、空值

* null 转 number 为 0 ，undefined 转 number 为 NaN

* null 用 typeof 判断为 object ，而 undefined 判断正常

```
// 声明 -----------------------------------------------------------------------------
var t1 = 123;
var t2 = "asdf";
var t3 = true;
var t4 = null;
var t5 = undefined;
var t6_obj = { a: 1 };
var t6_arr = [123, "asdf", true];

// JS 是弱类型语言，赋值可以使其他数据类型
t1 = true;

// PS -----------------------------------------------------------------------------------
// Number 可以是整数、小数等
var n = 3.1415926;
// NaN 表示非数字
var nan = NaN;

// 保留 2 位小数
console.log(n.toFixed(2));

// 最大值、最小值
console.log(Number.MAX_VALUE, Number.MIN_VALUE);

// 4 123
console.log("asdf".length, 123 + "");

// 访问 String
var str = "asdf";
console.log(str.charAt(0), str.charCodeAt(0), str[0]);

// ES6 新特性，模板字符串，可以保留换行符，可以嵌入表达式 ----------------------------------------
var nnn = 12;
var s1 = `
  ${nnn}${1 + 2}4
`;
// 1234 且保留换行符
console.log(s1);

// ES12 新特性，数字分隔符，解决长数字的可读性问题 -----------------------------------------
var a1 = 12_34;
var a2 = 123_4;
// 都是 true
console.log(1234 === a1, a1 === a2);
```

（2）ES6 基本类型

ES6 新特性，基本类型 Symbol：

- 值唯一，且不可见，可用来解决命名冲突问题

- 无法算术运算，比较运算只能用 == \!= === \!== 比较、可以逻辑运算

```
// 声明 ----------------------------------------------------------------------------------
const s1 = Symbol();
const s2 = Symbol();

// 这个字符串并不是值，只是一个说明，用于注释，字符串相同的 Symbol 也是不同的
const s3 = Symbol("asdf");
const s4 = Symbol("asdf");

// 用函数对象创建，当传入的字符串相同时，两个 Symbol 就相同
const s5 = Symbol.for();
const s6 = Symbol.for("123");
const s7 = Symbol.for("123");

// false "Symbol()" ，值唯一，且不可见
console.log(s1 === s2, s1);
// false "Symbol(asdf)"
console.log(s3 === s4, s3);
// false false true
console.log(s5 === s6, s5 === s7, s6 === s7, "\n");

// "asdf" ， ES10 新特性，可以查看 Symbol 的描述字符串
console.log(s3.description, "\n");

// 应用 -----------------------------------------------------------------------------------
const obj = {
  // 自定义独一无二的 key
  [Symbol("asdf")]: 123,

  // 内置 Symbol ，一些 JS 底层会调用这些 key
  [Symbol.hasInstance]: 123,
};

console.log(obj);

// 外部无法访问，因为 Symbol 是唯一的
console.log(obj[Symbol("asdf")]);

// 只有把 Symbol key 保存下来，才能访问到
const key1 = Symbol("qwer");
obj[key1] = 1;
console.log(obj[key1]);
```

ES11 新特性，基本类型 BigInt，用于存放更大的数字，不过只能是整数：

```
// 声明，只能是整数
const a = 123n;
const b = BigInt(456);
const c = BigInt("789");

// err 2n 1 <BigInt 只能和 BigInt 、string 算术运算
try {
  console.log(1n + 1);
} catch {
  console.log("err");
}
console.log(1n + 1n, 1n + "", "\n");

// 1 ，强制转为 number 时需要注意边界
console.log(Number(1n), "\n");

// true false true false
console.log(2n == 2, 2n === 2, 2n > 1, 2n > 2);
```

### 1.3 类型判断、转换

（1）判断数据类型

typeof ，有设计缺陷，null 、Array 、Set 、Map 、WeakSet、WeakMap 等都直接判断为 object ，而函数判断为 function ；

```
// "number" "string" "boolean" "undefined" "symbol" "bigint"
console.log(
  typeof 1,
  typeof "'",
  typeof true,
  typeof undefined,
  typeof Symbol(),
  typeof 1n
);

// 都是 "object"
console.log(
  typeof null,
  typeof [],
  typeof new Set(),
  typeof new Map(),
  typeof new WeakSet(),
  typeof new WeakMap()
);

class Person {}
// 都是 "function"
console.log(typeof (() => {}), typeof Person);
```

数组判断：

```
// true ，用底层 C++ 判断数据结果是否符合数组的特征，所以和原型无关
// 伪数组本质是对象所以判断为 false
console.log(Array.isArray([]));
```

toString  ，所有类型都能正常判断：

```
// "[object Arguments]"，伪数组也能判断
(function () {
  console.log(Object.prototype.toString.call(arguments));
})();

// ES6 新特性，自定义输出结果
const obj = { a: 1 };
obj[Symbol.toStringTag] = "MyType";
// "[object MyType]"
console.log(Object.prototype.toString.call(obj));
```

Symbol\.toStringTag 基本上 ES6 后的新对象都有部署；

```
// ES5 这些就能判断了，所以没部署 Symbol.toStringTag ----------------------------------------
const num = (123)[Symbol.toStringTag];
const arr = [][Symbol.toStringTag];
const obj = {}[Symbol.toStringTag];
const func = (() => {})[Symbol.toStringTag];
const args = (function () {
  return arguments[Symbol.toStringTag];
})();

// undefined
console.log(num, arr, obj, func, args, "\n");

// ES6 新增的大部分都有 Symbol.toStringTag ----------------------------------------------------
const sym = Symbol()[Symbol.toStringTag];
const bigInt = 123n[Symbol.toStringTag];

function* genFunc() {}
const gen = genFunc[Symbol.toStringTag];
const genIte = genFunc()[Symbol.toStringTag];
const promise = new Promise(() => {})[Symbol.toStringTag];
const asyncFunc = async function () {}[Symbol.toStringTag];

const set = new Set()[Symbol.toStringTag];
const weakMap = new WeakMap()[Symbol.toStringTag];
const reflect = Reflect[Symbol.toStringTag];

// "Symbol" "BigInt"
// "GeneratorFuncFunction" "Genertor" "Promise" "AsyncFunction"
// "Set" "WeakMap" "Reflect"
console.log(
  sym,
  bigInt,
  gen,
  genIte,
  promise,
  asyncFunc,
  set,
  weakMap,
  reflect,
  "\n"
);

// class 、迭代器 、proxy 则没有 -----------------------------------------------------------
class A {}
const proxy = new Proxy({}, {});
const ite = [][Symbol.iterator];

const cls = A[Symbol.toStringTag];
const pro = proxy[Symbol.toStringTag];
const it = ite[Symbol.toStringTag];

// undefined
console.log(cls, pro, it);
// "[object Function]" "[object Objct]" "[object Function]"
console.log(
  Object.prototype.toString.call(A),
  Object.prototype.toString.call(pro),
  Object.prototype.toString.call(ite)
);
```

判断 Proxy ：

```
// 判断是否是 Proxy ，用 toString 判断 Proxy 默认会得到原始对象的类型
const p = new Proxy(new Set(), {});
// "[object Set]"
console.log(Object.prototype.toString.call(p));

// 方法一，拦截 new ，可以做复杂的逻辑，如判断是第几层 Proxy --------------------------------------
Proxy = new Proxy(Proxy, {
  construct(target, argsList) {
    const result = new target(...argsList);

    const originType = Object.prototype.toString
      .call(result)
      .slice(1, -1)
      .split(" ")[1];

    result[Symbol.toStringTag] = `Proxy.${originType}`;

    return result;
  },
});

const p = new Proxy([1, 2, 3], {});
const pp = new Proxy(p, {});

// [object Proxy.Proxy.Array] 表示代理两次的 Array
console.log(Object.prototype.toString.call(p));

// 方法二 ---------------------------------------------------------------------------------
// const p = new Proxy(
//   { a: 1 },
//   {
//     get(target, key) {
//       if (key === Symbol.toStringTag) return "Proxy";
//       return target[key];
//     },
//   }
// );
// "[object proxy]"
// console.log(Object.prototype.toString.call(p));
```

（2）数据类型转换

类型转换规则：

- 原始值转原始值：
  
  ```
  /**规则
   * 转为 number：
     - boolean: true -> 1 ，false -> 0
     - string: "" " " "\n" -> 0，"3.14" -> 3.14 ，" 2 " -> 2 ，"1 2" -> NaN ，
               "2n" -> NaN ，"true" -> NaN ，"2n" -> NaN
     - undefined -> NaN ，null -> 0
     - Symbol：无法转换，强制类型转换都不行
     - BigInt：需要注意边界问题
  
   * 转为 string：
     - 3.14 -> "3.14" ，true -> "true" ，NaN -> "NaN" ，null -> "null" ，
       undefined -> "undefined"
     - Symbol：无法隐式转换，但是强制类型转换可以
     - BigInt：2n -> "2"
  
   * 转为 boolean
     - 非空值意义时转为 true：如 1 ，"asdf"" ，包括 Symbol
     - 具有空值、否定意义时转为 false ，如 0 ，"" ，" " ，NaN ，null ，undefined
   */
  ```

- 引用类型转原始值：
  
  ```
  /**规则
   * 按照 Symbol.toPrimitive > valueOf > toString 的优先级调用这些函数，其中 valueOf 和 toString 在原型链上有
   * 上一步转为原始值后， 再进行原始值到原始值的类型转换
   * 特殊情况：转为 boolean 直接全部转为 true ，包括空数组、空对象
   */
  // 自定义这 3 个函数 ----------------------------------------------------------------
  var obj1 = {
    [Symbol.toPrimitive]: function () {
      // 必须 re turn 原始值 ，否则在运算时直接报错，不再去找 valueOf 和 toString
      return 123;
    },
  };
  
  var obj2 = {
    valueOf: function () {
      // 自定义 valueOf 不必须 return 原始值，若 return 引用，运算时也不会报错，会直接忽略这次执行结果，这是历史遗留问题
      // 因此 return 引用时，忽略，会再去调用 toString
      return 456;
    },
  };
  
  var obj3 = {
    toString: function () {
      // 自定义 toString 必须 return 原始值，否则运算时直接报错
      return 789;
    },
  };
  
  // 124 457 790
  console.log(obj1 + 1, obj2 + 1, obj3 + 1, "\n");
  
  // 默认的 valueOf 和 toString ---------------------------------------------------------
  // valueOf 都是返回自己，所以一般默认的 valueOf 都无效，会再去找 toString
  var objValueOf = Object.prototype.valueOf,
    arrValueOf = Array.prototype.valueOf,
    funcValueOf = Function.prototype.valueOf,
    setValueOf = Set.prototype.valueOf,
    mapValueOf = WeakSet.prototype.valueOf,
    weakSetValueOf = Map.prototype.valueOf,
    weakMapValueOf = WeakMap.prototype.valueOf;
  
  var obj = {},
    arr = [],
    func = function () {},
    set = new Set(),
    map = new Map(),
    weakSet = new WeakSet(),
    weakMap = new WeakMap();
  
  // 都是 true
  console.log(
    objValueOf.call(obj) === obj,
    arrValueOf.call(arr) === arr,
    funcValueOf.call(func) === func,
    setValueOf.call(set) === set,
    mapValueOf.call(map) === map,
    weakSetValueOf.call(weakSet) === weakSet,
    weakMapValueOf.call(weakMap) === weakMap,
    "\n"
  );
  
  // toString ，Array 和 Function 重写了 toString
  var objToString = Object.prototype.toString,
    arrToString = Array.prototype.toString,
    funcToString = Function.prototype.toString,
    setToString = Set.prototype.toString,
    mapToString = Map.prototype.toString,
    weakSetToString = WeakSet.prototype.toString,
    weakMapToString = WeakMap.prototype.toString;
  
  // "[object Array]"
  console.log(objToString.call({}), "\n");
  
  // “【object Set】” 等,没有重写 toString ，都是 Object.prototype 的 toString
  console.log(setToString.call(new Set([])));
  console.log(mapToString.call(new Map([])));
  console.log(weakSetToString.call(new WeakSet([])));
  console.log(weakMapToString.call(new WeakMap([])), "\n");
  
  // "" "0" "1" "1,2"
  console.log(arrToString.call([]));
  console.log(arrToString.call([0]));
  console.log(arrToString.call([2]));
  console.log(arrToString.call([1, 2]));
  
  // "(a) => a" ，即整个函数的内容
  // ES10 新特性，会保留空格和换行符
  console.log(
    funcToString.call((a) => a),
    "\n"
  );
  ```

表达式运算中的隐式类型转换：

任何运算的双方都必须是原始值，否则将会隐式类型转换，运算结果也是一个原始值：

```
/**算术运算 ---------------------------------------------------------------------------
 * 除了 string 外的原始值运算，全部转为 number ：
   - NaN 和任何 number 运算都为 NaN ，包括 NaN 自己
   - Symbol 无法算术运算；BigInt 只能和 BigInt、String 算术运算
 * 有 string 和引用类型参与的运算：
   - 加法运算：全部转为 string ，引用类型转为原始值后再转为 string ，进行字符串拼接
   - 其他运算：全部转为 number ，引用类型转为原始值后再转为 number ，进行算数运算
 */
// NaN NaN
console.log(NaN + 1, NaN + NaN);

// NaN 1
console.log(undefined + 1, null + 1);

// "21" "2n" "3.14" "true" "undefined" "null" "NaN"
console.log(
  2n + "1",
  "2n" + "1",
  3.14 + "",
  true + "",
  undefined + "",
  null + "",
  NaN + ""
);

// "1" "21" "1,21" "[object Object]123" "() => {}123" "null" "NaN"
console.log(
  [] + 1,
  [2] + 1,
  [1, 2] + 1,
  {} + 123,
  (() => {}) + 123,
  [] + null,
  [] + NaN
);

// NaN -1 -1 1 1.14 1 NaN 1
console.log(
  "2n" - 1,
  "" - 1,
  " " - 1,
  " 2 " - 1,
  "3.14" - "2",
  "2" / 2,
  "1" - NaN,
  "1" - null
);

// -1 2 NaN NaN NaN 123,5
console.log(
  [] - 1,
  [2] - 0,
  [1, 1] - 1,
  {} - 1,
  (() => {}) - 1,
  "123" + [4, 5]
);

// err ，Symbol 无法算术运算，BigInt 只能和 BigInt、String 算术运算
try {
  // console.log(Symbol() + 1, "\n");
  // console.log(0n + 1, "\n");
  console.log(Symbol() + "", "\n");
} catch (err) {
  console.log("err\n");
}

/** 比较运算 ----------------------------------------------------------------------------
 * 类型相同时，直接比较 value （相同引用类型则比较地址），不会类型转换；类型不同时，全部转为 number ：
   - 引用类型先转为原始值，再转为 number
 * 特殊情况：
   - NaN 和任何数值比较都为 false ， 包括和 NaN 自己
   - undefined == null 不转为 number ，直接返回 true
   - Symbol 只能比较是否相等，与其他值比较都是 false
 */
// true
console.log("true" == "true");

// false true
console.log(NaN == NaN, undefined == null);

// false false false
console.log("false" == false, "false" == true, undefined == NaN);

// true false
console.log([0] == false, [0] == [0], "\n");

// 逻辑运算，全部转为 boolean ------------------------------------------------------------
if (
  1 &&
  -1 &&
  1.0 &&
  1n &&
  "false" &&
  Symbol() &&
  [] &&
  {} &&
  (() => {}) &&
  !(0 || -0 || 0.0 || 0n || NaN || "" || undefined || null) &&
  !![]
) {
  console.log("boolean\n");
}
```

包装类中的隐式类型转换：

```
const str1 = "asdf";

// str 生成一个临时包装类 String 对象，把 "a" 设置为 “1”
str1.a = "1";

// undefined ，str 和临时生成的 String 包装类不是同一个
console.log(str1.a);

// 同理，生成了临时包装类 String 对象，而且 String 也部署了 iterator
const [s1, s2] = str1;
// "a" "s"
console.log(s1, s2);

const str2 = new String("asdf");
str2.a = "1";
// 1
console.log(str2.a);
```

强制类型转换：

都不改变原始数据：

```
var n = 1;
var str = "3.14";

// "1" "1"
console.log(n.toString(), String(n));

// 3 3.14 3.14
console.log(Number.parseInt(str), Number.parseFloat(str), Number(str));

// 都是 false
console.log(Boolean(null), Boolean(undefined), Boolean(NaN), Boolean(""));

// 都是 true
console.log(Boolean([]), Boolean({}));

// "Symbol()" "Symbol(123)" true ， SYMbol 只能强制转换为 string 、boolean
console.log(String(Symbol()), String(Symbol("123")), Boolean(Symbol()));

// err
try {
  console.log(Number(Symbol()));
} catch (err) {
  console.log("err");
}
```

### 1.4 运算符

（1）ES5

中断运算的运算结果是中断的结果，而不像 C 语言中是 Boolean ：

```
// 123 456
console.log(true && 123);
console.log(false || 456);
```

== 会进行隐式类型转换再比较 value ，而 === 会先比较数据类型：

```
// true false
console.log("123" == 123, "123" === 123);

// false true
console.log("123" != 123, "123" !== 123);
```

其他和 C 一样。

（2）ES6

扩展运算符：

转化成逗号分隔的列表，具备 iterator 接口的数据类型才可使用：

```
const arr1 = [1, 2, 3];

// 用于函数 ---------------------------------------------------------------------
// 简化传参
function func1(a, b, c) {
  console.log(a, b, c, "\n");
}

// 1 2 3
func1(...arr1);

// 用于数组等有 iterator 接口的数据结构 --------------------------------------------
// 构建新的数组，也能实现浅层深拷贝
const arr2 = [...arr1, 4, ...arr1];

// 数组去重
const arr3 = [...new Set([...arr2])];

// [1, 2, 3, 4, 1, 2, 3]
console.log(arr2);

// [1, 2, 3, 4]
console.log(arr3, "\n");

// ES9 新特性，对象字面量也可以使用，但不是基于迭代器 ---------------------------------------
const obj = { a: 1, b: 2, c: 2 };

// 扩展 key: value ，相同的 key ，后面会覆盖前面的
const o = {
  ...obj,
  c: 33,
  ...arr1,
};

// err ，扩展对象得到的是 key: value ，不能给数组使用
try {
  const a = [...o];
} catch {
  console.log("err");
}

// 1 2 33 1 2 3
console.log(o.a, o.b, o.c, o["0"], o["1"], o["2"]);
```

其他：

```
// ES7 ，幂运算 **
const a = 2 ** 3;
// 8
console.log(a), "\n";

// ES11 ，可选链运算符 ? ，当从 undefined 中调用时，直接返回 undefined ，而不报错
// ES5 处理这种问题只能先判断是否存在，非常麻烦，如 !!data && data.a
let obj, arr, func;
obj?.a;
arr?.[0];
func?.();
// err ，由于可能是 undefined ，所以不能赋值
// obj?.a = 1;

// ES11 ，空值合并运算符 ?? ，类似 || 但限制更大，只有 null、undefined 才会执行后面代码
// 1 2 0 false ""
console.log(null ?? 1, undefined ?? 2);
console.log(0 ?? 3, false ?? 4, "" ?? 5, "\n");

// ES12 ，逻辑赋值运算符，中断结果会赋值给变量
let a1 = true,
  a2 = false,
  a3 = null;
// 1 2 3 1 2 3
console.log((a1 &&= 1));
console.log((a2 ||= 2));
console.log((a3 ??= 3));
console.log(a1, a2, a3);
```

### 1.5 迭代器

ES5 流程控制除了循环多了 for\.\.\.in 、forEach 外，其他与 C 一样。迭代器是 ES6 新特性。

（1）解构赋值

将数组、对象中的元素/属性一次赋值给多个变量，若变量多余数组元素、或变量是对象中不存在的属性，则值为 undefined 。

数组解构实现基于迭代器，而对象解构不是。

可以使用 rest 参数，但只能放在最后面且只能有一个，其中对象在 ES9 后才允许使用 rest 参数：

```
// 数组解构赋值，和顺序有关，可以设置默认值，可以连续解构 ------------------------------------
const arr = [1, 3, 5, [7, 9]];

// 1 3 5 7 9 undefined 10
const [a, b, c, [d, e], f, g = 10] = arr;
console.log(a, b, c, d, e, f, g);

// 1 3 [5, [7, 9]]
const [a1, b1, ...c1] = arr;
console.log(a1, b1, c1, "\n");

// 对象解构赋值，和顺序无关，可以设置默认值，可以起别名，可以连续解构 ---------------------
const obj = {
  name: "asdf",
  age: 18,
  other: {
    o1: 123,
  },
};

// 18 asdf 123 undefined false
const {
  age: myAge,
  name,
  other: { o1 },
  sex,
  isDelete = false,
} = obj;
console.log(myAge, name, o1, sex, isDelete);

// 18 {age: 18, other: { o1: 123 }} ，可以实现属性过滤
const { name: myName, ...keys } = obj;
console.log(myName, keys, "\n");

// 函数参数、返回值解构 --------------------------------------------------------------
function func1(options) {
  const { type } = options;
  console.log(type);

  return [0, 1];
}

// 此时必须传实参，或者设置默认值，因为从 undefined 解构是语法错误
function func2({ a, ...keys }) {
  console.log(a, keys, "\n");
}

// "asdf" 1 2
const [r1, r2] = func1({ type: "asdf" });
console.log(r1, r2);

// 123 {type: "asdf"}
func2({
  a: 123,
  type: "asdf",
});

// 复杂数据的解构 -----------------------------------------------------------------
const data1 = [{ a: 1, b: 2 }];
const data2 = { list: [3, 4] };

const [{ a: dataA, b: dataB }] = data1;
const {
  list: [dataC, dataD],
} = data2;

// 1 2 3 4
console.log(dataA, dataB, dataC, dataD);
```

（2）for\.\.\.of

具备 iterator 接口的数据类型才可使用 。除了 Object 外都有 iterator 接口。

for\.\.\.of 、forEach 、for\.\.\.in 异同：

- 遍历出的 key 输出结果的类型都是 string

- 除了 Map 用 for\.\.\.of 、forEach 外，其他情况都无法遍历出 Symbol 属性

- for\.\.\.in 遍历出 key ，for\.\.\.of 和 forEach 遍历出 value
  
  - forEach 还可以传入第二、三个参数，得到 key 和原始引用
  
  - 对于 Map ，for... 遍历 Map 得到 key ，for\.\.\.of 得到 [key, value] 。forEach 则得到 value

- for\.\.\.in 可以遍历出原型链上的自定义属性方法（圆形内置的属性方法都是不可枚举的）；for\.\.\.of 、forEach 不可以

- 使用场景：
  
  - Array 、Object 、Set 、Map 均可以用 for\.\.\.in ；遍历 Set 、Map 只能遍历出原型链上的自定义属性，无法遍历自身的属性
  
  - for\.\.\.of 、forEach 无法便利 Object ；Array 、Set 、Map 则可以
  
  - WeakSet 、WeakMap 由于是弱引用所以无法以任何形式遍历
  
  - map\(\) 等方法只有 Array 可以用

示例：

```
const arr = [1, undefined, 3];
arr[Symbol("arr_sym")] = "arr_sym";
arr.__proto__.arrKey = 4;
arr.__proto__[Symbol("arr_proto_sym")] = "arr_proto_sym";

const obj = { a: 1, b: undefined, c: 3, [Symbol("obj_sym")]: "obj_sym" };
obj.__proto__.objKey = 4;
obj.__proto__[Symbol("obj_proto_sym")] = "obj_proto_sym";

const set = new Set([1, undefined, 3]);
set[Symbol("set_sym")] = "set_sym";
set.__proto__.setKey = 4;
set.__proto__[Symbol("set_proto_sym")] = "set_proto_sym";

const map = new Map([
  ["a", 1],
  ["c", 3],
  [Symbol("map_sym"), "map_sym"],
]);
map.__proto__.mapKey = 4;
map.__proto__[Symbol("map_proto_sym")] = "map_proto_sym";

/**for...in ，便利 key ---------------------------------------------------------------
 * 无法便利出 Symbol key
 * 会遍历出圆形链上的自定义属性
 * Set 、Map 只能便利出原型链上的自定义属性，自己身上的无法遍历
 */
// "0" "1" "2" "arrKey" "objKey"
for (const i in arr) console.log("for...in arr", i);
console.log("\n");

// "a" "b" "c" "objKey"
for (const i in obj) console.log("for...in obj", i);
console.log("\n");

// "setKey" "objKey"
for (const i in set) console.log("for...in set", i);
console.log("\n");

// "mapKey" "objKey"
for (const i in map) console.log("for...in map", i);
console.log("\n");

/**for...of ，便利出 value --------------------------------------------------------------
 * 除了 Map 外都无法遍历出 Symbol key ，Map 遍历出 [key, value]
 * 只能遍历有 iterator 接口的数据结构，Object 无法使用
 * 无法遍历原型链上的属性
 */
// 1 undefined 3
for (const i of arr) console.log("for...of arr", i);
console.log("\n");

// err
try {
  for (const i of obj) console.log("for...of obj", i);
} catch {
  console.log("err");
}
console.log("\n");

// 1 undefined 3
for (const i of set) console.log("for...of set", i);
console.log("\n");

// "mapKey" "objKey"
for (const i of map) console.log("for...of map", i);
console.log("\n");

/**froEach ，便利出 value ---------------------------------------------------
 * Map 遍历出 key
 * 其他和 for...of 都一样
 *
 */
// 1 2  "map_sym"
map.forEach((i) => console.log("forEach map", i));
console.log("\n");

// 数组特有遍历方法
arr.map((i) => console.log("arr.map", i));
```

（3）迭代器

ES6 提供了 iterator 接口，为不同的数据结构提供统一的访问机制，只有 Object 没有 iterator 接口，其他都有，如 Array、伪数组、String、Set、Map 等

数组解构赋值是按顺序解构出来的，因为底层实现使用的迭代器，扩展运算符和 for\.\.\.of 也只有具备 iterator 接口的数据结构才能使用。

一般 iterator 接口是各数据结构的原型对象中的一个方法：

```
[Symbo.iterator] : function(){}
```

原理与使用

迭代器中有一个 next() 方法，作用是返回当一个对象，对象的内容为当前 value 和是否结束，得到这个信息后，移动到下一个元素：

```
const arr = [1, 2, 3];
const arrIterator = arr[Symbol.iterator]();

/* {value: 1, done: false}
 * value：当前元素
 * done：是否到达 end
 */
console.log(arrIterator.next());

// {value: 2, done: false}
console.log(arrIterator.next());
// {value: 3, done: false}
console.log(arrIterator.next());

// {value: undefined, done: truye}  结束
console.log(arrIterator.next());
```

当 done 为 true 时，迭代结束。总体上指针在 begin 到 end 是一个左闭右开的区间。

（4）自定义遍历数据

例如给某个对象单独部署 iterator 接口，使其可以使用 for\.\.\.of ，且 for\.\.\.of 的遍历规则是自定义的：

```
const o = {
  name: "asdf",
  arr: [1, 2, 3],
  [Symbol.iterator]() {
    let index = 0;
    const _this = this;

    return {
      next() {
        // 这里 this指向 o
        if (index < _this.arr.length)
          return { value: _this.arr[index++], done: false };
        else return { value: undefined, done: true };
      },
    };
  },
};

// 1 2 3
for (i of o) console.log(i);
```

直接给 Object 部署 iterator 接口也可以，例如用数组解构赋值的语法按顺序结构对象：

```
Object.prototype[Symbol.iterator] = function () {
  // 直接借助 Array 的 iterator 也可以，自己写也可以
  return Object.keys(this)[Symbol.iterator]();
};

const [n1, n2] = { a: 1, b: 2 };
console.log(n1, n2);

for (const i of { a: 1, b: 2 }) console.log(i);
```

### 1.6 异常处理

当代码出错时，会报错并终止运行，可以使用异常处理使报错后不终止运行：

```
// ES5 --------------------------------------------------------------------------------------
try {
  出错了;
  console.log("出现异常后，try 中后续代码不会执行，直接进入 catch");

  // 也可以手动抛出异常
  // throw "myErr";
} catch (err) {
  console.log("err");
}

// 无法捕获异步代码的异常
try {
  setTimeout(() => {
    // throw "async err";
  });
} catch (err) {
  console.log(err);
}

// err2 ，嵌套的异常只有出错的那一层会捕获
try {
  try {
    throw 123;
  } catch {
    console.log("err2\n");
  }
} catch (err) {
  console.log("err1");
}

// ES6 --------------------------------------------------------------------------------------
// ES9 新特性，catch 可以不 用传入参数，此时 catch 小括号必须去掉
try {
} catch {}

// ES9 新特性，新增 finally ，无论是否异常都会执行，且就算 return 、breaqk 、continue 后也会执行
function test(value) {
  try {
    if (value) throw "err";
    console.log("ok");
    return "res";
  } catch {
    console.log("err");
  } finally {
    console.log("finally");
  }
}

// ok finally res
console.log(test(false), "\n");
// err finally undefined
console.log(test(true), "\n");

// finally
for (let i = 0; i < 10; i++) {
  try {
    break;
    // continue;
  } finally {
    console.log("finally");
  }
}
```

Error 类型：

```
try {
  // "Error: err string" ，Error 基类 ，其他 err 类型都继承于它
  throw new Error("err string");
  // "Error: Error: err string"
  // throw new Error(new Error("err string"));

  // throw new EvalError('函数使用不当，现在很少用了"');

  // throw new RangeError("越界");

  // throw new ReferenceError("xxx is not define");

  // throw new SyntaxError("语法错误");

  // throw new TypeError("数据类型错误");

  // throw new URIError("decode encode 错误");

  // es12 新特性
  // throw new AggregateError("多种错误，如 Promise.any");
} catch (err) {
  // console.log(err, "\n");
  console.log(err.message, "\n");
}

// 自定义 err
class MyCustomError extends Error {
  constructor(message) {
    super(message);
    this.name = "MyCustomError";
  }
}

// ES13 新特性，Error Cause ,用于 Error ，能更好的追踪嵌套 try...catch 根本的错误原因 ---------
try {
  try {
    throw new Error("Inner error");
  } catch (innerErr) {
    // 外层错误附带 cause（原因）
    throw new Error("Outer error", { cause: innerErr });
  }
} catch (err) {
  // "Outer error" "Inner error"
  console.log(err.message);
  console.log(err.cause.message); //
}
```

## 2 函数

### 2.1 函数、作用域

（1）基本

函数也是对象，调用函数本质就是执行了这个函数对象的 call 方法，因此由 call 方法的对象就是一个函数。

基本使用：

```
// 具名函数
function func1() {
  // 可以在 function 内部定义 function ，内部函数只能在外部函数内使用
  // 不要在 if 等块级作用域声明块级函数，ECMA 并没有这个标准，不同浏览器的运行逻辑不同
  function func11() {
    P;
  }
}

// 匿名函数
var func2 = function () {};

// JS 没有类型检测，所以不知道传入的参数是什么类型
function func(a, b) {
  // 设置默认值
  b = b || 2;

  console.log(a, b);

  // arguments 保存了传入的所有实参，包括多传的参数
  console.log(arguments);

  // true ，argument 是一个伪数组，具有 length 也可以下标访问，但没有 Array 的方法，因为伪数组是 Object 构造的
  // JS 获取的 DOM 也是伪数组
  console.log(arguments.__proto__ === Object.prototype);

  // ES6 新特性，可以将伪数组转为 Array ，不会改变原伪数组
  var args = Array.from(arguments);
  // true
  console.log(args.__proto__ === Array.prototype, "\n");

  // 默认 return
  // return undefined;

  // 2，错误写法，只能 return 一个值，return 多个则最后一个生效
  // return 1, 2;
}

var func3 = func2;

// func1 func2 func2 ，name 保存了函数名，匿名函数则是保存了最初引用该函数的变量名
console.log(func1.name, func2.name, func3.name);

// 2 ，获取形参个数，注意是形参不是实参
console.log(func.length);

// 1 2 [1, 2, 3] ，多传的参数也放入 argument
func(1, 2, 3);

// undefined 2 [] ，参数没传且没默认值则 undefined
func();

// 1 2 [1, 2] ，函数调用本质是调用了 call 方法
// 等价于 func(1, 2)
func.call(this, 1, 2);
```

函数签名：

由函数名、形参列表、返回值组成，配合文档注释可以说明函数如何使用：

```
/**
 * 求和
 * param {Number, Number} 两个数值
 * return {Number} 求和结果
 */
function sum(a, b) {}
```

立即执行函数：

是匿名函数，不用调用，会立即执行，只执行一次，内部会形成局部作用域，可以解决 var 没有快级作用域的问题，也可以防止多个 JS 文件的 var 冲突：

```
(function () {
  console.log("123");
})();

// 0
var i = 0;
(function () {
  for (var i = 0; i < 10; i++) {}
})();
console.log(i);
```

（2）作用域链

用于查找变量，先从自己作用域开始，直到全局，找不到就是 undefined 。规则：

- 内部可以访问外部变量，反之不行；访问的是最近一级作用域的变量

- 只与定义函数时有关，与调用无关：
  
  ```
  function func1() {
    var a = 1;
  
    return function () {
      console.log(a);
    };
  }
  
  function func2() {
    var a = 2;
    func1()();
  }
  
  // 1
  func2();
  ```

- 由于 JS 是解释型语言，所以下面代码不会报错：
  
  ```
  function func() {
    console.log(a);
  }
  
  const a = 1;
  
  // 1
  func();
  ```

### 2.2 ES6 函数

（1）形参

rest 参数，也叫剩余参数：

用于接收不定数量的参数，必须放在最后面且只能有一个，接收后是一个数组，可以替代 arguments ：

```
function func(a, b, ...args) {
  console.log(a, b, args);

  // true
  console.log(args.__proto__ === Array.prototype);
}

// 1 2 [3, 4, 5]
func(1, 2, 3, 4, 5);
```

```
// 可以利用 rest 参数获取回调函数需要几个参数
function func(fn) {
  fn(1, 2);
}

// 2
func((...args) => console.log(args.length));
```

形参默认值：

当未传入参数，或者传入 undefined 时，就使用默认值：

```
function func1(a = 5) {
  console.log(a);
}

// 5
func1();

// 默认参数可以放在除了 rest 的任何位置，但最好往后靠，才比较明确 -----------------------------
function func2(a, b, c = 3) {
  console.log(a, b, c);
}

function func3(a, b = 2, c) {
  console.log(a, b, c);
}

// 1 2 3
func2(1, 2);

// 1 2 undefined
func3(1, 2);

// 默认值也可以是一个表达式 ------------------------------------------------------------
function double(n) {
  return n * 2;
}

// 正常使用，只有在未传入参数或传入 undefined 时，表达式才会执行
function func4(a, b = double(a)) {
  console.log(a, b);
}

/*形成了暂时性死区，就类似于下面代码，无法再 b 声明前使用 b 
 * let a = double(b);
   let b;
 */
function func5(a = double(b), b) {
  console.log(a, b);
}

// 1 2
func4(1);

// 1 undefined ，传入了非 undefined 参数，double(b) 未执行
func5(1);

// err
try {
  func5();
} catch {
  console.log("err");
}
```

```
// 引用类型作为默认值
function func(str, options = {}) {
  // 方式一
  const defaultOptions = {};
  options = { ...defaultOptions, ...options };

  // 方式二
  const { a = 1, b = 2 } = options;
}
```

函数的 length 的设计是为了获取函数至少需要的参数数量，所以会忽略 rest 参数和默认值参数，只获取第一个默认值参数前面的参数数量：

```
function func(a, b = 1, ...args) {}

// 1
console.log(func.length);
```

ES5 的 arguments 使用很不方便，尽量用 rest 参数替代：

- 外部不知道 argument 需要使用剩余参数

- argument 保存了所有参数，需要分割；arguments 是伪数组

另外 arguments 也有设计上的问题，在修改刑参时会同步修改 arguments ，之所以没有修复这个 bug ，是因为考虑到老项目的兼容问题，所以退出了严格模式，有了 ES6 新语法后，使用这些函数新语法就说明是新项目了，就不用使用严格模式：

```
// 非严格模式下，修改形参会同步影响到 arguments ，这是非常不合理的
function func1(a) {
  // "use strict";

  a = 5;

  // 5
  console.log(arguments[0]);
}

// 但只要用了默认值或 rest 参数。在非严格模式下也会恢复正常
function func2(a, b = 5) {
  a = 5;

  // 1
  console.log(arguments[0]);
}

func1(1);
func2(1);
```

ES8 新特性，函数可以喝数组、对象一样，最后面加一个逗号而不报错了：

```
function func(a, b, ) {}
func(1, 2, );
```

（2）箭头函数

在 ES6 之前，function 既可以作为普通函数封装代码，又可以作为构造函数来实例化对象，这实际上是 JS 设计上的缺陷，作为面向对象的语言，应该把这两个功能在语法上区分开来，消除函数的二义性。

箭头函数就是解决方案之一（另一个是 class ）。

与普通函数的区别：

- 只能定义匿名函数

- 没有 arguments，因为 rest 参数是更好的替代

- 由于设计初衷是为了消除二义性，所以箭头函数不能作为构造函数，不能 new、没有原型、没有自己的 this ，使用 this 其实就是在作用域链中找到的

```
const func1 = (a, b) => {
  return a + b;
};

// 形参只有一个时，可以省略 () ，函数体只有一条语句时，可以省略 {} ，此时就是 return 这条语句
// 若没有形参，则必须加上 ()
const func2 = a => a * 2;
const func3 = () => 123;

// 上述情况若 return对象，则需要加上 () ，避免语法错误
const func4 = () => ({ a: 1 });
```

（3）标签模板

函数调用结合模板字符串的一种新的函数调用方式。标签指的就是函数，在函数调用后面的模板字符串会按照规则作为函数的实参：

```
const func1 = (a) => console.log(a);

// ["asdf"] ，相当于 func([`asdf`]);
func1`asdf`;

// #{} 会把左右的子串分割成参数，若没有字符，则为空字符串 -------------------------------------
function func2() {
  console.log([...arguments]);
}

const func3 = (...args) => console.log(args, "\n");

// [["", "", ""], 123, 456]
func2`${123}${456}`;
func3(["", "", ""], 123, 456);

// [["a", "b", "c"], 123, 456]
func2`a${123}b${456}c`;
func3(["a", "b", "c"], 123, 456);

// ES9 新特性，如果模板字符串中有错误的转义字符，不在 err ，而是视为 undefined ------------------------
const func4 = (...args) => {
  // [[undefined, " asdf\n"], 123] ，err 的转义字符后面的字符都不要了
  console.log(args);

  // ["\000 and ", " asdf\n"] ，raw 可以获取转义字符的原始字符串
  console.log(args[0].raw);
};

func4`\000 and ${123} asdf\n`;
```

应用，将命令式代码转为声明式代码：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      .box {
        width: var(--my-width, "aurto");
      }
    </style>
  </head>

  <body>
    <div class="box" style="height: 200px"></div>
  </body>

  <script>
    HTMLElement.prototype.getKey = (rawStr) =>
      rawStr.match(/[a-zA-Z-]/g)?.join("") || "";

    HTMLElement.prototype.styles = function (...args) {
      let styles = this.getAttribute("style") ?? "";

      for (let i = 1; i < args.length; i++) {
        const styleKey = this.getKey(args[0][i - 1]);
        styles += `; ${styleKey}: ${args[i]}`;
      }

      this.style = styles;

      // 链式调用
      return this;
    };

    HTMLElement.prototype.props = function (...args) {
      for (let i = 1; i < args.length; i++) {
        this.setAttribute(this.getKey(args[0][i - 1]), args[i]);
      }

      return this;
    };

    HTMLElement.prototype.content = function (...args) {
      let content = args[0][0] || "";

      for (let i = 1; i < args[0].length; i++) {
        content += args[0][i] + args[i];
      }

      this.textContent = content;

      return this;
    };

    const box = document.querySelector(".box");

    // 简化了各种 .style ，.setAttribute
    box.styles`
    --my-width: ${"100px"};
      border: ${"10px solid #000"};
      background-color: ${"red"};
    `.props`
      data-item-id: ${0},
    `.content`this is ${"box"}`;
  </script>
</html>
```

### 2.3 函数式编程

（1）纯函数

相同的输入都能得到同样的结果，且无副作用的函数就是纯函数：

- 如 Math\.random 每次都会产生不同的输出，就不是纯函数；如输出依赖外部变量，由于可能被外部修改，所以输出也不确定，也就不是纯函数

- 无副作用，即不会修改外部作用域的变量（如 push 会修改原始数组，就不是纯函数），没有 ajax 、定时器、修改 DOM 等异步操作

不是纯函数，那就是一个副作用函数：

```
// 纯函数
function func1(a, b) {
  return a + b;
}

// 非纯函数 -------------------------------------------------------
let a = 0;
const obj = { a: 1 };

// 每次输出都不同
Math.random();

// 返回值依赖外部变量，而外部变量是不确定的，可能会被修改
function func2() {
  return a;
  // return obj.a;
  // return localStorage.getItem("test");
}

// 修改了外部作用域的 arr ，产生了副作用
function func3(arr) {
  arr[0] = 1;
  // arr.push(1);
}

// 异步任务如 ajax 、定时器等产生副作用
function func3() {
  setTimeout(() => {});
}
```

非纯函数由于会产生副作用，使用时就需要特别注意：

```
const arr1 = [1, 2, 3];
const arr2 = [1, 2, 3];
const arr3 = [1, 2, 3];
const arr4 = [1, 2, 3];

// 都得到 [1] ，因为在删除的过程中，arr1.length 变小，使得 i 判断条件提前结束
for (const i in arr1) arr1.pop();
for (const i of arr2) arr2.pop();
for (let i = 0; i < arr3.length; i++) arr3.pop();
console.log(arr1, arr2, arr3);

// 解决方法，定死循环次数
const len = arr4.length;
for (let i = 0; i < len; i++) arr4.pop();
console.log(arr4);
```

（2）高阶函数

形参或返回值是 function 的函数，就是高阶函数，其中作为形参的函数称为回调函数

```
function func1(fn) {
  fn();
}

function func2() {
  return function () {};
}

function func3(fn) {
  fn();
  return function () {};
}

// 纯粹的函数式编程中没有对象，但 JS 混合了多种编程思想，所以 JS 中这样也算高阶函数
function func4(options) {
  options.fn();
}
```

（3）惰性函数

当函数中某些逻辑只需要执行一次时，就可以写成惰性函数，提高性能：

```
function nextTick(callback) {
  if (Promise) {
    nextTick = function (callback) {
      Promise.resolve().then(callback);
    };
  } else {
    nextTick = function (callback) {
      setTimeout(() => callback);
    };
  }

  // 执行修改后的函数
  nextTick(callback);
}
```

```
// 另一种方式，在项目最开始就判断，缺点是会增加初始化时间
const nextTick = ((callback) => {
  if (Promise) return (callback) => Promise.resolve().then(callback);
  else return (callback) => setTimeout(() => callback);
})();
```

（4）闭包

编译原理的概念，只要函数形成了嵌套，且内部函数使用了外部函数的资源，那么内部函数就变成了闭包，即使外部函数被垃圾回收了，闭包使用的资源依然存在，这是非常合理的，因为内部函数还在使用就不应该被垃圾回收。

直到闭包函数也被垃圾回收了，闭包的资源才会被垃圾回收：

- 优点：缓存资源；也可以在外面按照自己的规则访问函数的私有资源

- 缺点：不会被垃圾回收，使用不慎就会加大内存消耗，低版本 IE 则会内存泄漏，解决方法是把不适用的闭包设为 null

```
const func1 = (...args) => {
  let num = 0;

  // 内部函数使用了形参和 num ，这两个变量都不会被垃圾回收
  return () => console.log(args[0]++, num++);
};

const func2 = (...args) => {
  let num = 0;

  // z这样也是函数嵌套，这种方式通常用来实现私有资源，只给外部提供 get 方法访问资源
  return {
    getNum: () => console.log(args[0]++, num++),
  };
};

const func3 = () => {
  const a = 1;

  // 这也是函数嵌套，也形成了闭包，只不过内部函数没有被外部使用，已经被垃圾回收了
  const func = () => a;
};

let f1 = func1(0),
  f2 = func2(0);

// 0 0 0 0
f1();
f2.getNum();

// 1 1 1 1 ，
f1();
f2.getNum();

// 手动回收闭包
f1 = null;
f2.getNum = null;
```

（5）面向切面编程

将函数的核心功能和非核心功能分开，在适当的时候可以给有核心功能的函数添加一些非核心功能；

实现方式一：

```
function AOP(fn, before, after) {
  return function (...args) {
    before?.call(this, ...args);
    fn?.call(this, ...args);
    after?.call(this, ...args);
    ``;
  };
}

// -----------------------------------------------------------------------------
const obj = {
  func1() {
    console.log("func1");
  },

  func2(a, b) {
    console.log("func2", a, b);
  },
};

const func1 = AOP(
  obj.func1,
  function (...args) {
    console.log("func1 before", this === obj, ...args);
  },
  function (...args) {
    console.log("func1 after", this === obj, ...args);
  }
);

// func1 before true
// func1
// func1 after true
func1.call(obj, "\n");

const func2 = AOP(
  obj.func2,
  function (...args) {
    console.log("func2 before", this === obj, ...args);
  },
  function (...args) {
    console.log("func2 after", this === obj, ...args);
  }
);

// func2 before true 1 2
// func2 1 2
// func2 after true 1 2
func2.call(obj, 1, 2);
```

实现方式二：

```
Function.prototype.before = function (beforeFn) {
  const fn = this;

  return function (...args) {
    beforeFn.call(this, ...args);
    fn.call(this, ...args);
  };
};

Function.prototype.after = function (afterFn) {
  const fn = this;

  return function (...args) {
    fn.call(this, ...args);
    afterFn.call(this, ...args);
  };
};

// -------------------------------------------------------------------------------
const obj = {
  test(...args) {
    console.log("test", this === obj, ...args);
  },
};

const fullTest = obj.test
  .before(function (...args) {
    console.log("before", this === obj, ...args);
  })
  .after(function (...args) {
    console.log("after", this === obj, ...args);
  });

// before true 1 2
// test true 1 2
// after true 1 2
fullTest.call(obj, 1, 2);
```

（6）柯里化

处理一个原函数，固化其某些参数（即闭包这些参数），并生成一个新函数，新函数只需要传入剩下的参数即可。柯里化通尝将多参函数转化为参数更少的函数或单参函数。

如果一个函数需要被使用多次，且其中某些参数是不变的，就可以使用柯里化，后续只需要使用新生成的函数，传入剩下的参数即可：

```
function currv(fn, ...preArgs) {
  return (...args) => {
    const totalArgs = [...preArgs, ...args];

    // 如果参数足够 fn 使用，就调用 fn
    if (totalArgs.length >= fn.length) return fn.apply(this, totalArgs);
    // 否则继续 currv
    else return currv.call(this, fn, ...totalArgs);
  };
}

const sum1 = currv(function (a, b) {
  return a + b;
}, 10);

// 30
console.log(sum1(20));
// 40
console.log(sum1(30), "\n");

const sum2 = currv(function (a, b, c) {
  return a + b + c;
}, 10);

// 50
console.log(sum2(20, 20));
// 80
console.log(sum2(30, 40), "\n");

const sum3 = sum2(20);
// 70 ，10+20+40
console.log(sum3(40));
```

```
// 多参的柯里化不好标注，这里就标注只允许单参的类型

type PreArgs<A extends any[]> = A extends [...infer PA, any]
  ? A | PA | PreArgs<PA>
  : [];

type CurrvReturn<A, R> = A extends []
  ? () => R
  : A extends [infer ARG]
  ? (param: ARG) => R
  : A extends [infer ARG, ...infer REST]
  ? (param: ARG) => CurrvReturn<REST, R>
  : never;

declare function currv<A extends any[], R, PA extends PreArgs<A>>(
  fn: (...args: A) => R,
  ...preArgs: PA
): CurrvReturn<A, R>;
```

（7）函数管道

将多个单参函数组合成一个新的单参函数，上一个单参函数的输出会作为下一个单参函数的输入。若传入的不是单参函数，则需要 currv ：

```
function pipe(...fns) {
  return (value) => fns.reduce((pre, fn) => fn.call(this, pre), value);
}

const obj = {
  num1: 2,
  num2: 1,

  double(n) {
    return n * this.num1;
  },

  add(n) {
    return n + this.num2;
  },
};

const func = pipe.call(obj, obj.double, obj.add);

// 5 ，2*2+1
console.log(func(2));
```

（8）防抖、节流

有对应的库：

```
npm install --save lodash
```

防抖、节流的作用都是为了限制执行次数，减少函数不必要的执行，优化性能，区别是：

- 防抖：在一段时间内只允许执行一次，若在此时间段内再次触发，则重新计时

- 节流：在一段时间内只允许执行一次，可以在开头或结尾执行

```
npm install -g @types/node
```

```
// 防抖
function debunce<A extends any[]>(
  func: (...args: A) => any,
  duration: number = 1000
) {
  let timer: NodeJS.Timeout = null;

  return function (...args: A): void {
    clearTimeout(Number(timer));
    timer = setTimeout(() => func.call(this, ...args), duration);
  };
}

// 节流
function throttle<A extends any[]>(
  func: (...args: A) => any,
  duration: number = 1000,
  immediate: boolean = true
) {
  let timer: NodeJS.Timeout = null;

  return function (...args: A): void {
    if (!timer) {
      immediate && func.call(this, ...args);

      timer = setTimeout(() => {
        timer = null;
        immediate || func.call(this, ...args);
      }, duration);
    }
  };
}
```

（9）参数归一化

当形参支持多种类型时，在函数内部就需要很多的分支判断形参类型，可读性差。

这时候可以用参数归一化抽离类型判断，并把参数处理为最宽泛的类型，后续就能很方便的处理了：

```
function func(datas = [], options = {}) {
  // 参数归一化，datas 统一处理为 Array ，options 统一处理为 Object
  const result = formateParams(datas, options);
  datas = result.datas;
  options = result.options;

  // 具体的业务逻辑
  console.log(datas);
  for (const num of datas) {
    let res = num;
    res = options.round ? Math.round(res) : res;
    res = options.abs ? Math.abs(res) : res;

    console.log(res);
  }

  console.log("\n");
}

function formateParams(datas, options) {
  if (typeof datas === "number") {
    const length = datas;
    datas = [];
    for (let i = 0; i < length; i++) datas.push(Math.random() * 10);
  } else if (!Array.isArray(datas)) throw new TypeError("datas type err");

  if (Object.prototype.toString.call(options) === "[object Object]") {
    const defaultOptions = { round: false, abs: false };
    options = { ...defaultOptions, ...options };
  } else if (typeof options === "boolean") {
    options = { round: options, abs: false };
  } else throw new TypeError("options type err");

  return { options, datas };
}

// 测试
func();
func(3);
func(3, true);
func([1, -3, 5.5, -4.2], { round: true, abs: true });
```

## 3 对象

### 3.1 Object

（1）基本

```
// 创建 -------------------------------------------------------------------------------
// 构造函数创建，过程：bnew Object() -> 修改 this -> 执行构造函数 -> return this
function Obj(n) {
  this.a = n;

  // 默认返回值
  // return this;
}
const obj1 = new Obj(123);

// 字面量创建，底层会调用 new Object()
const c = 3;
const func2 = () => {};

const obj2 = {
  a: 1,

  // key 的引号可以省略，如果是复杂的 key 则必须加引号
  "b.b.b": 2,

  // 都是匿名函数
  func1: function () {
    console.log("func");
  },

  // ES6 新特性，若 value 是一个变量且和 key 名字相同，可以简写
  c,
  func2,

  // ES6 新特性，函数简写，等价于 func3: function() {}
  func3() {},

  // ES6 新特性，key 可以用 [] 包裹表达式，若 key 不是 string、Symbol ，会隐式转为 string
  [Symbol()]: "sym",
};

// 调用、添加、删除属性 ----------------------------------------------------------------
// 调用
console.log(obj1.a, obj1["a"]);

// undefined ， 调用没有的属性得到 undefined
console.log(obj1.aaa);

// err ，无法从 undefined 中调用任何属性
try {
  console.log(o.a);
} catch {
  console.log("err");
}

// 删除
delete obj1.a;

// 添加到对象自身
obj1.b = 3;
obj1["c"] = 3;

// 添加到圆形
obj1.__proto__.d = 4;
Obj.prototype.e = 5;

// 添加 static 属性
Obj.f = 6;
```

对象的 key 只能是 string 或 Symbol ，如果是其他类型则会转为 string ：

```
const obj = {};
const arr = [];

// 等价于 obj["[object Object]"] = "obj"
obj[{ a: 1 }] = "obj";
// "obj"
console.log(obj["[object Object]"]);

// 等价于 arr["0"] = 123
arr[0] = 123;
// 123
console.log(arr[0]);
```

循环引用，自己的属性引用自己，或者两个对象互相引用，形成环形结构：

```
// 循环引用
const o = {};
o.obj = o;

// err ，因为此时 o 还没有生成
// const o = { obj: o };
```

（2）深拷贝

引用数据类型，引用（地址）存储在栈内存，用变量接收；属性等存储在堆内存。

浅拷贝只拷贝地址，修改拷贝对象的属性，原始对象也会修改，因为是同一个堆内存空间；而深拷贝则是拷贝全部元素，存放在新开票的堆内存中。

```ag-0-1j35kgj3kag-1-1j35kgj3k
const obj1 = { a: 1 };

// 浅拷贝
const obj2 = obj1;

obj2.a = 2;

// 2 2
console.log(obj1.a, obj2.a);
```

深拷贝：

```
// 缺点是 JSON API 自己的限制，优先数据类型无法拷贝
const func1 = (obj) => JSON.parse(JSON.stringify(obj));

// 缺点是只能深拷贝一层
const func2 = (obj) => ({ ...obj });

// 缺点是兼容性差，需要高版本浏览器和高版本 node
const func3 = (obj) => structuredClone(obj);

/**自己实现
 * NaN，Function，基本数据类型不需要深拷贝，直接返回，Symbol 除外
 * 支持循环引用的深拷贝
 * 支持 Symbol ，Date ，RegExp 的深拷贝
 * 支持对象、数组、Set、WeakSet、Map、WeakMap 的深拷贝
 * 原型上的自定义属性，需要 for in 遍历、方法，比较少用，这里就不实现拷贝了
 */
function deepCopy(source, hash = new WeakMap()) {
  // 不需要递归深拷贝的类型
  const nonRecursionTypes = [
    "[object Symbol]",
    "[object Date]",
    "[object RegExp]",
  ];

  // 需要递归深拷贝的类型
  const recursionTypes = [
    "[object Object]",
    "[object Array]",
    "[object Set]",
    "[object Map]",
    "[object WeakSet]",
    "[object WeakMap]",
  ];

  const type = Object.prototype.toString.call(source);

  // 1.如果是NaN，函数或基本数据类型（Number,String,Boolean,null,undefined,BigInt），直接返回
  if (!recursionTypes.includes(type) && !nonRecursionTypes.includes(type))
    return source;

  // 2.如果是Symbol，Date或RegExp，简单深拷贝后返回
  if (nonRecursionTypes.includes(type))
    return type === "[object Symbol]"
      ? Symbol(source.description)
      : type === "[object Date]"
      ? new Date(source)
      : new RegExp(source);

  // 3.如果是循环引用，直接return
  if (hash.has(source)) return hash.get(source);
  hash.set(source, source);

  // 4.若果是需要递归深拷贝的类型
  let res = null;
  switch (type) {
    case "[object Array]":
    case "[object Object]":
      res = Array.isArray(source) ? [] : {};
      //之所以不直接用for遍历source是因为这样遍历不出键位Symbol的属性，ownKeys才行
      Reflect.ownKeys(source).forEach((i) => {
        if (i !== "length" || type === "[object Object]") {
          res[i] = deepCopy(source[i], hash);
        }
      });
      break;
    case "[object Set]":
    case "[object WeakSet]":
      res = new Set();
      for (let i of source) res.add(deepCopy(i, hash));
      break;
    case "[object Map]":
    case "[object WeakMap]":
      res = new Map();
      for (let [k, v] of source) res.set(k, deepCopy(v, hash));
      break;
    default:
      break;
  }

  return res;
}

// 测试代码
const obj = {
  num: 123,
  bigint: 123456789123456789n,
  nan: NaN,
  und: undefined,
  arr: [1, 2],
  obj: { a: 1, b: 2 },
  func: () => 123,
  null: null,
  [Symbol("111")]: 111,
  set: new Set([5, 6]),
  map: new Map([["key", "value"]]),
  sym: Symbol("sym"),
  date: new Date(),
  reg: new RegExp(),
};

// 测试循环引用
const objTest = {
  obj,
};

obj.myself = obj;
obj.objTest = objTest;
obj.arr.push(obj.arr);
obj.set.add(obj.set);
obj.map.set("m", obj.map);

// 输出
console.log(obj);
console.log(deepCopy(obj));
```

深拷贝也有第三方 API 可以直接使用。

（3）ES6 Object 新 API 

```
const obj = {
  a: 1,
  b: 2,
};

Object.defineProperty(obj, "c", {
  value: 3,
  enumerable: false,
  writable: true,
});

// ES6 --------------------------------------------------------------------------------
// 返回 key 或 value 的数组，会过滤掉非枚举属性
// ["a", "b"] [1, 2] [["a", 1], ["b", 2]]
console.log(Object.keys(obj));
console.log(Object.values(obj));
console.log(Object.entries(obj), "\n");

// 判断两个是否相等，可以判断基本类型，会有严格的比较，如 +0 和 -0 不相等
// true false
console.log(Object.is(obj, obj), "\n");
console.log(Object.is(+0, -0), "\n");

// 合并多个 obj ，会改变原始 obj ，若有相同 key ，后面会覆盖前面，被覆盖的属性必须是可写的
const newObj = Object.assign(obj, { a: 11 }, { c: 3 });
console.log(newObj, obj, "\n");

// ES10 ---------------------------------------------------------------------------------
// 用二维数组创建对象
const obj1 = Object.fromEntries([
  ["a", 1],
  ["b", 2],
]);
console.log(obj1);

// ES15 -------------------------------------------------------------------------------
// 分组，纯函数，有 iterator 就可以用，返回一个没有原型的对象
const arr15 = [
  { name: "a", age: 18 },
  { name: "a", age: 28 },
  { name: "b", age: 38 },
];

/**
 * {
     a: [ { name: "a", age: 18 }, { name: "a", age: 28 } ],
     b: [ { name: "b", age: 38 } ]
   } 
 */
const group1 = Object.groupBy(arr15, (i) => i.name);
console.log(group1, group1.__proto__);

// 结果和上面类似 true ，分组，纯函数，返回带有原型的 map
const group2 = Map.groupBy(arr15, (i) => i.name);
console.log(group2, group2.__proto__ === Map.prototype);
```

（3）Reflect 反射

ES6 新特性，对象的任何操作，都会转化成浏览器的内部方法，数组、函数等也是对象，对其的操作也会转化成内部方法。这些方法开发者无法使用，ES5 无法使用这些方法的。

```
const obj = {};

// 等价于 set(obj, "a") ，此时 key 一定是 string
obj.a = 1;

// 等价于 set(obj, "b") ，不同的是如果 key 可能不是 string ，就会强制类型转换成 string
obj["b"] = 2;

// 调用内部方法 defineProperty
Object.defineProperty(obj, "c", { value: 3 });

// 等价于 get(obj, key)
console.log(obj.a, obj["b"], obj.c, "\n");
```

而 Reflect 就有这些内部方法：

```
const obj = {};

// Reflect 使用这些内部方法时，会 try...catch 处理是否处理成功，返回布尔值
// 第三个参数为 this 指向
Reflect.set(obj, "a", obj);

// undefined ，没有圆形
console.log(Reflect.prototype);

// 但是具备 OBJECT 的 static 方法
// Object 圆形上的方法渐渐地也部署成 static 方法了，因此 Reflect 也有
console.log(Reflect.hasOwnProperty, "\n");
```

Reflect 应用场景：

```
// 简化内部操作 -----------------------------------------------------------------------
const obj = { a: 1 };

Object.defineProperty(obj, "b", {
  value: 2,
  enumerable: false,
});

// ["a"] ，keys 方法内部会判断并过滤掉非枚举 key ，再调用 ownKeys
console.log(Object.keys(obj));
// ["a", "b"] ，如果不想要 keys 的操作，就可以直接使用 ownKeys
console.log(Reflect.ownKeys(obj), "\n");

// 修改 this ------------------------------------------------------------------------
const o = {
  a: 1,
  get b() {
    return this.a;
  },
};

const p = new Proxy(o, {
  get(t, k, r) {
    console.log(k);

    // return t[k];
    return Reflect.get(t, k, r);
  },
});

// "b" ，没有 a 是因为 this 只想的是 o ，而不是 p
// "b" "a" ，使用 Reflect 修改 this 为 p 后就可以了
p.b;
```

（4）对象常用操作

数组、对象判空：

```
const arr = [], obj = {};

// 推荐做法
// true ，数组判空
console.log(Array.isArray(arr) && arr.length === 0);
// true true ，对象判空
console.log(Object.keys(obj).length === 0);
console.log(Object.getOwnPropertyNames(obj).length === 0);

// ------------------------------------------------------------------------
// false false ， 错误做法，因为这是判断两个引用的地址
console.log(arr === [], obj === {});

// true ture ，不推荐，性能差，且 stringify() 本身有些限制，如 undefined 会被忽略
console.log(JSON.stringify(arr) === "[]", JSON.stringify(obj) === "{}");

// 不推荐，for...in 会便利到圆形上的自定义属性，for...of 虽然不会到圆形，但也只能用于 arr ，且麻烦
let arrIsEmpty = true, objIsEmpty = true;
arr.__proto__.a = 123;
obj.__proto__.a = 123;
for (const i of arr) arrIsEmpty = false;
for (const i in obj) objIsEmpty = false;
// true false
console.log(arrIsEmpty, objIsEmpty);
```

判断对象中是否有某属性：

* 以下方法都无法判断 Symbol key 属性：
  
  ```
  const obj = {
    a: undefined,
  };
  
  obj.__proto__.b = undefined;
  obj.__proto__.c = 123;
  
  // 判断是否连圆形上都不存在 -----------------------------------------------------------
  // 都是 undefined ，原型链上都找不到，但是无法确定是否 a 和 b 本身就是 undefined
  console.log(obj.a, obj.b, obj["a"], obj["b"]);
  // 123 123
  console.log(obj.c, obj["c"]);
  
  // 都是 true ，在原型链上找，同时可以确定是否值本身就是 undefined
  console.log("a" in obj, "b" in obj, "c" in obj);
  
  // 只判断对象本身是否有该属性，不去原型链上找 -----------------------------------------------
  // true false ，可以判断值本身就是 undefined 的属性
  console.log(obj.hasOwnProperty("a"), obj.hasOwnProperty("b"));
  
  // 同上，只是变成获取所有属性，包括非枚举属性
  console.log(Object.getOwnPropertyNames(obj));
  
  // ES13 新增 hasOwn() ，等价于 hasOwnProperty
  // 写法更简单，且不在 Object 圆形上，就不容易被修改调或意外的不可用
  console.log(Object.prototype.hasOwnProperty.call(obj, "a"));
  console.log(Object.hasOwn(obj, ""));
  ```

* 判断对象中是否有 Symbol key 属性：常规方法无法看到 Object 中的 Symbol key （Map 可以）：
  
  ```
  const obj = {
    a: "a",
    [Symbol("b")]: "b",
  };
  
  const map = new Map();
  map.set("a", "a");
  map.set(Symbol("b"), "b");
  
  // 无法看到 Objct 中的 Symbol key
  for (const i in obj) console.log(i);
  console.log(Object.keys(obj));
  console.log(Object.getOwnPropertyNames(obj));
  console.log(JSON.stringify(obj), "\n");
  
  // Map 就可以
  for (const i of map) console.log(i);
  console.log("\n");
  
  // 只能看到 Symbol key
  console.log(Object.getOwnPropertySymbols(obj), "\n");
  
  // 全部非圆形属性都能看到
  console.log(obj, map);
  ```

* 获取所有非圆形 key，包括 Symbol key 和非枚举属性：
  
  ```
  const obj = {
    a: 1,
    [Symbol("b")]: 2,
  };
  
  Object.defineProperty(obj, "c", {
    value: 3,
    enumerable: false,
  });
  
  obj.__proto__.d = 4;
  
  // ["a", Symbol(b), "c"]”
  console.log(Reflect.ownKeys(obj));
  ```

### 3.2 class

解决 JS 函数二义性的另一个方案，实例对象专门由 class 的 constructor 构造。

（1）基本

使用：

```
// err ，class 此时是暂时性死区，无法使用
try {
  console.log(A);
} catch {
  console.log("err");
}

// 声明
class A {
  constructor(a) {
    this.a = a;
    this.b = 2;
  }

  // 放到 A 原型上
  func1() {
    return this;  
  }

  // class 是局部作用域，所以箭头函数 this 为实例对象
  func2 = () => this;

  // ES13 新特性 --------------------------------------------------------------------
  // 在 constructor 外给 this 定义属性
  c = 3;
  [Symbol("d")] = 5;

  // 用 # 定义私有属性、私有方法 ，外部无法使用；私有方法是只读的
  #e = 5;
  #func3 = () => 6;
  getPrivate = () => this.#e + this.#func3();
  hasPrivate = (key) => #e in this;

  // 静态属性、静态方法、只能 class 本身使用，静态方法只能使用静态属性和静态方法
  static f = 7;
  static staticFunc = () => this.f;

  // static private
  static #g = 8;
  static getStaticPrivateFunc = () => A.#g;

  // 静态代码块，可以有多个，编译阶段就执行，只能使用静态属性和静态方法
  static {
    // 局部作用域

    // true ，this 指向类本身
    console.log(this === A, "\n");
  }
}

const obj = new A(1);

// 1 2
console.log(obj.a, obj.b);
// true
console.log(obj.func1() === obj.func2(), "\n");

// ，5+6
console.log(obj.getPrivate());
// 7
console.log(A.staticFunc());
// 8
console.log(A.getStaticPrivateFunc(), "\n");

// true true ，in 只能判断 public  的属性方法，private 的只能类提供 get 方法才行
console.log("a" in obj, obj.hasPrivate("e"));
// true ，判断 static 需要类本身
console.log("f" in A);
```

class 转 ES5 构造函数：

```
class A {
  constructor(name) {
    this.name1 = name;
    this.run2 = function () {};
  }

  name2 = "asdf";
  run3 = function () {};
  run4 = () => {};

  run1() {}
  static staticFunc() {}

  static staticProp = "static";
  static run5 = () => {};
  static {
    console.log("staic block");
  }

  #privateFunc() {}
}

// 转化成 ES5 构造函数 --------------------------------------------------------------
// ES13 的 # 私有属性方法，由于是语法底层实现的，所以自己无法实现，原型上也没有
function B(name) {
  "use strict";
  if (!(this instanceof B)) throw new TypeError("只能 new 调用");

  this.name1 = name;
  this.name2 = "asdf";
  this.run2 = function () {};
  this.run3 = function () {};
  this.run4 = () => {};
}

[
  { target: B.prototype, funcs: [{ key: "run1", value: A.prototype.run1 }] },
  { target: B, funcs: [{ key: "staticFunc", value: A.staticFunc }] },
].forEach((item) => {
  for (var i = 0; i < item.funcs.length; i++) {
    var index = i;

    Object.defineProperty(item.target, item.funcs[i].key, {
      value: function () {
        if (typeof this !== "function" && !(this instanceof B)) {
          throw new TypeError("不能 new 调用");
        }

        item.funcs[index].value.call(this);
      },

      writable: true,
      configurable: true,
      enumerable: false,
    });
  }
});

(function () {
  this.staticProp = "static";
  this.run5 = () => {};

  console.log("static block");
}).call(B);
```

（2）类的继承

```
class A {
  constructor(a) {
    this.a = a;
  }

  fatherFunc() {
    console.log("fatherFunc");
  }
}

// 只能单继承
class B extends A {
  constructor(a, b, c) {
    // 子类中必须有 super() 调用父类的 constructor ，否则 new 时会 err
    super(a);
    this.b = b;
    this.c = c;
  }

  sonFunc() {
    // 调用父类的方法
    super.fatherFunc();
    console.log("sonFunc", "\n");
  }

  // 重写父类方法
  fatherFunc() {
    // 可以使用父类同名方法
    // super.fatherFunc();

    console.log("rewrite fatherFunc");
  }
}

const son = new B(1, 2, 3);

// // 1 2 3
console.log(son.a, son.b, son.c, "\n");

son.sonFunc();
son.fatherFunc();
```

（3）实现私有属性

ES6 的访问器使用 _name 在命名上区分私有属性，但约束力不强；用 Symbol key 实现私有属性和也有办法访问。

ES13 有 \# 可以实现，且是运行时，不过由于是新特性，可能有兼容性问题。

TypeScript 中的 private 只是编译时，编译后的 JS 也没有使用 # ，且就算再 ts 中，也有办法可以使用动态属性绕过检查：

```
class A {
  private a = 5;
}

const obj = new A();
console.log(obj["a"]);
```

自己实现可以使用立即执行函：

```
class A {
  // 立即执行函数，防止外部访问私有属性
  privateFields = (function () {
    const fields = {
      a: 1,
    };

    // 闭包，防止 fields 被垃圾回收
    return {
      get: (key) => {
        // 防止从原型上访问，只有 key 时 privateFields 有的属性时，才允许访问
        if (fields.hasOwnProperty(key)) return fields[key];
      },
      set: (key, newValue) => {
        if (fields.hasOwnProperty(key)) fields[key] = newValue;
      },
    };
  })();
}

const obj = new A();

// 1
console.log(obj.privateFields.get("a"));

// 2
obj.privateFields.set("a", 2);
console.log(obj.privateFields.get("a"));

// 测试从原型上访问
Object.defineProperty(Object.prototype, "abc", {
  get() {
    return this;
  },
});
obj.privateFields.set("a", 3);
console.log(obj.privateFields.get("abc")?.a);
```

或者使用模块化，把私有属性存放在 WeakMap ：

```
// 用 WeakMap 而不是 Map、Object ，是为了垃圾回收对象时，同时也会受 WeakMap 的元素
const privateFields = new WeakMap();

export default class {
  constructor() {
    privateFields.set(this, { a: 1 });
  }

  getPrivateFields = () => privateFields.get(this);
}
```

### 3.3 原型

原型是一个对象，所以也叫原型对象。任何一个实例对象通过隐式原型属性 \_\_proto\_\_ ，任何一个构造函数通过显示原型属性 prototype ，就能访问到原型，实例对象和它的构造函数指向的是同一个原型对象：

```
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const p = new Person("asdf", 18);

// true 
console.log(p.__proto__ === Person.prototype);

const obj = { a: 1 };

// true ，字面量对象本是 new Object()
console.log(obj.__proto__ === Object.prototype);

// 原型对象也是对象，也有原型，而这个原型对象是 Object 构造的
// true
console.log(Person.prototype.__proto__ === Object.prototype);

// Object 的原型不再有原型，指向 null
// null
console.log(Object.prototype.__proto__);
```

数组、函数等都是对象：

```
const arr = [];
const func = () => {};

// true true
console.log(arr.__proto__ === Array.prototype);
console.log(func.__proto__ === Function.prototype, "\n");

// true true ture ，它们的原型对象的原型，即 Object 的原型
console.log(Array.prototype.__proto__ === Object.prototype);
console.log(Function.prototype.__proto__ === Object.prototype);
console.log(Number.prototype.__proto__ === Object.prototype);
```

ES6 新增的有关圆形的 API：

```
// 创建 obj ，并指定原型，属性描述符默认都为 false （new Object() 默认为 true）
function Person() {
  this.a = 1;
}

const obj = Object.create(new Person(), {
  b: {
    value: 2,
  },
});

// 1 2
console.log(obj.__proto__.a, obj.b, "\n");

// { a: 1 } ，返回 obj 的原型 ----------------------------------------------------------
console.log(Object.getPrototypeOf(obj), "\n");

// 给 obj 设置新的原型 -----------------------------------------------------------------
Object.setPrototypeOf(obj, { c: 3 });

// { c: 3 }
console.log(obj.__proto__), "\n";
```

（2）原型链

原形对象和函数都是对象，也有圆形，就形成了原型链，Object new 出原型对象，Function new 出函数：

- Object.prototype 是最终的原型，没有构造者，网上就是 null

- Function 的 __proto__ 和 prototype 是同一个原型对象

```
// Array 、Set 等也是一样的
function Person() {}
const obj = new Person();

const A = obj.__proto__;
const B = A.__proto__;
const C = Person.__proto__;

// 都是 true
console.log(
  A === Person.prototype,
  B === Object.prototype,
  C === Object.__proto__ && C === Function.prototype,

  // 特殊情况
  B.__proto__ === null,
  Function.__proto__ === Function.prototype
);
```

```
obj ---> __proto__ ---> A ---> __proto__ ---> B ---> null
 |\                    /|\                   /| 
   \                  /   \                 / |
    \                /     \               /  |
     \              /       \             /   |
     new        prototype   new     rototype  |
      \           /          \          /     |
       \         /            \        /      |
        \       /              \      /       |
        \      /                \    /        |
         Person <---- new ----> Object        |
             \         |          /  |        |
              \     Function     /   |        |
               \       |        /    |        |
               \       |       /     |        |
                \  prototype  /      |        |
                 \\    |     /       |        |
                  \    &    /        |        |
                   \   |   /         |        |
                   __proto__         |        |
                     \ | /           |        |
                      \|/            |        |
                       C <--- new ---|        |
                       |                      |
                       |----- __proto__ ------|
```

obj instanceof Func ，判断 obj 的原型链上是否能找到 Func.prototype ：

```
// true true
console.log({} instanceof Object, [] instanceof Array);

// true ture
console.log(Number instanceof Object, Function instanceof Object);

// 都是 false ，无法判断基本数据类型
console.log(
  123 instanceof Number,
  "" instanceof String,
  undefined instanceof Number,
  null instanceof Number
);
```

原型链的作用是查找属性和方法，当对象自身不存在该属性，会去原型上找，直到 Object 的原型中都没有时，返回 undefined ，这个过程是自动的，不需要手动调用原型，简化了语法：

```
const obj = { a: 1 };

// 可以在原型上添加自定义的属性、方法
obj.__proto__.b = 2;

// 1 2 2 ，不用手动找原型，JS 自己就会在原型链上找
console.log(obj.a, obj.b, obj.__proto__.b);

// undefined ，因为 Object.prototype 中都没有属性 c
console.log(obj.c);
```

（3）ES5 继承

```
/**为了保证原型链的完整性
 * ，实例对象的 __proto__ 和类的 prototype 要保证是一个对象
 * 子类、父类的 prototype 不能是同一个对象
 */

function Person(name) {
  this.name = name || "person";
  this.arr = [1];
  this.run = () => {};
}
Person.prototype.msg = "person_prototype_msg";

/**原型链继承 -------------------------------------------------------------------------
 * 优点：可继承父类原型
 * 缺点：无法多继承；new 时无法给父构造函数传参
        一些操作如数组 push 会先 get ，自身没有就会到原型上再 set ，所有实例对象也会修改
 */
function SonA(age) {
  this.age = age || 18;
}
SonA.prototype = new Person();

const a1 = new SonA(18);
const a2 = new SonA(18);

// { age: 18 } person person_prototype_msg
console.log(a1, a1.name, a1.msg);

a1.name = "xxx";
// xxx person ，由于自己身上没有 name 就直接 set ，而不会去 __proto__
console.log(a1.name, a2.name);

a1.arr.push(2);
// [1, 2] [1, 2] ，先 get arr ，所以会去到 __proto__ 再 set ，所有实例对象就都修改了
console.log(a1.arr, a2.arr, "\n");

/**构造函数继承 --------------------------------------------------------------------
 * 优点：new 时可以给父构造函数传参；可用搓个 call 实现多继承
 * 无法继承父类原型
 */
function SonB(name, age) {
  Person.call(this, name);
  this.age = age || 18;
}

const b = new SonB("myName", 18);

// { name: "myName", age: 18, arr: [1], run } undefined
console.log(b, b.msg, "\n");

/**组合继承 --------------------------------------------------------------------
 * 原型链继承 + 构造函数继承
 * 优点：可多继承，可以给父构造函数传参、可继承圆形，由于实例对象已经有父类的属性方法，所以使用这些属性方法不会去原型找，继承的原型就不会被共享
 * 缺点：需要执行两次父构造函数，Child.prototype 的属性方法实际上是不需要的
 */
function SonC(name, age) {
  Person.call(this, name);
  this.age = age || 18;
}
SonC.prototype = new Person();

const c = new SonC('myName"', 18);

// { name: "myName", age: 18, arr: [1], run } person_prototype_msg
console.log(c, c.msg);

/**寄生组合继承 --------------------------------------------------------------------
 * 组合继承的基础上，把 Child.prototype 变成空对象
 */
SonC.prototype = Object.create(Person.prototype);

// create 的简化实现
function func(prototype) {
  function F() {}
  F.prototype = prototype;
  return new F();
}

// SonC.prototype = func(Person.prototype);
```

### 3.4 this

函数中的 this 只有在调用时，才确定 this 的指向。

ES11 新特性，globalThis ，始终指向全局对象：

```
// 浏览器：window ，node：node 全局对象
console.log(globalThis);
```

（1） this 的 4 种绑定规则

优先级：new > 显示 > 隐式 > 默认 。

默认绑定规则：

- 全局作用域中，浏览器 this 指向 window ，node 的 this 指向 {} ：
  
  ```
  // 浏览器中 window window
  // node 中 {} 和 node 全局对象
  console.log(this, globalThis);
  ```

- 函数不通过对象直接调用，而是独立调用，浏览器中指向 window ，node 中指向 node 全局对象，这个 node 全局对象可以用 globalThis 获取。
  
  本质就是独立调用的函数是 window.func() 或 globalThis.func() 调用的，所以才指向它们：
  
  ```
  function func1() {
    console.log(this);
  }
  func1();
  
  (function func2() {
    console.log(this);
  })();
  
  function func3() {
    return function () {
      console.log(this);
    };
  }
  func3()();
  
  function func4(fn) {
    fn();
  }
  func4(function () {
    console.log(this);
  });
  
  const obj = {
    func5() {
      return function () {
        console.log(this);
      };
    },
  };
  obj.func5()();
  ```
  
  在严格模式下，这种情况会指向 undefined ，但是不影响全局作用域的 this 和任何作用域的 globalThis ，webpack 、vite 默认都是严格模式。
  
  原因是严格模式下，认为独立调用时就是一个普通函数，自然没有 this ：
  
  ```
  "use strict";
  
  console.log(this);
  console.log(globalThis);
  
  function func() {
    console.log(this);
  }
  func();
  ```

隐式绑定规则：

- 对象调用，就指向这个对象：
  
  ```
  const obj = {
    a: 1,
    func() {
      console.log(this);
    },
  };
  
  // obj
  obj.func();
  ```

- 隐式丢失，结果和函数独立调用一样；
  
  ```
  const obj = {
    a: 1,
    func() {
      console.log(this);
    },
  };
  
  // window 或 node 全局对象，严格模式下是 undefined
  const fn = obj.func;
  fn();
  ```

- 圆形链上的函数，若 obj 是通过隐式的使用隐式圆形属性调用的，指向 obj ；若是主动加上 __proto__ 调用的，指向圆形对象：
  
  ```
  const obj = {};
  const op = obj.__proto__;
  
  obj.__proto__.func = function () {
    console.log(this === obj, this === obj.__proto__);
  };
  
  // true false
  obj.func();
  
  // false true
  obj.__proto__.func();
  
  // false true
  op.func();
  ```

显示绑定规则：

- call ，apply ，bind 显示修改 this ：
  
  ```
  function func(a, b) {
    console.log(this, a, b);
  }
  
  const obj = { a: 1 };
  
  func.call(obj, 1, 2);
  func.apply(obj, [1, 2]);
  
  const fn = func.bind(obj, 1);
  fn(2);
  
  // 实现 call 、apply 、bind --------------------------------------------------------------
  Function.prototype.myCall = function (ctx, ...args) {
    // 原版 call 中传入的 this 是 undefined 、null 时就用 globalThis
    ctx = ctx ?? globalThis;
  
    // 使用后，若 this 为基本类型则转为包装类对象，引用类型则不变
    ctx = Object(ctx);
  
    // 把函数挂到 ctx 中再调用，this 就指向 ctx 了
    const tempKey = Symbol();
    // 防止在函数调用期间用到这个临时 key
    Object.defineProperty(ctx, tempKey, {
      value: this,
      enumerable: false,
    });
  
    ctx[tempKey](...args);
    delete ctx[tempKey];
  };
  
  Function.prototype.myApply = function (ctx, args) {
    if (
      typeof args !== "object" &&
      typeof args !== "function" &&
      args !== undefined
    ) {
      throw "err";
    }
  
    if (
      [
        "[object Undefined]",
        "[object Null]",
        "[object Set]",
        "[object Map]",
      ].includes(Object.prototype.toString.call(args))
    ) {
      args = [];
      console.log(123);
    } else {
      args = Array.from(args);
    }
  
    this.myCall(ctx, ...args);
  };
  
  Function.prototype.myBind = function (ctx, ...args) {
    const fn = this;
  
    return function (...subArgs) {
      const allArgs = [...args, ...subArgs];
  
      // 原版 bind 是支持 new 这个函数的，且最终 new 的是调用 bind 的函数而不是返回的函数
      if (new.target) return new fn(...allArgs);
      else return fn.myCall(ctx, ...allArgs);
    };
  };
  ```

new 绑定：

- this 指向实例对象：
  
  ```
  function Person() {
    console.log(this);
  
    this.a = 1;
    this.getThis = function () {
      console.log(this);
    };
  }
  
  const obj1 = new Person();
  obj1.getThis();
  ```

- 构造函数默认 return this ，使得接收的变量获得实例对象，若修改了 return ，则会得到 retuirn 的对象，不推荐这么做：
  
  ```
  function Person() {
    console.log(this);
  
    this.a = 1;
    this.getThis = function () {
      console.log(this);
    };
  
    return { b: 2 };
  }
  
  const obj1 = new Person();
  
  // { b: 2 }
  console.log(obj1);
  ```

特殊情况：

- 箭头函数没有 this ，也不适用 this 的四种绑定规则，使用 this 其实就是在作用域链中找：
  
  ```
  const obj = {
    func1: () => {
      console.log(this);
    },
  
    func2: function () {
      return () => console.log(this);
    },
  
    func3: () => {
      return () => console.log(this);
    },
  };
  
  // 浏览器：window ，node：{} ，在作用域链中找到 this 在全局作用域
  obj.func1();
  // 浏览器：window ，node：{} ，箭头函数使用 this 规则无效
  obj.func1.call(obj);
  
  // 浏览器和 node 都是 obj，在作用域链中找到 this 在 func2 局部作用域中，而 func2 是 obj 调用的
  obj.func2()();
  
  // 浏览器：window ，node：node 全局对象，在作用域链中找到 this 在 func2 局部作用域中，而 func2 隐式丢失，相当于独立调用
  const f = obj.func2;
  f()();
  
  // 浏览器：window ，node：{} ，在作用域链中找到 this 在全局作用域
  obj.func3()();
  ```

- API 的回调函数的 this 由内部实现决定，如 Vue 的一般都指向 Vue 实例。但如果回调函数是箭头函数，则不管内部如何实现，this 都只看调用 API 的作用域：
  
  ```
  function api(fn) {
    const obj = { a: 1 };
    fn.call(obj);
  }
  
  // obj
  api(function () {
    console.log(this);
  });
  
  // 浏览器：window ，node：{} ，在作用域链中找到 this 在全局作用域
  api(() => {
    console.log(this);
  });
  ```

（2）实例

注意，浏览器 window 和 node 全局对象有一些内置属性；

```
// ""
console.log(window.name);
```

```
// 浏览器：window.name = 3 ，node：{}.name = 3 ，node 全局对象.name = 4
// 非严格模式
globalThis.name = 4;
this.name = 3;

const obj1 = {
  name: "1",

  fn1() {
    console.log(this.name);
  },

  fn2: () => console.log(this.name),

  fn3() {
    return function () {
      console.log(this.name);
    };
  },

  fn4() {
    return () => console.log(this.name);
  },
};

const obj2 = {
  name: "2",
};

// 浏览器：1 2 3 3 ，node：1 2 3 3
obj1.fn1();
obj1.fn1.call(obj2);
obj1.fn2();
obj1.fn2.call(obj2);
console.log("\n");

// 浏览器： 3 2 3 ，node：4 2 4
obj1.fn3()();
obj1.fn3().call(obj2);
obj1.fn3.call(obj2)();
console.log("\n");

// 浏览器：1 1 2 ，node：1 1 2
obj1.fn4()();
obj1.fn4().call(obj2);
obj1.fn4.call(obj2)();
```

### 3.5 属性描述符、代理

JS 中，有两种方式可以拦截引用类型的 get 、set ：

* ES5 的 Object\.defineProperty

* ES6 的 Proxy

（1）ES5 的 Object\.defineProperty

给属性设置访问器、属性描述符：

```
const obj = {};
let data = 0;

Object.defineProperty(obj, "a", {
  // 访问器 ---------------------------------------------------------
  get() {
    // 设置 getter 后，obj.a 类似于 get(obj, "a")
    return data;
  },

  set(newValue) {
    // 设置 setter 后，obj.a = newValue 类似于 set(obj, "a", newValue)
    // 不可以 obj.a = newValue ，因为会无线递归 setter
    data = newValue;
  },

  // 设置属性的 value
  // 有了 getter 就不能这样设置 value
  // value: 123,

  // 三个属性描述符 ----------------------------------------------------
  // 构造函数、字面量(即 new Object())、class 创建的对象，这三个属性描述符默认都是 true ，而 defineProperty 默认为 false

  // 默认 false ，是否可修改，包括上面是否能以 value 形式修改
  // 设置了 setter 后，就不能把 writable: 设为 true ，因为修改已经交给 setter 处理了
  // writable: true,

  // 默认 false ，是否可枚举，如 for...in ，Object.keys() 等是否能获得这个属性
  enumerable: true,

  /**默认 false ，false 后：
   * 属性不可删除
   * 无访问器时无法添加访问器，若已有访问器也无法去掉
   * 三个属性描述符不能再修改
   */
  configurable: true,
});

obj.a = 123;
// 123
console.log(obj.a);

// ES8 新特性，获取属性描述符信息 -----------------------------------------------------
console.log(Object.getOwnPropertyDescriptor(obj, "a"));

// 实现数据代理 -----------------------------------------------------------------
function defineReactive(target, key) {
  if (!(target instanceof Object)) return;

  // 闭包数据
  let value = target[key];

  Object.defineProperty(target, key, {
    get: () => value,
    set: (newValue) => (value = newValue),
  });
}

const o = { a: 1 };
defineReactive(o, "a");
o.a = 123;
// 123
console.log(o.a);
```

ES6 新特性，访问器语法糖，可以在对象、构造函数、class 中直接设置访问器：

```
const obj = {
  a: 1,

  get b() {
    return this._b;
  },

  set b(newValue) {
    this._b = newValue;
  },

  // 可以设置多个访问器
  // get c() {},
  // set c(newValue) {},
};

obj.b = 2;

// 2
console.log(obj.b);
// { a: 1m b: [Getter/Setter], _b: 2}
console.log(obj);

// "a" "b" "_b"
console.log(Object.keys(obj), "\n");

// 实现数据代理 -----------------------------------------------------------------------
function ref(value) {
  // value 是闭包数据

  return {
    get value() {
      return value;
    },

    set value(newValue) {
      value = newValue;
    },
  };
}

const a = ref(123);

a.value = 456;
console.log(a.value);
```

（2）Proxy

ES6 新特性，Proxy 可以实现代理一个对象。

Proxy 可以拦截所有对象的基本操作，如对象属性的读取、修改、添加、删除，判断属性是否存在；数组由于也是对象，所以数组元素的操作也可以拦截。

原理是对象的操作最终都会执行浏览器的内部方法，如 .get() 、.set() 等。

```
const obj = { a: 1 };
// const obj = [1, 2];

const p = new Proxy(obj, {
  // 拦截基本操作 get()
  get(target, key, receiver) {
    // return target[key];
    return Reflect.get(target, key, receiver);
  },

  // 拦截基本操作 .hasProperty ，如使用 in
  has(target, key) {
    // return key in target;
    return Reflect.has(target, key);
  },

  // 拦截基本操作 .ownKeys，如使用 for...in
  ownKeys(target) {
    return Reflect.ownKeys(target);
  },

  // 拦截基本操作 .set ，如修改、添加
  set(target, key, newValue, receiver) {
    // try {
    //   target[key] = newValue;
    //   return true;
    // } catch {
    //   return false;
    // }

    return Reflect.set(target, key, newValue, receiver);
  },

  deleteProperty(target, key) {
    // try {
    //   delete target[key];
    //   return true;
    // } catch {
    //   return false;
    // }

    return Reflect.deleteProperty(target, key);
  },
});
```

Proxy 中的拦截器建议使用 Reflect ：

- Proxy 的 set 、deleteProperty 这些拦截修改、删除操作的拦截器，需要 return 布尔值表示是否操作成功，通常需要 try...catch ，而 Reflect 内部就有 try...catch ，也 return 布尔值，使用起来更简洁

- 一些情况需要直接使用内部方法修改 this ，Reflect 就可以做到

（3）冻结 freeze

Object\.freeze 冻结一个对象、冻结后无法修改、增加、删除属性、无法设置属性描述符、无法更换圆形、但是冻结对象自身可以赋值成另一个引用：

```
// 修改被冻结的对象的属性大多数情况下都会 thrrow error --------------------------------
let obj = { a: 1 };
const sameObj = Object.freeze(obj);

// true
console.log(obj === sameObj);

// err
try {
  obj.a = 2;
} catch {
  console.log("err");
}

// err
try {
  Object.defineProperty(obj, "a", { value: 3 });
} catch {
  console.log("err");
}

// 1 true
console.log(obj.a, Object.isFrozen(obj));

// 冻结对象自身可以重新赋值成另一个引用
obj = { a: 1 };
obj.a = 11;
// 11 false
console.log(obj.a, Object.isFrozen(obj), "\n");

// 浅冻结 --------------------------------------------------------------------------
// freeze 只能冻结自己，如果冻结对象的属性是一个引用类型，是不会深度冻结的
const obj1 = { a: 1, deepObj: { b: 2 } };
Object.freeze(obj1);
obj1.deepObj.b = 3;

// 3 false
console.log(obj1.deepObj.b, Object.isFrozen(obj1.deepObj), "\n");

// freeze 前设置了 setter ------------------------------------------------------
//  只要 set 的目标不是冻结对象的属性，就可以正常 set
let b = 2;
const obj2 = {
  a: 1,
  get b() {
    return b;
  },
  set b(newValue) {
    b = newValue;
  },
};

function defineReactive(o, k) {
  let value = o[k];

  Object.defineProperty(o, k, {
    get() {
      return value;
    },

    set(newValue) {
      value = newValue;
    },
  });
}

defineReactive(obj2, "a");
Object.freeze(obj2);

obj2.a = 11;
obj2.b = 22;

// 11 true
console.log(obj2.a, Object.isFrozen(obj2));

// 22 true
console.log(obj2.b, Object.isFrozen(obj2));

// Proxy 则不行，因为 set 的毁掉已经到了调用 set() 的阶段了
const obj3 = { c: 3 };
const p = new Proxy(obj3, {
  get: (t, k) => t[k],
  set(t, k, v) {
    t[k] = v;
    return true;
  },
});
Object.freeze(p);

// err
try {
  p.c = 33;
} catch {
  console.log("err");
}
```

简单实现 freeze ：

```
function myFreeze(obj) {
  if (!(obj instanceof Object)) return obj;

  // 只处理自己的属性，不涉及到圆形
  const keys = [
    ...Object.getOwnPropertyNames(obj),
    ...Object.getOwnPropertySymbols(obj),
  ];

  for (const key of keys) {
    Object.defineProperty(obj, key, {
      // 设置不能修改 value
      writable: false,

      // 设置不能删除属性、不能设置属性描述符
      configurable: false,
    });
  }

  // 设置不能新增属性、不能更换圆形
  Object.preventExtensions(obj);

  // 用 Object.defineProperty 给所有属性设置 configureble 为 false ，并调用 Object.preventExtensions()
  // Object.seal(obj);

  return obj;
}
```

### 3.6 数组

（1）ES5

Array ，构造函数 ，即 Array 也是对象：

```
var arr = [1, 2];
var arr1 = new Array(2);
var arr2 = new Array(2, 123);

// [undefined, undefined] ，[123, 123]
console.log(arr1, arr2);

// 2
console.log([1, 2].length);

// Array 转 String ，纯函数
// "1,2" "1,2,3"
console.log([1, 2].toString(), [[1, 2], [30]].toString());
// "1&2"
console.log([1, 2].join("&"));

// 非纯函数 -------------------------------------------------------
// 头尾增加、删除
console.log(arr);
var b = arr.pop();
var a = arr.shift();
arr.push(22);
arr.unshift(11);
// [11, 22] 1 2
console.log(arr, a, b);

// [22] ，删除左闭右开的元素
arr.splice(0, 1);
console.log(arr);
// [2] ，替换
arr.splice(0, 1, 2);
console.log(arr);
// [1, 2, 3] ，插入
arr.splice(0, 0, 1);
arr.splice(2, 0, 3);
console.log(arr);

// 翻转、排序
// [3, 2, 1]
arr.reverse();
console.log(arr);
// [1, 2, 3]
arr.sort();
console.log(arr);
// [3, 2, 1]
arr.sort(function (a, b) {
  return b - a;
});
console.log(arr);

console.log("----------------------------------------");

// 以下方法都是纯函数 ---------------------------------------------------------
// [1, 2, 3, 4] ，拼接
console.log([1, 2].concat([3, 4]));

// [1, 2] ，取出左闭右开的元素
console.log([1, 2, 3].splice(0, 2));

// 查找 ，返回下标，找不到返回 -1 ，第二个参数是开始下标
// lastIndexOf 是 ES14 新特性
// 0 2 -1 -1
console.log(
  [1, 2, 3].indexOf(1),
  [1, 2, 3].lastIndexOf(3),
  [1, 2, 3].indexOf(1, 1),
  [1, 2, 3].lastIndexOf(3, 1)
);
```

（2）ES6

```
const arr = [1, 2, 3];

// ES6 ----------------------------------------------------------------------------
// true ， 判断是否是一个真正的数组
console.log(Array.isArray(arr));

// 深拷贝数组，纯函数，参数可以是伪数组、Set 、Map ，结果都是真正的 Array
// [1, 2, 3]
console.log(Array.from(arr));
// [1]
console.log(Array.from(new Set([1])));
// [["a", 1]]
console.log(Array.from(new Map([["a", 1]])));
// [] []
console.log(
  Array.from({ a: 1 }),
  Array.from(function () {}),
  "\n"
);

// [2,4,6] ，纯函数，便利原数组并根据自定义条件生成新数组
console.log(arr.map((i) => i * 2));

// [1, 2] ，纯函数，便利原数组并根据条件筛选
console.log(arr.filter((i) => i < 3));

// 6 ，纯函数，便利数组并汇总，pre 为上一次便利的 return；第二个参数为初始值，默认为 0
console.log(arr.reduce((pre, now) => pre + now, 0));

// 6 ，2+4 ， 链式调用 map 、filter 、reduce
console.log(
  arr
    .filter((i) => i < 3)
    .map((i) => i * 2)
    .reduce((pre, now) => pre + now, 0),
  "\n"
);

// 查询元素是否符合条件 ，都是纯函数
// false ，便利整个数组，全部符合条件就返回 true
console.log(arr.every((i) => i > 3));
// true ，便利整个数组或者提前返回，只要一个符合条件就马上返回 true
console.log(
  arr.some((i) => i > 2),
  "\n"
);

// 查找第一个符合条件的元素，找到就马上返回，都是纯函数
// 1 ，找到返回元素值或引用，找不到返回 undefined
console.log(arr.find((value, index, arr) => value < 2));
// 0 ，找到返回 index ，找不到返回 -1
console.log(
  arr.findIndex((value, index, arr) => value < 2),
  "\n"
);

// [0, 2, 3] ，替换，非纯函数，第二、三个参数为开始、结束 index（左闭右开），默认全部替换
console.log(arr.fill(0, 0, 1), "\n");

// ---------------------------------------------------------------------------------------
// ES7 新特性，查询是否有某个元素，纯函数，找到就马上返回 true ，string 也可使用
// true
console.log(arr.includes(2), "\n");

// ES10 新特性，数组降维，纯函数
const deepArr = [1, [2, [3, 4]]];
// [1, 2, 3, 4] ，[1, 2, [3, 4]] ，参数为降低的维度，默认为 1
console.log(deepArr.flat(2), deepArr.flat());
// [2, NaN] ，等价于 arr.map().flat()
console.log(deepArr.flatMap((i) => i * 2));

// ES13 新特性，纯函数，访问元素，可以传入负数反向索引，string 也可使用
const arr13 = [1, 2, 3];
const str13 = "asdf";
// 1 3 "a" "f"
console.log(arr13.at(0), arr13.at(-1), str13.at(0), str13.at(-1));

// ES14 新增 6 个纯函数 ------------------------------------------------------------
const arr14 = [1, 5, 3, 4, 7];

// 反向的 find 和 findIndex
console.log(
  arr14.findLast((i) => i > 3),
  arr14.findLastIndex((i) => i > 3)
);

// 排序、翻转
console.log(arr14.toSorted(), arr14.toReversed());

// 对应 splice
console.log(arr14.toSpliced(2, 1, -1));

// 索引对应的元素替换为 newValue
console.log(arr14.with(0, 11));
```

### 3.7 包装类

除了 null 、undefined 、Symbol 的其他 6 个基本数据类型，都有包装类，内置了一些属性和方法。

```
var n = 123;
var s = "asdf";
var b = true;

var num = new Number(123);
var str = new String("asdf");
var bool = new Boolean(true);

// 123 "asdf" true
console.log(n, s, b);

// 都是对象
console.log(num, str, bool);
```

其中 String 即使不是 new 出来的，也可以直接使用包装类的 API ，但由于 String 是基本类型，每次调用 API 都会生成一个临时的包装类 String 对象：

```
// "a" 4
console.log("asdf"[0], "asdf".length);

var str = "asdf";

// node 会报错，不允许这么做，浏览器就可以
str[0] = "q";
str.a = "1";

// "asdf" undefined ，因为修改的是临时对象
console.log(str, str.a);
```

String 中的 API ：

```
var sxtr1 = "";
var str2 = new String("asdf");

// 4 "asdf"
console.log("asdf".length, "as" + "df");

// 大小写转换
console.log("asdf".toUpperCase(), "ASDF".toLowerCase());

// ["as", "df"] ，string 转 Array ，不改变原字符串
console.log("as df".split(" "));

// 访问
// "a" 97
console.log("asdf".charAt(0), "asdf".charCodeAt(0));
// "a" ，HTML5 新增
console.log("asdf"[0]);

// "as" ，用法和 slice 一样
console.log("asdf".substring(0, 2));

// 替换第一个遇到的子串，不改变原字符串
// "dfdf"
console.log("asdf".replace("as", "df"));

console.log("----------------------------------------------");

// 以下方法用法都和 Array 一样，不改变原字符串 ----------------------------------------
// "asdf"
console.log("as".concat("df"));

// "asd"
console.log("asdf".slice(0, 3));

// 查找 ，返回下标，找不到返回 -1 ，第二个参数是开始下标
// 0 3 -1 -1
console.log(
  "asdf".indexOf("a"),
  "asdf".lastIndexOf("f"),
  "asdf".indexOf("a", 1),
  "asdf".lastIndexOf("f", 2)
);
```

ES6 String API ：

```
// ES8 新特性，填充字符串，纯函数，、(n, c) 填充 c 直到 length 为 n 为止，c 默认为 " "
// "aab" " b"
console.log("b".padStart(3, "a"), "b".padStart(2));
// "qwb"
console.log("b".padStart(3, "qwertyu"));
// "bcs"
console.log("b".padEnd(2, "c"), "\n");

// ES10 新特性，去掉首尾空格，纯函数
// "a" "a"
console.log("  a".trimStart(), "a  ".trimEnd(), "\n");

// ES12 新特性，替换所有符合条件的子串，纯函数
console.log("aaa".replaceAll("a", "b"), "\n");

// ES15 新特性，处理非法代理对 ----------------------------------------------
const illFormed = "\uD800";

// false ，代理对是否承兑出现
console.log(illFormed.isWellFormed());
// 将非法字符替换为 “\uFFFD”
console.log(illFormed, illFormed.toWellFormed());
```

ES6 Number API ：

```
// Number.EPSILON ，用于浮点数运算
if (Math.abs(0.3 - (0.1 + 0.2)) < Number.EPSILON) console.log("相等");

// 进制
const a = 0b1010, b = 0o777, c = 0xff;

// 判断是否是整数
console.log(Number.isInteger(123));

// 判断是否是有理数
console.log(Number.isFinite(123));

// 转化成整数、浮点数
console.log(Number.parseInt(3.14), Number.parseFloat("3"));

// 判断是否是 NaN ，只有 NaN 才返回 true
console.log(Number.isNaN(NaN));
// 而 ES5 的 window.isNaN 会把 undefined ，String 、Object 都返回 true ，因为会进行类型转换
// console.log(window.isNaN(undefined));
```

### 3.8 正则

ES5 ：

```
// 创建正则 ----------------------------------------------------------------------------
// 字面量，只能是 /reg/
var reg1 = /a/;

// 构造函数创建，strinmg 和 /reg/ 都可以
var reg2 = new RegExp(/a/);
var reg3 = new RegExp("a");

// 修饰符，用于修改匹配模式 ---------------------------------------------------------
// 默认情况区分大小写，只匹配第一个结果
var r1 = /a/;

// g：找到所有结果  ， i：不区分大小写  ， m：每行分别匹配
var r2 = /a/g;
var r3 = new RegExp("a", "i");
var r3 = /a/gim;

// 匹配 ------------------------------------------------------------------------------
// 找到第一个匹配结果（g 无效），结果为 Array ，信息包含匹配结果、首字符下标等；找不到为 null
// [ 'as', index: 0, input: 'asdf', groups: undefined ]
console.log(/as/.exec("asas")), reg1;

// 默认模式和 exec 一样，g 模式则返回所有匹配结果
// [ 'as', index: 0, input: 'asdf', groups: undefined ]
console.log("asas".match(/as/));
// ["as", "as"]
console.log("asas".match(/as/g), "\n");

// 配合 string 内置方法 -------------------------------------------------------------
// "dfas" ，正则替换，不改变原 string
console.log("asas".replace(/as/, "df"));

// ["as", "as"] ，正则将 string 转 Array ，不改变原 string
console.log("as-as".split(/-/), "\n");

// 配合 ES6 的 every 实现多正则匹配，如密码检测 ------------------------------------
var reg = [/[a-zA-Z0-9]{6,10}/, /[A-Z]/, /[0-9]/];
console.log(reg.every((r) => r.test("123456")));
```

ES6 ：

```
// ES9 -------------------------------------------------------------------------------
// 增加了负向后行断言，正向后行断言
// 新增匹配模式：dotAll 模式，修饰符 s ，使得可以匹配换行符

// 分组可以命名 左括号后加 ?<name>
const a = /\w+(?<num>\d+)/;

// 为每个字符分配了多个转义属性，比如判断是否存在希腊语字符，可以匹配 Script_Extensions 属性为 Greek 的字符
console.log(/\p{Script_Extensions=Greek}/.test("π"));

// ES11 -----------------------------------------------------------------------------
// ES5 正则中，若想获得所有匹配结果并同时得到下标，只能使用循环
const regExp = /yyds(\d+)/g;
const text = "yyds1 is a very good yyds2";
let matches;
while ((matches = regExp.exec(text)) !== null) {
  console.log(matches);
}

// matchAll
const reg = /yyds(\d+)/g;
const t = "yyds1 is a very good yyds2";
let m = [...t.matchAll(reg)];
for (const match of m) {
  console.log(match);
}

// ES13 --------------------------------------------------------------------------
// 新的修饰符 d，表示想要匹配字符串的开始和结束索引
const matchObj = /(a+)(b+)/d.exec("aaaabb");
// 'aaaa'
console.log(matchObj[1]);
// 'bb'
console.log(matchObj[2]);
// 由于 /d 标识的存在，matchObj 有一个属性 .indices，它用来记录捕获的每个编号组
console.log(matchObj.indices[1]); // [0, 4]
console.log(matchObj.indices[2]); // [4, 6]
```

### 3.9 Set 、Map

ES6 新特性，数据结构都是哈希表 \+ 双向链表，多维护一条双向链表是为了方便遍历和保证 key 顺序。

（1）Set

集合，成员的值是惟一的，有相同的会去重，具有iterator接口 ：

```
const s0 = new Set();
const s1 = new Set([1, 2, 3]);

s0.add(1);
s0.delete(1);
// [] 0
console.log(s0, s0.size);

// true
console.log(s1.has(3));

s1.clear();
// []
console.log(s1);
```

实际应用：

```
// 数组去重
const arr = [1, 1, 2, 2, 3];
const arr0 = [...new Set([...arr])];

// 交集
const arr1 = [1, 1, 2, 2, 3];
const arr2 = [3, 4, 4, 5, 5];
const arr3 = [...new Set([...arr1])].filter((i) => new Set([...arr2]).has(i));

// 并集
let arr4 = [...new Set([...arr1, ...arr2])];

// 差集 (a-b a 有但 b没有)
const arr5 = [...new Set([...arr1])].filter((i) => !new Set([...arr2]).has(i));

// ES16 新特性，纯函数，集合运算 -----------------------------------------------------------
const s16_1 = new Set([1, 3]);
const s16_2 = new Set([3, 5]);

// 交集、并集、差集
console.log(
  s16_1.intersection(s16_2),
  s16_1.union(s16_2),
  s16_1.difference(s16_2)
);
```

（2）Map

字典，键值对的集合，key 是唯一的，相同的 key 会覆盖前面的 key ，有 iterator 接口。

key 可以是任何数据类型，Symbol 类型的 key 也可以遍历出来：

```
const m1 = new Map();
const m2 = new Map([
  ["name", "asdf"],
  ["age", 23],
]);

// obj 、map 互相转换
const m3 = new Map(Object.entries({ a: 1, b: 2 }));
const obj = Object.fromEntries(m3);

m1.set("name", "qwer");
console.log(m1.get("name"), m1.has("name"), m1.size);

m1.delete("name");
m2.clear();
```

实际应用：

```
// 统计出现个数

const arr = ["apple", "apple", "banana"];
const m = new Map();

for (const i of arr) {
  if (m.has(i)) m.set(i, m.get(i) + 1);
  else m.set(i, 1);
}

console.log(m);
```

Map 、Object 区别：

* Map 是哈希表 \+ 双向链表；Object 是隐藏类（类似结构体），当频繁增删会退化为哈希表；Map 在频繁增删、大量数据效率更高更稳定，Object 在少量数据，增删少性能更高

* Map 可以是任何类型 key ，key 顺序为插入顺序；Object 只能是 string 、Symbol ，ES6 后 key 顺序，number 转 struing 后升序，其他按照插入顺序

* Map 有迭代器对象；Object 没有，只能用 Object\.keys 等方法

* Map 有 size 属性可以直接获取大小；Object 还需要 keys 获取 length

* Map 需要自己实现 JSON 序列化；Object 则不用

（3）WeakSet 、WeakMap

都是弱引用（WeakMap 弱引用的是 key），若资源不需要再使用，WeakSet 、WeakMap 就不再引用它们：

* 数据结构只有哈希表，不维护双向链表

* WeakSet 的成员必须是引用类型（ES14 后也可以是 Symbol）；WeakMap 的 key 必须是引用类型（ES14 后也可以是 Symbol） ，但 value 可以是任何类型

* 由于弱引用的不确定性，WeakSet 、WeakMap 就没有 size 、clear ，也无法便利，因此也没有 iterator 接口

```
// 大部分情况都是强引用，Set 、Map 也是
let obj1 = {};
let obj2 = obj1;

// 不会回收
obj1 = null;

// --------------------------------------------------------------------------------------------
const obj = {
  a: {},
  b: {},
};

const s = new Set([obj.a]);
const m = new Map([[obj.a, 1]]);

// 成员只能是引用类型、Symbol
const ws = new WeakSet([obj.b]);

// key 只能是引用类型、Symbol ；value 可以是任何类型
const wm = new WeakMap([[obj.b, 1]]);

// Set 、Map 是强引用，引用不会被垃圾回收
delete obj.a;
console.log(s, m);

// WeakSet 、WeakMap 是若引用，会被垃圾回收
// 垃圾回收是优先级比较低的县城，所以此时可能还未被回收，但最终都会回收
delete obj.b;
console.log(ws, wm, "\n");

// 都是 undefined
console.log(ws.size, wm.size, ws.clear, wm.clear);
console.log(ws.forEach, wm.forEach);
```

强引用：

ES12 新特性，WeakRef ，获得一个弱引用：

```
const obj = { a: 1 };
const wr = new WeakRef(obj);

// { a: 1 } ，若 obj 被垃圾回收了，则是 undefined
console.log(wr.deref());
```

（4）垃圾回收

为了防止内存泄漏，浏览器的垃圾回收器会对没有使用或不再使用的资源自动地进行回收来释放内存，遵循以下基本规则：

- 全局作用域的资源是否回收不确定，因为垃圾回收器难以判断开发者是否还需要这个资源，可能直到程序结束才回收。所以可以手动释放：
  
  ```
  // 占内存存放 obj 的地址，堆内存存放 a 的值和 o 的地址，b 的值
  let obj = { a: 1, o: { b: 2 } };
  
  // 手动释放，若其他地方都没有再强引用这个对象，就可以回收了
  // obj.o = null;
  // delete obj.o;
  
  // 直接释放 obj
  obj = null;
  ```

- 函数、块级作用域执行完，就会释放内部资源

- 闭包资源直到闭包的函数被回收才会回收

### 3.10 二进制处理、其他内置对象

（1）二进制处理

ArrayBuffer 可以创建一个原始二进制缓冲区，方便读写二进制；

```
// 创建一个 2 Byte 的二进制缓冲区，即 16 bit
const buffer = new ArrayBuffer(2);

// 2
console.log(buffer.byteLength);

// 用 16 进制保存二进制数据，输出 00 00 ，不区分大小端，只有解析时才区分
console.log(buffer, "\n");

// 读写 buffer -----------------------------------------------------------------------------
// 读写二进制需要 view ，以无符号 16 bit 整数为例 ；it 要 <= buffer 的 bit
const view = new Uint8Array(buffer);

// [0, 0] ，view.length = buffer.byteLength / view 构造函数 Byte ，如 UInt8Array 就是 1 Byte
console.log(view);

// 十进制写入对应的 Byte
view[1] = 255;

// 二进制写入对应的 Byre
view.set([0x00, 0xff]);

// [0, 255] 00ff
console.log(view, buffer, "\n");

// 解析 buffer --------------------------------------------------------------------------------
// 用 DateView 解析 buffer 转为十进制，大端、小端都可以
const dataView = new DataView(buffer);

/**args
 * 0：默认 0 ，表示跳过几个 Byre 后开始解析，注意跳过后剩余 Byre 要 >= dataView 的 Byre
 * 1：false 大端，true 小端，默认 false ，大端低位在右边
 */
// 255 65280
console.log(dataView.getUint16(), dataView.getUint16(0, true), "\n");

/**ES15 新特性，transfer ，更改 Byte 并产生新 buffer ，原 buffer 清空 --------
 * 扩容：往右填充 0
 * 缩小：从右边开始阶段
 */
// 00ff
console.log(buffer);

// 0 00ff0000
const newBuffer1 = buffer.transfer(4);
console.log(buffer.byteLength, newBuffer1);

// 0 00ff
const newBuffer2 = newBuffer1.transfer(2);
console.log(newBuffer1.byteLength, newBuffer2);
```

Blob 。二进制块，用于在内存中创建一个原始数据的文件，通常会配合 Object URL 或 Data URL ：

```
<!DOCTYPE html>
<html lang="en">
  <body>
    localhost:3000
  </body>

  <script>
    // 在内存中创建一个 text 文件原始数据的二进制块
    const blob = new Blob(["Hello, world!"], { type: "text/plain" });

    // Byte 大小、文件类型
    console.log(blob.size);
    console.log(blob.type);

    // 读取文件内容
    const reader = new FileReader();
    reader.onload = function (e) {
      console.log(e.target.result);
    };
    reader.readAsText(blob);

    // 用 blob 或 file 创建 URL ，可以在浏览器访问，标签链接，也可以用于下载，Web Worker 等 ----------------------------------
    /**Object URL
     * 内存中动态生成一个信息较少的 url ，适合大文件
     * url 在刷新、关闭页面后清除，也可以手动清除；也因为 url 是动态生成的，html 、css 不能写死，也难以在其他页面使用
     * 不需要解析，直接使用，性能高
     */
    const url = URL.createObjectURL(blob);
    console.log(url);
    // 不需要时释放
    // URL.revokeObjectURL(url);

    /**Data URL
     * 直接把文件内容编码为 base64 ，且作为 url ，因此只适合小文件
     * 文件内容和类型都相同 base64 就相同，Data URL 也就相同，也因此内存中不需要保存 url ，html 、css 可以写死，其他页面也可以使用
     * 浏览器解析 base64 需要一定性能消耗
     */
    function createDataURL(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          resolve(reader.result);
        };

        reader.onerror = () => {
          reject(new Error("读取 Blob 失败"));
        };

        reader.readAsDataURL(blob);
      });
    }

    createDataURL(blob).then((dataUrl) => {
      console.log(dataUrl);
    });
  </script>
</html>
```

（2）其他内置对象

Math ，只是对象，不是构造函数：

```
// 圆周率 正无穷 负无穷
console.log(Math.PI, Math.max(), Math.min());

// 参数会隐式转为 number ----------------------------------------------------------
// 2 1
console.log(Math.max(1, 2), Math.min(1, 2));

// 绝对值 下取整 上取整 四舍五入
console.log(Math.abs(-3), Math.floor(3.1), Math.ceil(3.9), Math.round(3.5));

// 0 ~ 1 的随机数
console.log(Math.random());

// min ~ max 的随机整数
function myRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
console.log(myRandom(10, 50));

// ES6 ---------------------------------------------------------------------------------
// 去掉小数部分
console.log(Math.trunc(3.14));

// 正数/负数/0返回 1/-1/0
console.log(Math.sign(123));
```

Date ，构造函数：

```
var date = new Date();

// 年 月 日 星期 时 分 秒
console.log(
  date.getFullYear(),
  date.getMonth() + 1,
  date.getDate(),
  date.getDay() || 7,
  date.getHours(),
  date.getMinutes(),
  date.getSeconds()
);

// 获取时间戳（1970.1.1 到现在的 ms）
console.log(date.getTime(), date.valueOf());

// HTML5 新增获取时间戳的方式
console.log(Date.now());
```

```
/**时间戳格式化
 * 时间戳：从 1970 年 1 月 1 日 00:00:00 UTC 开始，氛围两种： 
   - 精确到 s ：目前 13 位，最后 3 位为 0
   - 精确到 ms ：目前 13 位
*/
function formatDate(
  datetime: Date | string | number,
  fmt: string = "yyyy-MM-dd"
) {
  const date = new Date(
    String(datetime).length === 10 ? Number(datetime) * 1000 : Number(datetime)
  );

  const o: any = {
    "M+": date.getMonth() + 1,
    "d+": date.getDate(),
    "h+": date.getHours(),
    "m+": date.getMinutes(),
    "s+": date.getSeconds(),
  };

  if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, date.getFullYear() + "");

  for (const i in o) {
    const str = o[i] + "";

    if (new RegExp(`(0${i})`).test(fmt) && str.length >= 2) {
      fmt = fmt.replace(RegExp.$1, str);
    } else if (new RegExp(`(${i})`).test(fmt)) {
      fmt = fmt.replace(RegExp.$1, str);
    }
  }
  return fmt;
}

const time = Date.now();
console.log(formatDate(time));
```

## 4 异步编程

ES5 中异步使用回调函数，如果嵌套很多，可读性就很差，称为毁掉地狱：

```
setTimeout(() => {
  console.log(1);

  setTimeout(() => {
    console.log(2);

    setTimeout(() => {
      console.log(3);
    }, 1000);
  }, 1000);
}, 1000);
```

ES6 提供了生成器、Promise、async/await ，使异步代码更清晰。

### 4.1 生成器

（1）基本

将函数氛围多个代码块，手动决定是否执行：

```
// 定义
function* func1() {}
function*func2() {}
function *fun3() {}

// GeneratorFunction
console.log(func1[Symbol.toStringTag]);
console.log(Object.prototype.toString.call(func1), "\n");

// 用 yield 分割代码块
function* func() {
  console.log(0);

  yield "block 1";
  console.log(1);

  // 接收 next 传入的参数
  const x = yield "block 2";
  console.log(x);
}

// 调用生成器会得到一个迭代器对象
const ite = func();

// 每次 next 会执行当前代码块，并把指针指向下一个代码块
// 0 1 2
const block1 = ite.next();
const block2 = ite.next();
const end = ite.next(2);

// { value: 'block 1', done: false }
// { value: 'block 2', done: false }
// { value: undefined, done: true }
console.log(block1, block2, end, "\n");

// 不再输出
const endend = ite.next();

// for...of
const it = func();
// 0 "block1" 1 "block2" undefined
for (const i of it) console.log(i);
```

（2）异步

只使用生成器：

```
// 回调地狱 ---------------------------------------------------------------------------------
setTimeout(() => {
  console.log(1);

  setTimeout(() => {
    console.log(2);

    setTimeout(() => {
      console.log(3);
    }, 1000);
  }, 1000);
}, 1000);

// 改写成生成器 ----------------------------------------------------------------------
function* func() {
  yield (step) => {
    setTimeout(() => {
      console.log(1);
      step();
    }, 1000);
  };

  yield (step) => {
    setTimeout(() => {
      console.log(2);
      step();
    }, 1000);
  };

  yield (step) => {
    setTimeout(() => {
      console.log(3);
      step();
    }, 1000);
  };
}

function run(genFunc) {
  const gen = genFunc();

  (function step() {
    const result = gen.next();
    if (!result.done) result.value(step);
  })();
}

run(func);
```

也可以结合 Promise ：

```
function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function* func() {
  yield wait(1000);
  console.log(1);

  yield wait(1000);
  console.log(2);

  yield wait(1000);
  console.log(3);
}

function run(genFunc) {
  const gen = genFunc();

  function step() {
    const result = gen.next();
    if (!result.done) result.value.then(step);
  }

  step();
}

run(func);
```

### 4.2 Promise

（1）基本使用

Promise 有 3 种状态：

- Pending：待定，初始状态，未完成也未拒绝，then、catch 都不会执行

- Fullfilled：已完成，resolve() 实现，后可以执行 then

- Rejected：已拒绝，reject() 实现，后可以执行 catch

状态只能从 Pending 改变到 Fillfilled 或 Rejected ，且只能改变一次。

```
const flag = true;

/* 格式：
 * new Promise((resolve, reject) => {}).then(res => {}).catch(err => {})
 * new Promise((resolve, reject) => {}).then(res => {}, err => {})
 * ES9 新特性，可以再加一个 finally(() => {}) ，除了 pedding 无论成功失败都会在 then 、catch 后面回调；
   但 then 还是最多只能传两个参数
 */
new Promise((resolve, reject) => {
  setTimeout(() => {
    /* resolve, reject
     * resolve: 表示成功，状态变成 fullfilled ，若 then 已注册则把 then 的回调放到微任务，没有则等到 then 注册了再放到微任务
     * reject： 表示失败，状态变成 rejected ，其他同上，只是变成 catch
     * 若 resolve、reject 都没有，则状态为 Pending， thern、catch 都不执行
     */
    if (flag) resolve("this is res");
    else reject("err");

    // resolve ，reject 后面的代码也会执行，而不是直接截断
    console.log("run");
  }, 1000);
})
  .then((res) => {
    console.log(111, res);
  })
  .catch((str) => {
    console.log(str);
  })
  .finally(() => {
    console.log("this is finally");
  });

// ES15 新特性，创建 Promise 的同时获取 resolve 、reject ，方便外部使用
const { promise, resolve, reject } = Promise.withResolvers(
  (resolve, reject) => {}
);

// 若 resolve 时还没有注册 then ，则只有到了 then 才会放到微任务 ---------------------------------
// 2 1 ，第一个 resolve 时还没有 then 所以无法放到微任务
new Promise((resolve) => {
  resolve(1);

  new Promise((resolve) => {
    resolve(2);
  }).then((res) => console.log(res));
}).then((res) => console.log(res, "\n"));

// 1 2 ，第一个 resolve 时，then 已经有了，直接放到微任务
new Promise((resolve) => {
  setTimeout(() => {
    resolve(1);

    new Promise((resolve) => {
      resolve(2);
    }).then((res) => console.log(res, "\n"));
  });
}).then((res) => console.log(res));
```

then ，catch 、finally 返回 Promise ，此 Promise 的状态由 then 、catch 返回值决定，

* 正常 return 则 fullfilled ，throw 则 rejected 

* 若 return 的又是一个 Promise ，则需要状态吸收，生成一个微任务，内部调用 then 让状态保持一致。

* finally 特殊，正常 return 或 return 非 rejected 的 Promise ，就穿透前一个 Promise 的值；若 finally 回调异常或 return rejected 的 Promise ，finally 就是 rejected

可以借助 Promise 把任务放到微队列：

```
Promise.resolve().then(() => console.log(1));
Promise.reject().catch(() => console.log(2));

// 传参
const add = (a, b) => console.log(a + b);
Promise.resolve().then(() => add(1, 2));
```

ES16 新特性，Promise\.try ，更方便处理同步 err ：

```
function run(syncErr, asyncErr) {
  if (syncErr) throw "同步 err";
  else {
    if (asyncErr) return Promise.reject("异步 err");
    else return Promise.resolve();
  }
}

// 同步 err ，传统方式比较繁琐
try {
  run(true, true).then(
    () => console.log("ok"),
    (err) => console.log(err)
  );
} catch (err) {
  console.log(err);
}

// 同步 err ，使用 Promise.try ，同步 err 会自动转为 Promise.reject ，用 cath 捕获
// async function 也可以
Promise.try(run, true, true).then(
  () => console.log("ok"),
  (err) => console.log(err)
);

// try 的回调是同步执行的，返回的 Promise 状态情况和 then 一样
Promise.try(() => {
  console.log("sync");

  return 123;
  // throw "err";
}).then(
  (res) => console.log(res),
  (err) => console.log(err)
);
```

（2）async 、await

ES8 新特性，简化 Promise ，以类似同步代码的方式编写异步代码：

```
const testP = new Promise((resolve, reject) => {
  resolve(1);
  // reject(2);
  // resolve({ data: 123 });
});

// async 函数返回一个 Promise ，状态由返回值决定，规则和 then 返回值一样 ---------
async function func1() {
  // console.log(0);

  return 1;
  // throw 2;
  // return testP;
}

// 等价于
function func2() {
  return new Promise((resolve, reject) => {
    // console.log(0);

    resolve(1);
    // reject(2);
    // Promise.resolve().then(() => testP.then(resolve, reject));
  });
}

func1().then(
  (res) => console.log(res),
  (err) => console.log(err)
);

// await 只能用在 async 函数中，用于等待一个 Promise 完成 ----------------------------------------
async function func3() {
  // console.log(0);

  let result;
  try {
    result = await testP;

    // 若 await value ，value 不是一个 Promise ，则会转化为 Promise.resolve(value)
    // result = await 3;

    // await 的优先级闭 . [] () 等低
    // result = (await testP).data;
  } catch (err) {
    result = err;
  } finally {
    console.log("finally", result);
  }

  // 下面都是 then 、catch 中的代码，多个 wait 则相当于嵌套 then 、catch
  console.log("ok");
  return result;
  // throw result;
}

// 等价于
function func4() {
  return new Promise((resolve, reject) => {
    // console.log(0);

    let result;
    testP.then(
      (res) => {
        result = res;
        resolve(result);

        // 不是放在 .finally
        console.log("finally", result);
        console.log("ok");
      },
      (err) => {
        result = err;
        reject(err);

        // 不是放在 .finally
        console.log("finally", result);
        console.log("ok");
      }
    );
  });
}

func3().then(
  (res) => console.log(res),
  (err) => console.log(err)
);
```

表达式中不要混合同步代码和异步代码，会出问题：

```
let sum1 = 0;
let sum2 = 0;

async function getData(data, duration) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(data), duration);
  });
}

async function add1(data, duration) {
  sum1 = sum1 + (await getData(data, duration));
  console.log(sum1);
}

// 2 3 ，同步异步混合一起运算，两次分别是 0+2 0+3 ，导致结果出错
add1(2, 1000);
add1(3, 2000);

// 正确做法，同步异步分开
async function add2(data, duration) {
  const n = await getData(data, duration);
  sum2 += n;
  console.log(sum2);
}

// 2 5 ，0+2 和 2+3
add2(2, 3000);
add2(3, 4000);
```

ES9 新特性，异步迭代器 for await of ：

```
const p = new Promise((resolve) => resolve(0));

// fpr 结合异步 --------------------------------------------------------------------
// // 1 2 "sync" 0 0 ，其中 1 2 "sync" 是同步任务
// for (const i of [1, 2]) {
//   console.log(i);
//   p.then((res) => console.log(res));
// }
// console.log("sync");

// // "start" 1 "sync" 0 2 0 "end" ，其中 "start" 1 "sync" 是同步任务
// (async function () {
//   console.log("start");

//   for (const i of [1, 2]) {
//     console.log(i);

//     const res = await p;
//     console.log(res);
//   }

//   console.log("end");
// })();
// console.log("sync");

// 异步迭代器 for await of ------------------------------------------------------------------------
(async function () {
  console.log("start");

  const arr = [p, p];
  for await (const res of arr) console.log(res);

  // 等价于
  // for (const i of arr) {
  //   const res = await i;
  //   console.log(res);
  // }

  // 所以若不是 Promise 会用 Promise.resolve 转为 Promise
  // for await (const res of [1, 2]) console.log(res);

  console.log("end");
})();
```

（3）实现 Promise

通过自己实现一个 Promise ，可以完整理解 Promise 的执行过程，其中特别需要注意的是 then 、catch 返回 Promise 的情况、 static resolve 的情况和 \.finally ：

```
/**与原版 Promise 不同的地方
 * 原版 rejected 若没有 catch 会抛出异常，这里没有处理，比较难实现
 */

const MY_PROMISE_STATU = {
  PEDDING: "pedding",
  FULLFILLED: "fullfilled",
  REJECTED: "rejected",
};

class MyPromise {
  #statu = MY_PROMISE_STATU.PEDDING;
  #result = undefined;
  #handler = [];

  constructor(executor) {
    try {
      executor(this.#resolve, this.#reject);
    } catch (err) {
      this.#reject(err);
    }
  }

  #resolve = (data) => {
    this.#changeStatu(MY_PROMISE_STATU.FULLFILLED, data);
  };

  #reject = (reson) => {
    this.#changeStatu(MY_PROMISE_STATU.REJECTED, reson);
  };

  // 修改状态，只能修改一次
  #changeStatu(statu, result) {
    if (this.#statu !== MY_PROMISE_STATU.PEDDING) return;

    if (this.#isPromiseLike(result)) {
      this.#statuAssimilater(result, this.#resolve, this.#reject);
    } else {
      this.#statu = statu;
      this.#result = result;
      this.#run();
    }
  }

  // 最核心的 then 方法
  then(onFullfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      /**
       * then 的时候肯呢还没有 resolve ，reject ，先记录起来
       * handler 是一个数组，因为 Promise 对象肯呢个会调用多次 then
       * 保存 resolve ，reject 是为了控制 then 链式调用返回的 Promise 的状态
       */
      this.#handler.push({
        onFullfilled,
        onRejected,
        resolve,
        reject,
      });

      this.#run();
    });
  }

  // Promise 规范规定只要有一个符合规范的 then 方法，就是一个 Promise ，也叫 thenable
  // 只要都是 thenable ，就具有互操作性，如都可以使用 await 等
  #isPromiseLike(value) {
    if (
      typeof value !== null &&
      (typeof value === "object" || typeof value === "function")
    ) {
      return typeof value.then === "function";
    }
  }

  // 放到微队列
  #runMicroTask(func) {
    if (globalThis.queueMicrotask) queueMicrotask(func);
    else if (globalThis.MutationObserver) {
      const ob = new MutationObserver(func);
      const textNode = document.createTextNode("1");
      ob.observe(textNode, { characterData: true });
      textNode.data = "2";
    } else setTimeout(func);
  }

  // 状态吸收，当 then 、catch 、async 函数返回一个 Promise ，或 resolve 、reject 接收一个 Promise ，就需要状态吸收
  #statuAssimilater(myPromise, resolve, reject) {
    if (!this.#isPromiseLike(myPromise)) return;
    this.#runMicroTask(() => myPromise.then(resolve, reject));
  }

  // 处理 then 的回调
  #runOne(callback, resolve, reject) {
    if (this.#statu === MY_PROMISE_STATU.PEDDING) return;

    // 若没有传入回调，则 return 的 Promise 状态要和之前的 Promise 保持一致，达成穿透
    this.#runMicroTask(() => {
      if (typeof callback !== "function") {
        if (this.#statu === MY_PROMISE_STATU.FULLFILLED) resolve(this.#result);
        else reject(this.#result);
      } else {
        // 正常 return 则 resolve ，throw 则 reject
        // 若 return Promise ，则这个 Promise 状态要和 then 的 Promise 保持一致
        try {
          const data = callback(this.#result);

          if (this.#isPromiseLike(data)) {
            this.#statuAssimilater(data, resolve, reject);
          } else resolve(data);
        } catch (err) {
          reject(err);
        }
      }
    });
  }

  // 处理 then 的回调
  #run() {
    // 只有 fullfilled 、rejected 才 run

    if (this.#statu === MY_PROMISE_STATU.PEDDING) return;

    while (this.#handler.length !== 0) {
      const { onFullfilled, onRejected, resolve, reject } =
        this.#handler.shift();

      this.#runOne(
        this.#statu === MY_PROMISE_STATU.FULLFILLED ? onFullfilled : onRejected,
        resolve,
        reject
      );
    }
  }

  // Promise 规范之外的方法 ----------------------------------------------------------------
  catch(onRejected) {
    return this.then(null, onRejected);
  }

  /**finally
   * onFinally 不接收参数，正常情况下状态要和之前的 Promise 保持一致
   * 若 finally 正常 return 或 return 一个非 rejected 的 Promise ，就穿透前一个 Promise 的值
   * 若 finally 回调异常，或 return 一个 rejected 的 Promise ，那 finally 就是 rejected
   */
  finally(onFinally) {
    return this.then(
      (data) => {
        // 用 Promise.resolve 就能处理 finally 的所有情况
        return MyPromise.resolve(onFinally()).then(() => data);
      },
      (err) => {
        return MyPromise.resolve(onFinally()).then(() => {
          throw err;
        });
      }
    );
  }

  static resolve(value) {
    // 如果传入的是自己实现的 Promise ，就直接 return
    if (value instanceof MyPromise) return value;

    let tempResolve;
    let tempReject;
    const temp = new MyPromise((resolve, reject) => {
      tempResolve = resolve;
      tempReject = reject;
    });

    // 如果是其他人实现的 Promise，返回自己的 Promise 且状态和 value 保持一致
    if (temp.#isPromiseLike(value)) value.then(tempReject, tempReject);
    // 其他情况
    else tempResolve(value);

    return temp;
  }

  static reject(value) {
    // 不管 value 是什么，都返回一个新的 Promise
    return new MyPromise((resolve, reject) => {
      reject(value);
    });
  }
}
```

测试：

```
// 测试 1 ，调用多次 then -----------------------------------------------------------
const p1 = new MyPromise((resolve, reject) => {
  // 状态只能改变一次
  // resolve(1);
  // reject(2);
  // throw 3
  // 和原版 Promise 一样无法捕获异步异常
  // setTimeout(() => {
  //   throw 4;
  // });
});

p1.then(
  (res) => console.log(res),
  (err) => console.log(err)
);

p1.then(
  (res) => console.log(res),

  (err) => console.log(err)
);

// 测试 2 ，Promise 静态方法 ------------------------------------------------------------
const temp = new MyPromise(() => {});

// true
// console.log(MyPromise.resolve(temp) === temp);

// 其他 thenable
MyPromise.resolve(
  new Promise((resolve, reject) => {
    // resolve("resolve");
    // reject("reject");
  })
).then(
  (res) => console.log(res),
  (err) => console.log(err)
);

// 其他情况
// MyPromise.resolve(123).then((res) => console.log(res === 123));
// MyPromise.reject(123).catch((res) => console.log(res === 123));

// 测试 3 ，resolve 、then 先后顺序不同影响执行顺序 -----------------------------------------------
// "b" "a" ，resolve("b") -> resolve("a") -> then("a") -> then("b")
new MyPromise((resolve, reject) => {
  // resolve("a");
  // reject("a");

  new MyPromise((resolve, reject) => {
    // resolve("b");
    // reject("b");
  }).then(
    (res) => console.log(res),
    (err) => console.log(err)
  );
}).then(
  (res) => console.log(res),
  (err) => console.log(err)
);

// "a" "b" ，then("a") -> resolve("a") -> resolve("b") -> then("b")
new MyPromise((resolve, reject) => {
  setTimeout(() => {
    // resolve("a");
    // reject("a");

    new MyPromise((resolve, reject) => {
      // resolve("b");
      // reject("b");
    }).then(
      (res) => console.log(res),
      (err) => console.log(err)
    );
  });
}).then(
  (res) => console.log(res),
  (err) => console.log(err)
);

// 测试 4 ，穿透 ----------------------------------------------------------------------------
new MyPromise((resolve, reject) => {
  // resolve(1);
  // reject(2);
})
  .then()
  .then(
    (res) => console.log(res),
    (err) => console.log(err)
  );

// 2
new MyPromise((resolve, reject) => {
  // reject(2);
})
  .then(
    () => {},
    (err) => console.log(err)
  )

  .catch((err) => console.log(err + 1));

// 测试 5 ，finally 返回值 ---------------------------------------------------------------
const pf = new MyPromise((resolve, reject) => {
  resolve("ok");
  // reject("err");
});

new MyPromise((resolve) => {
  // resolve(0);
})
  .then((res) => console.log(res))
  .finally(() => {
    return pf;
  })
  .then(
    (res) => console.log(res),
    (err) => console.log(err)
  );

// 测试 6 ，结合 finally 的穿透 ------------------------------------------------------------
// 1 2 4 3
const f1 = new MyPromise((resolve, reject) => {
  // resolve();
})
  .then(() => console.log(1))
  .catch(() => console.log(1))
  .catch(() => console.log(1))
  .catch(() => console.log(1))
  .then(() => console.log(3));

const f2 = new MyPromise((resolve, reject) => {
  // resolve();
})
  .finally(() => console.log(2))
  .then(() => console.log(4));

// 测试 7 ，状态吸收 ----------------------------------------------------------------------
// 1 2 3 4
const pa = new MyPromise((resolve) => {
  resolve(3);
});

const pb = new MyPromise((resolve) => {
  // resolve(pa);
}).then((res) => console.log(res));

new MyPromise((resolve) => {
  // resolve();
})
  .then(() => console.log(1))
  .then(() => console.log(2))
  .then(() => console.log(4));

// // 0 1 2 3 4 5
// MyPromise.resolve()
//   .then(() => {
//     console.log(0);
//     return MyPromise.resolve(4);
//   })
//   .then((res) => console.log(res));

// MyPromise.resolve()
//   .then(() => {
//     console.log(1);
//   })
//   .then(() => {
//     console.log(2);
//   })
//   .then(() => {
//     console.log(3);
//   })
//   .then(() => {
//     console.log(5);
//   });
```

（4）处理多个 Promise

这些函数接收一个可迭代对象，返回 Promise，若成员不是 Promise 则会转为 Promise 。

当所有 Promise resolve 或 reject 后才决定返回的这个 Promise 的状态。

```
const p1 = new Promise((resolve) => {
  resolve(1);
});

const p2 = new Promise((resolve) => {
  resolve(2);
});

const p3 = new Promise((resolve, reject) => {
  reject(3);
});

/**all -----------------------------------------------------------------------------------------
 * 所有 Promise fullfilled 时才 fullfilled ，总时间为最晚完成的 Promise ，或最早 rejected 的时间
 * res 为数组，err 为单个值
 */
// [1, 2] ，fillfilled
Promise.all([p1, p2]).then(
  (res) => console.log(res),
  (err) => console.log(err)
);

// 3 ，rejected
Promise.all([p1, p2, p3]).then(
  (res) => console.log(res),
  (err) => console.log(err, "\n")
);

/**allSettle ，ES11 新特性 ------------------------------------------------------------------------
 * 所有 Promise 完成后，不管成功失败，返回的 Promise 状态都是 fullfilled
 * res 为数组，保存每个 Promise 成功失败的信息
 */
// [ { statu: "fullfilled", value: 1 }, ... ]
Promise.allSettled([p1, p2, p3]).then((res) => console.log(res, "\n"));

/**any ，ES12 新特性 -----------------------------------------------------------------------------
 * 所有 Promise rejected 时才 rejected ，总时间为最晚完成的 Promise ，或最早 fullfilled 的时间
 * 只要有 Promise fullfilled 就直接 fullfilled ，类似竞速
 * res 为单个值；err 为对象，有个 key 保存失败值的数组
 */
// 1 ，fullfilled
Promise.any([p1, p2, p3]).then(
  (res) => console.log(res),
  (err) => console.log(err)
);

/** 这些 key 都是不可枚举的
 * {
     stack: "AggregateError: All promises were rejected"
     message: "All promises were rejected"
     errors:  [ 3 ]
   }
 */
Promise.any([p3]).then(
  (res) => console.log(res),
  (err) => {
    for (const key of Reflect.ownKeys(err)) console.log(key, ": ", err[key]);
    console.log("\n");
  }
);
```

实现 all（any 、allSettle 都差不多）：

```
// 接收一个可迭代对象
function myAll<T>(promiseList: Iterable<any>) {
  return new Promise((resolve, reject) => {
    const result: any[] = [];

    let cnt = 0;
    for (const promise of promiseList) {
      const index = cnt++;

      // 若成员不是 Promise 就转为 Promise
      Promise.resolve(promise).then((res) => {
        result[index] = res;
        if (--cnt <= 0) resolve(result);
      }, reject);
    }

    if (cnt <= 0) resolve(result);
  });
}
```

# 四、Web API

## 1 DOM

DOM ，文档对象模型，使 JS 可以操作 HTML。

DOM 树：整个html页面是一个 DOM 树，根元素是 \<html\>，叫文档 document ，每一个html 标签，叫元素 element ，所有页面内容，包括每个标签/属性/文本/注释等，叫节点 node 。

### 1.1 基本操作

（1）获取元素、节点操作

```
<!DOCTYPE html>
<html lang="en">
  <body>
    <ul id="box">
      <li class="item"></li>
      <li class="item"></li>
    </ul>
  </body>

  <script>
    // 获取元素 --------------------------------------------------------------------------
    // 单个 ul 元素
    const box1 = document.getElementById("box");

    // 伪数组 HTMLCollection
    const itemArr1 = document.getElementsByClassName("item");
    const itemArr2 = document.getElementsByTagName("li");

    /**html 和 body 
     * 若页面没有 <html> 会自动补上，也会有 documentElement
     * 若页面没有任何一个元素标签 （style 、script 、head 等不是元素标签，div 等才是），
       则 document.body 为 null ，但只要有任何一个元素标签则都会补上 <body>
     */
    const html = document.documentElement;
    const body = document.body;

    // 获取父子 node 、元素 ----------------------------------------------------------------
    // 获取子 node ，node 即元素、属性、文本等，nodeType 为节点类型
    const firstNode = box1.firstChild;
    const lastNode = box1.lastChild;
    console.log(firstNode, firstNode.nodeType);

    // 获取所有子 node ，结果为伪数组 NodeList
    const ietmNodes = box1.childNodes;

    // 获取子元素
    const firstElement = box1.firstElementChild;
    const lastElement = box1.lastElementChild;
    console.log(firstElement, firstElement.nodeType);

    // 获取所有子元素，结果为伪数组 HTMLCollection
    const itemElements = box1.children;

    // 父 node 、父元素
    const parentNode = itemArr1[0].parentNode;
    const parentElement = itemArr1[0].parentElement;

    // true true true ，判断是否为所包含的节点，如果就是本身也是 true
    console.log(
      box1.contains(box1),
      box1.contains(firstNode),
      box1.contains(firstElement)
    );

    // 获取兄弟 node 、元素 ----------------------------------------------------------------
    // 下一个兄弟 node 、元素
    const nextNode = itemArr1[0].nextSibling;
    const nextElement = itemArr1[0].nextElementSibling;

    // 上一个兄弟 node 、元素
    const preNode = itemArr1[1].previousSibling;
    const preElement = itemArr1[1].previousElementSibling;

    // 创建、添加、删除元素 ---------------------------------------------------------------
    // 添加、插入元素时，若待添加、待插入的是已存在的元素，则会移动，添加、插入到其他容器也是移动

    const newItem1 = document.createElement("li");
    const newItem2 = document.createElement("li");
    newItem1.innerText = 123;
    newItem2.innerText = 456;

    // push 到最后面
    box1.appendChild(newItem2);

    // 插入到某元素前面
    // box1.insertBefore(newItem1, itemArr1[0]);

    // 删除元素
    // box1.removeChild(itemArr1[1]);

    // 拷贝所有 node
    const newBox1 = box1.cloneNode(true);
    // 只拷贝元素本身，不拷贝子元素、文本等信息
    const newBox2 = box1.cloneNode();

    // HTML5 新特性 ，获取元素 ------------------------------------------------------------
    // 获取第一个符合条件的元素，可以传入任何 CSS 选择器，如属性选择器 ".box[data-item-id]"
    const box2 = document.querySelector("#box");

    // 伪数组 NodeList
    const itemArr3 = document.querySelectorAll(".item");
    const itemArr4 = document.querySelectorAll("li");

    // HTMLCollection 和 NodeList 区别 ---------------------------------------------------
    // HTMLCollection 的数据和页面实施绑定，如下会死循环
    // for (const ietm of itemArr2) {
    //   const newItem = document.createElement("li");
    //   box1.appendChild(newItem);
    // }

    // NodeList 则不绑定，就不会死循环
    for (const item of itemArr4) {
      const newItem = document.createElement("li");
      box2.appendChild(newItem);
    }

    // 但是，有时候获得的 NodeList 也是动态的，如 childNodes
    // 解决方法是用 ... 或者 Array.from 生成一个新数组再使用
    const itemArr5 = [...box2.childNodes];
  </script>
</html>
```

（2）读写节点值，样式、属性

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      #box2 {
        font-weight: 700;
        background-color: gray;

        /* CSS3 新特性，CSS 变量，也叫 CSS 自定义属性，用 -- 定义 */
        /* 这个变量和 CSS 属性一样会放在 SOM 树中当前选中的元素 */
        /* CSS 变量也有作用域链，当前作用域没有就会往上找 */
        --my-width: 10px;

        /* 使用变量 */
        border: var(--my-font-size) solid #000;

        /* 运算 */
        border: calc(var(--my-font-size) / 2) solid #000;

        /* 若变量不存在，就会使用默认值 */
        border-radius: var(--my-radius, 100px);
      }

      .box::before {
        color: red;
      }

      /* 设置 <html> 的样式 */
      :root {
        --my-font-size: 15px;
        border: 1px solid #000;
      }
    </style>
  </head>

  <body>
    <div id="box1">
      <!-- desc -->
      <span>123</span>
      <span style="display: none">456</span>
      <script>
        let a;
      </script>
    </div>

    <div id="box2" style="font-size: 50px">123</div>

    <input id="inp" type="text" data-inp-id="0" />
  </body>

  <script>
    const box1 = document.querySelector("#box1");
    const box2 = document.querySelector("#box2");
    const inp = document.querySelector("#inp");

    // HTMLDivElement -> HTMLElement -> Element -> Node -> EventTarget -> Object 原型 -> null
    let proto = box1.__proto__;
    while (proto) {
      console.log(proto);
      proto = proto.__proto__;
    }

    // 读写节点值 ----------------------------------------------------------------------
    // 123 ，获取所有非隐藏节点、非注释节点的内容C
    console.log(box1.innerText);
    // undefined ，获取不到注释节点的内容
    console.log(box1.childNodes[1].innerText);

    // 123 456 let a; ，获取包括隐藏节点，不包括注释节点所有子节点内容
    console.log(box1.textContent);
    // desc ，只有当前就是注释节点时，才能获取注释内容
    console.log(box1.childNodes[1].textContent);

    // null
    console.log(box1.nodeValue);
    // desc ，nodeValue 专门用来获取注释节点、文本节点的内容
    console.log(box1.childNodes[1].nodeValue);

    // 整个 HTML 的内容
    console.log(box1.innerHTML);
    // undefined ，如果当前是注释节点就获取不到注释内容，但文本节点可以
    console.log(box1.childNodes[1].innerHTML);

    // 修改注释内容
    box1.childNodes[1].nodeValue = " csed ";

    // 无论哪种方式，修改后都只有修改后内容
    // box1.innerText = 789;
    // box1.textContent = 789;
    // box1.innerHTML = 789;

    // 尽量不要这样修改 HTML 内容，容易被 XSS 攻击
    // box1.innerHTML = "<div>000</div>";

    // 读写样式 ---------------------------------------------------------------------------
    // 获取样式表
    console.log(document.styleSheets);

    /**读写 DOM 树行内样式
     * 单个：dom.style.color
     * 多个：都会覆盖所有行内样式，dom.style.cssText ，后续可以 += 追加属性；setAttribute 后续无法通过 cssText += 追加
     * 增加、删除：dom.style.setProperty() ，dom.style.removeProperty()
     */
    box2.style.fontSize = "100px";
    box2.setAttribute("style", "font-size:100px");
    box2.style.cssText = "font-size: 100px; border: 50px solid #000";
    box2.style.cssText += "text-align: center";
    box2.style.setProperty("height", "1000px");
    box2.style.removeProperty("height");

    /**getComputedStyle() ，window 的 API
     * 获取 SOM 树最终显示在页面的非几何样式，如黑色模式下获取的背景色都是黑色；样式修改后需要重新获取
     * 几何样式至少都需要在布局树后的阶段才能获取正确值；transition 变化后的样式都无法获取
     * 不符合 JS 命名规范的 CSS 属性需要 getPropertyValue() 获取
     */
    console.log(getComputedStyle(box2).fontSize);
    console.log(getComputedStyle(box2).backgroundColor);
    console.log(getComputedStyle(box2).getPropertyValue("--my-width"));
    // 获取伪元素的样式
    console.log(getComputedStyle(box2, "::before").color);

    // 读写 CSS 变量，set 会把 CSS 属性放到 DOM 树中该元素的 style 中，即行内样式
    box2.style.setProperty("--my-color", "black");
    console.log(box2.style.getPropertyValue("--my-color"));

    /**读写 class
     * className 会覆盖所有 class
     * HTML5 新特性 classList ，可以单独读写 class
     */
    box2.className = "cls1 cls2";
    box2.className += "cls3";
    box2.classList.add("cls3");
    box2.classList.remove("cls1");
    console.log(box2.classList);
    // 切换，即存在就删除，不存在就添加
    box2.classList.toggle("cls4");

    /**读写属性 ---------------------------------------------------------------------------
     * 获得的结果都是 string ，不存在则 undefined
     * dom.propName 只能读取原生属性
     * setAttribute() ，removeAttribute() ，getAttribute() 原生属性、自定义属性都可以读写，自定义属性通常在标签中以 data-xxx 命名
     * HTML5 新特性 dataset ，专门用于读写自定义属性，省略 data- ，且会变成小驼峰
     */
    inp.disabled = true;
    inp.value = 123;
    inp.setAttribute("data-inp-name", "name1");
    console.log(inp.getAttribute("data-inp-name"));
    inp.removeAttribute("data-inp-name");
    inp.dataset.inpId = "1";
    console.log(inp.dataset.inpId);
  </script>
</html>
```

（3）读写几何信息

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      * {
        margin: 0;
        padding: 0;
      }

      .container {
        position: relative;
        margin: 50px;
        padding: 50px;
        border: 5px solid #000;
      }

      .box1 {
        margin: 2px;
        padding: 2px;
        width: 100px;
        height: 100px;
        border: 10px solid #000;
        background-color: blue;
      }

      .box2 {
        overflow: scroll;
      }

      .box2 > .item {
        height: 30px;
      }

      .box3 {
        margin-top: 300px;
        transform: scale(2);
      }

      .box4 {
        transition: all 1s;
      }

      .box4-move {
        display: flex;
        border-width: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="box1"></div>
    </div>

    <div class="box1 box2">
      <div class="item">1</div>
      <div class="item">2</div>
      <div class="item">3</div>
      <div class="item">4</div>
      <div class="item">5</div>
    </div>

    <div class="box1 box3"></div>

    <div class="box1 box4"></div>
  </body>

  <script>
    const box1 = document.querySelector(".box1");
    const box2 = document.querySelector(".box2");
    const items = document.querySelectorAll(".item");
    const box3 = document.querySelector(".box3");
    const box4 = document.querySelector(".box4");

    // "" ，可读写，获取行内样式，即 DOM 树 -------------------------------------------------
    console.log(box1.style.width);

    // "100px" ，只读，获取 SOM 树样式 ------------------------------------------------------
    console.log(getComputedStyle(box1).width);

    // 获取布局树样式 ----------------------------------------------------------------------
    /**滚动条
     * 无论什么盒子模型，滚动条都会压缩 content 大小
     * 滚动条大小会随着视口缩放而改变
     */
    // offset ，只读 ------------------------
    // 124 ，content + padding + border + 滚动条
    console.log(box1.offsetWidth);

    // 52 ，margin + 最近一级非 static 祖先 padding ，直到 body 为止，即使 body 是 static 也不会网上找了
    // 若该祖先是 body ，还需要加上 body 的 border
    console.log(box1.offsetLeft);

    // .container ，最近一级非 static 祖先
    console.log(box1.offsetParent);

    // client ，只读 ---------------------------
    // 104 ，content + padding - 注意 content 会被滚动条压缩
    console.log(box1.clientWidth);

    // 10 ，border
    console.log(box1.clientLeft);

    // scroll 。只读 ----------------------------
    // 154 ，滚动总高度 + padding ，即 30*5+2*2 ，此时不计算滚动条大小
    console.log(box2.scrollHeight, box2.clientHeight);

    // 输出一样 ，若内容没有溢出形成滚动，则的 clientWidth 相同，content 被滚动条压缩
    console.log(box2.scrollWidth, box2.clientWidth, box2.clientHeight);

    // 0 随滚动变化，获取滚动元素距滚动开始的偏移
    console.log(box2.scrollTop);
    box2.addEventListener("scroll", function () {
      console.log(box2.scrollTop);
    });

    // 获取最终当前显示的样式，即渲染流程的最终结果，但无法获取 transition 后的样式 ---------------
    // 获取的是当前举行区域，如果后续元素移动了，新位置需要重新获取举行
    const rect = box3.getBoundingClientRect();

    // 248 ，offsetWidth * transform: scale(2)
    // 如果旋转了，则得到的是外接举行的 width
    console.log(rect.width);

    // -60 ，计算 transform 后距 body border 外边缘的偏移，类似于相对于 body 的 offsetLeft ，只是 offset 得不到 transform 后的结果
    console.log(rect.left, box3.offsetLeft);

    // 获取到视口的偏移
    window.addEventListener("scroll", function () {
      // console.log(rect.top - document.documentElement.scrollTop);
    });

    // 获取 transition 后的样式 ---------------------------------------------------------
    box4.addEventListener("click", function (e) {
      e.target.style.backgroundColor = "red";
      e.target.style.transform = "translateX(100px)";
      e.target.classList.add("box4-move");

      // 已经写入的属性和无法 transition 的属性就能马上获取到
      console.log(
        e.target.style.backgroundColor,
        e.target.style.transform,
        getComputedStyle(e.target).display
      );

      // 无法获取 transition 后的样式
      requestAnimationFrame(() => {
        const { backgroundColor: bgc, border: bd } = getComputedStyle(e.target);
        const x = e.target.getBoundingClientRect().left;
        console.log(bgc, bd, x);
      });
    });

    // 正确做法
    box4.addEventListener("transitionend", function (e) {
      const { backgroundColor: bgc, border: bd } = getComputedStyle(e.target);
      const x = e.target.getBoundingClientRect().left;
      console.log(bgc, bd, x);
    });
  </script>
</html>
```

（4）Mutation Observer

用于观察文本节点、属性节点和子元素节点的变化，回调会放到微任务：

```
<!DOCTYPE html>
<html lang="en">
  <body>
    <ul class="list1">
      <li class="list1-item">1</li>
    </ul>

    <ul class="list2"></ul>

    <span class="text">text</span>
  </body>

  <script type="module">
    const list1 = document.querySelector(".list1");
    const list2 = document.querySelector(".list2");
    const textNode = document.querySelector(".text").firstChild;

    // 创建 --------------------------------------------------------------------------
    const ob = new MutationObserver((mutationsList, observer) => {
      for (const mutation of mutationsList) {
        const {
          type,
          target,
          oldValue,
          attributeName,
          addedNodes,
          removedNodes,
        } = mutation;

        switch (type) {
          // 属性节点变化
          case "attributes":
            const newValue = target.getAttribute(attributeName);

            console.log(
              `${target.className} 的属性 "${attributeName}" 从 ${oldValue} 被修改为 ${newValue}`
            );
            break;

          // 子元素节点增减，不含子节点文本属性的变化
          case "childList":
            const type = addedNodes.length ? "添加" : "删除";
            const childNodes = type === "添加" ? addedNodes : removedNodes;

            const childTes = [...childNodes].reduce(
              (pre, item) => pre + "li" + item.textContent + " ",
              ""
            );

            console.log(`${target.className} ${type}了子元素：${childTes}`);
            break;

          // 文本节点变化
          case "characterData":
            const newText = target.textContent;
            console.log(`文本节点从 ${oldValue} 修改为 ${newText}`);
            break;

          default:
            break;
        }
      }
    });

    // 观察配置，attributeFilter 默认值为 undefined 其他都是 false
    const obConfig = {
      // 属性变化，是否携带 oldValue ，观察特定属性
      // 若 attributeOldValue 为 true 且没有设置 attributeFilter 则 attributes 也会默认 true
      // attributes: true,
      attributeOldValue: true,
      attributeFilter: ["data-list-id", "data-item-id"],

      // 子元素增减
      childList: true,

      // 深度观察
      subtree: true,
    };

    // 开始观察，可以调用多次观察多个元素，相同的元素只会回调一次（但是一些不规范的场景会回调多次，如不同 ul 添加了相同的 li）
    ob.observe(list1, obConfig);
    ob.observe(list1, obConfig);
    ob.observe(list2, obConfig);

    // 观察文本节点的变化，注意必须传入一个文本节点
    ob.observe(textNode, {
      // 默认值都是 false ，若 characterDataOldValue 为 true 则 characterData 默认为 true
      // characterData: true,
      characterDataOldValue: true,
    });

    // 停止观察
    // ob.disconnect();

    // 测试 ----------------------------------------------------------------------------
    Promise.resolve().then(() => console.log("start"));

    // 修改属性节点
    // list1.setAttribute("data-list-id", "1");
    // list2.setAttribute("data-list-id", "2");
    // requestAnimationFrame(() => {
    //   list1.setAttribute("data-list-id", "11");
    //   list2.setAttribute("data-list-id", "22");
    // });

    // 深度观察
    // list1.firstElementChild.setAttribute("data-item-id", "1");

    // 增减子元素节点
    // const list1_item = document.createElement("li");
    // const list2_item = document.createElement("li");
    // list1_item.textContent = "2";
    // list2_item.textContent = "1";
    // list1.appendChild(list1_item);
    // list2.appendChild(list2_item);
    // list1.removeChild(list1_item);
    // list2.removeChild(list2_item);
    // // 不要添加相同的元素，会有意外的结果
    // list2.appendChild(list1_item);

    // 修改文本节点
    textNode.data = "asdf";

    Promise.resolve().then(() => console.log("end"));
  </script>
</html>
```

### 1.2 事件

事件三要素：事件源、事件类型、事件函数。事件函数的 this 指向事件源。

（1）绑定

```
<!DOCTYPE html>
<html lang="en">
  <body>
    <ul>
      <li class="item" onclick="func1(event, 1)">标签绑定事件</li>
      <li class="item">onclick</li>
      <li class="item">addEventListener</li>
      <li class="item">同时用 oncli 、addEventListener</li>
      <li class="item">传参</li>
    </ul>
  </body>

  <script>
    const items = document.querySelectorAll(".item");

    /**可以直接在元素标签内绑定，---------------------------------------------------
     * 如果需要事件对象则必须传入 event
     * 其实就是在标签内写一个表达式，如也可以是 cnt++
     */
    function func1(e, num) {
      console.log(e, "click" + num);
    }

    // JS 绑定 -------------------------------------------------------------------------
    items[1].onclick = function (e) {
      console.log(e, "click2");
    };

    // 删除绑定
    // items[1].onclick = null;

    /**addEventListener ，HTML5 新特性 -----------------------------------------------------
     * 第三个参数为 options ，默认都是 false
       - capture ：是否在捕获阶段触发，而不是冒泡阶段
       - once ：只执行一次，执行完自动 remove
       - passive ：是否允许调用 e.preventDefault()
     * 若第三个参数传入 boolean 而不是 options，则是只指定 capture
     */
    items[2].addEventListener("click", function (e) {
      console.log("click3");
    });

    // 可以多次绑定不同的函数引用，执行多次
    items[2].addEventListener("click", function (e) {
      console.log("click3");
    });

    // 如果是相同的函数引用，则只保留一个，但 onclick 不会去掉，所以下面执行两次
    function func() {
      console.log("click4");
    }

    items[3].onclick = func;

    items[3].addEventListener("click", func);
    items[3].addEventListener("click", func);

    // 删除绑定
    // items[3].removeEventListener("click", func);

    // onevent 、addEventListener 传参 -------------------------------------------------
    function argsFunc(e) {
      ((event, a, b) => {
        console.log(a + b, e);
      })(e, 1, 2);
    }

    items[4].onclick = argsFunc;
    items[4].addEventListener("click", argsFunc);

    // 可以 JS 主动触发事件 -----------------------------------
    // 不用传参，会自动带上 event
    // items[1].click();

    // 需要传入 event 并指定事件类型，第二个为可选参数 options ，可以设置是否冒泡等
    // items[1].dispatchEvent(new MouseEvent("click", {}));
  </script>
</html>
```

（2）常见的事件类型

| 鼠标事件        | 描述             |
| ----------- | -------------- |
| click       | 单机             |
| dblclick    | 双击             |
| mousedown   | 按下             |
| mouseup     | 谈起             |
| mounseenter | 鼠标经过，经过子盒子时不触发 |
| mouseleave  | 鼠标离开，离开子盒子不触发  |
| mouseover   | 鼠标经过，经过子盒子时也触发 |
| mouseout    | 鼠标离开，离开子盒子也触发  |
| mousemove   | 鼠标移动           |

| 键盘事件     | 描述                       |
| -------- | ------------------------ |
| keydown  | 按键按下，按键按着不放就一直触发，可识别所有键  |
| keypress | 按键按下，按键按着不放就一直触发，不能识别功能键 |
| keyup    | 按键弹起                     |

注意事项：

* event.keyCode 可获得按键码，up，down 不区分大小写，press 区分。通过event.keyCode 可实现对特定键的监听

| form 事件 | 描述  |
| ------- | --- |
| submit  | 提交  |
| reset   | 重置  |

| input 事件 | 描述                 |
| -------- | ------------------ |
| focus    | 聚焦                 |
| blur     | 失焦                 |
| input    | 每次输入、退格都触发         |
| change   | enter 和失焦触发        |
| invalid  | 非法输入时触发，可自定义非法输出信息 |

注意事项：

* 表单应当都放在 form 中，提交时监听 submit 事件，可以避免很多问题

* 部分类型 input 无法用某些 input 事件

| 移动端触屏事件     | 描述         |
| ----------- | ---------- |
| touchstart  | 手指触屏       |
| touchmove   | 手指移动       |
| touchend    | 手指弹起       |
| touchcancel | 触屏事件被取消时触发 |

其他事件：

```
// 鼠标右键菜单事件，常应用与阻止右键弹出菜单
document.addEventListener("contextmenu", function (e) {
  e.preventDefault();
});

// 选中文本时触发，常应用于阻止选中文本
document.addEventListener("selectstart", function (e) {
  e.preventDefault();
});
```

自定义事件：

Vue 、React 的自定义事件并不是使用这种方法实现的，有自己的机制。

```
<!DOCTYPE html>
<html lang="en">
  <body></body>

  <script>
    // 创建自定义事件
    const myEvent = new CustomEvent("myCustomEvent", {
      // 通信的数据，必须写在 detail
      detail: { a: 1 },
    });

    // 监听该事件
    document.addEventListener("myCustomEvent", function (e) {
      console.log(e.detail.a);
    });

    // 触发该事件
    document.dispatchEvent(myEvent);

    // 如果需要添加属性方法，则需要 继承 ---------------------------------------------------
    class MyCustomEvent extends CustomEvent {
      constructor(type, options) {
        super(type, { detail: options.detail });

        for (const key in options) {
          if (key === "detail") continue;
          this[key] = options[key];
        }
      }
    }

    const myE = new MyCustomEvent("myE", {
      detail: { a: 1 },
      b: 2,
    });

    document.addEventListener("myE", function (e) {
      console.log(e.detail?.a, e.b);
    });
    document.dispatchEvent(myE);
  </script>
</html>
```

（3）事件对象

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      .box {
        margin: 20px;
        border: 5px solid #000;
        width: 60px;
        height: 30px;
      }
    </style>
  </head>
  <body>
    <div class="box"></div>
    <div class="box"></div>
  </body>

  <script>
    const box = document.querySelectorAll(".box");

    // 通用的属性方法 -----------------------------------------------------------------
    box[0].addEventListener("click", function (e) {
      // 阻止浏览器对该事件的默认行为
      e.preventDefault();

      // 阻止事件冒泡
      e.stopPropagation();

      // 事件类型\，事件触发时的时间戳
      console.log(e.type, e.timeStamp);

      // 监听此事件的元素
      console.log(this, e.currentTarget);

      // 触发此事件的元素，注意事件冒泡中 e.target 也始终是触发事件的元素
      console.log(e.target);
    });

    // 鼠标相关事件中的事件对象，如拖拽 ---------------------------------------------------
    box[1].addEventListener("mouseenter", function (e) {
      // 鼠标点击相关的事件特有 ------------------------------------------------------------------
      // 点击的鼠标键，左中右分别为 0 1 2 ，不是点击事件就为 0
      console.log(e.button);

      // 是否按下了修饰键，布尔值
      console.log(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey);

      // enter、leave 等进入离开相关的事件特有 -----------------------------------------------
      // enter 等进入的事件为从何处进入的元素；leave 等事件为离开后到达的元素
      console.log(e.relatedTarget);
      // 低版本 IE 中没有 relateedTarget ，但类似的有非标准属性 toElement
      // console.log(e.toElement);

      // 所有鼠标事件都有，左上角为坐标轴的原点 --------------------------------------------------------
      // 鼠标距 e.target 元素 content + padding 的偏移
      console.log(e.offsetX, e.offsetY);
      // 鼠标距视口的偏移
      console.log(e.clientX, e.clientY);
      // 鼠标距视口的偏移 + 页面滚动的偏移，即距整个页面的偏移
      console.log(e.pageX, e.pageY);
      // 鼠标距显示器的偏移
      console.log(e.screenX, e.screenY);
    });

    // 键盘事件对象 ------------------------------------------------------------------------
    window.addEventListener("keydown", function (e) {
      // 如 "1" "Numberpad1" 97
      // keyCode 已弃用
      console.log(e.key, e.code, e.keyCode);

      // 是否按下了修饰键，布尔值
      console.log(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey);

      // 是否正在长按
      console.log(e.repeat);
    });
  </script>
</html>
```

（3）事件流

事件处理包括事件捕获、事件冒泡两个阶段。默认情况下，事件在冒泡阶段触发。

- 事件捕获：从 DOM 树根结点出发到叶子结点捕获事件，若事件设置为捕获阶段触发且后代元素绑定了相同事件，则也会触发

- 事件冒泡：从触发事件的对象出发，到根结点，若事件设置为冒泡阶段触发且该事件对象的祖先有绑定相同事件，则也会触发

- 无论捕获还是冒泡，是否阻止冒泡，e\.target 始终为触发事件的元素；当 click 最内部的元素时的执行顺序：
  
  * 捕获：big \- mid \- small
  
  * 冒泡：small \- mid \- big
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <style>
        .box {
          border: 1px solid #000;
        }
  
        .big {
          display: flex;
          justify-content: center;
          align-items: center;
          width: 200px;
          height: 200px;
          background-color: #000;
        }
  
        .mid {
          display: flex;
          justify-content: center;
          align-items: center;
          width: 100px;
          height: 100px;
          background-color: #00f;
        }
  
        .small {
          width: 50px;
          height: 50px;
          background-color: #f00;
        }
      </style>
    </head>
    <body>
      <div class="big box">
        <div class="mid box">
          <div class="small box"></div>
        </div>
      </div>
    </body>
    <script>
      /**
       * 当 click small 时，3 个事件都会触发
       * 可以用 e.stopPropagation() 关闭事件冒泡
       */
  
      var big = document.querySelector(".big");
      var mid = document.querySelector(".mid");
      var small = document.querySelector(".small");
  
      const bigCb = (e) => console.log("big", e.target);
      const midCb = (e) => {
        /**只有阻止冒泡的 api ，没有阻止捕获的 api ，但阻止冒泡也会影响捕获行为）：
         * 捕获：big - mid
         * 冒泡：small - mid
         */
        // e.stopPropagation();
  
        console.log("mid", e.target);
      };
      const smallCb = (e) => console.log("small", e.target);
  
      // 捕获阶段触发
      big.addEventListener("click", bigCb, true);
      mid.addEventListener("click", midCb, true);
      small.addEventListener("click", smallCb, true);
  
      // 冒泡阶段触发
      // big.addEventListener("click", bigCb);
      // mid.addEventListener("click", midCb);
      // small.addEventListener("click", smallCb);
    </script>
  </html>
  ```

利用事件冒泡，当有很多子元素需要绑定相同事件，可以只把这个事件绑定到父元素，让父元素做事件委托，减少事件绑定数，提高性能：

```
<!DOCTYPE html>
<html lang="en">
  <head> </head>
  <body>
    <ul class="list">
      <li data-id="1">1</li>
      <li data-id="2">2</li>
      <li data-id="3">3</li>
    </ul>
  </body>
  <script>
    var list = document.querySelector(".list");
    var items = document.querySelector(".item");

    list.addEventListener("click", function (e) {
      // 只有 click li 时，才处理
      if (!e.target.getAttribute("data-id")) return;

      console.log(e.target.innerText);
    });
  </script>
</html>
```

### 1.3 常用 API

（1）拖拽

需要在元素标签添加 draggable="true" ：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      .container {
        display: flex;
        flex-wrap: wrap;
      }

      .box {
        margin: 20px 0;
        border: 10px solid #000;
        width: 300px;
        height: 300px;
      }

      .item {
        margin: 20px;
        height: 30px;
        border: 1px solid #000;
        background-color: red;
        line-height: 30px;
        text-align: center;
        color: #fff;
        transition: margin-top 0.5s;
      }

      .hidden {
        display: none;
      }

      .enter {
        margin-top: 50px;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <div class="box" data-can-dragged="true">
        <div class="item" draggable="true" data-item-id="0">1</div>
        <div class="item" draggable="true" data-item-id="1">2</div>
        <div class="item" draggable="true" data-item-id="2">3</div>
        <div class="item" draggable="true" data-item-id="3">4</div>
        <div class="item" draggable="true" data-item-id="4">5</div>
      </div>

      <div class="box" data-can-dragged="true"></div>
      <div class="box" data-can-dragged="true"></div>
    </div>
  </body>

  <script src="./1.js"></script>

  <script>
    const boxes = document.querySelectorAll(".box");
    const items = document.querySelectorAll(".item");
    const flip = new Flip(items);

    /**拖拽
     * 被拖拽元素的标签才需要加 draggable 属性，目标不用
     * 最好写成 draggable="true" ，若简写成 draggable ，拖拽会有问题
     * 被拖拽元素监听 dragstart 、drag 、dragend ；目标监听 dragenter 、dragover ，dragleave，drop ，dragend
     */
    let activateBox = null;
    let activateItem = null;
    let enterItem = null;

    for (const box of boxes) {
      // 拖拽开始时触发一次，draggable 的元素才会触发
      box.addEventListener("dragstart", function (e) {
        // 被拖拽的元素
        // console.log("start", e.target);

        // 修改鼠标行为，即拖拽时鼠标的样式
        // e.dataTransfer.dropEffect = "copy";

        // 修改拖拽缩略图，需要创建一个 img 元素并设置 src
        // e.dataTransfer.setDragImage(myImgElement, 0, 0);

        activateItem = e.target;
        activateBox = box;

        // 拖拽开始时，会产生一个样式基于被拖拽元素的拖拽缩略图，所以才需要异步修改被拖拽元素的样式，才不影响拖拽缩略图
        setTimeout(() => {
          e.target.classList.add("hidden");
          flip.play();
        });
      });

      // 拖拽时一直触发
      // box.addEventListener("drag", function (e) {
      //   // 被拖拽的元素，不是拖拽缩略图
      //   // console.log(e.target);
      // });

      // 拖拽结束时触发一次
      box.addEventListener("dragend", function (e) {
        // 被拖拽的元素
        // console.log(e.target);

        flip.refreshPosition();
        flip.refreshPosition(e.target, e.clientX, e.clientY);
        e.target.classList.remove("hidden");

        flip.play();
      });

      // 拖拽到刚进入某个元素后触发一次
      box.addEventListener("dragenter", function (e) {
        // 拖拽经过的元素
        // console.log("enter", e.target);

        if (!e.target.dataset.itemId) return;
        if (enterItem) enterItem.classList.remove("enter");
        if (e.target === enterItem) {
          enterItem = null;
          return;
        }

        enterItem = e.target;
        e.target.classList.add("enter");
      });

      // 拖拽经过某个元素后触发多次
      box.addEventListener("dragover", function (e) {
        e.preventDefault();

        // 拖拽经过的元素
        // console.log("over", e.target);
      });

      // 拖拽离开某个元素后触发一次
      box.addEventListener("dragleave", function (e) {
        // 拖拽离开的元素
        // console.log(e.target);

        if (enterItem && !box.contains(e.relatedTarget)) {
          enterItem.classList.remove("enter");
          enterItem = null;
        }
      });

      // 松手后触发一次，闭 dragend 执行早
      // 有些元素如 div ，table 、td 等不允许其他元素被拖拽到它们上面，不会触发 drop，需要在 dragover 事件中取消默认行为
      box.addEventListener("drop", function (e) {
        // 松手后被压在下面的元素
        // console.log("drop", e.target);

        const parentEl =
          e.target.dataset.canDragged === "true"
            ? e.target
            : e.target.parentElement;

        if (enterItem?.parentElement === box) {
          parentEl.insertBefore(activateItem, enterItem);
        } else parentEl.appendChild(activateItem);

        enterItem?.classList?.remove("enter");
      });
    }
  </script>
</html>
```

（2）剪切板

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      .img-box {
        width: 100px;
        height: 100px;
        border: 1px solid #000;
      }
    </style>
  </head>
  <body>
    <p class="text">123456789</p>
    <input type="text" />

    <div class="img-box" contenteditable="true"></div>
  </body>

  <script>
    const text = document.querySelector(".text");

    // 监听复制并添加内容 -----------------------------------------------------------------
    text.addEventListener("copy", function (e) {
      // 阻止复制的内容
      e.preventDefault();

      // 复制的内容，阻止了默认行为也能获取，因为得到的其实是选中的内容
      const selectedText = window.getSelection().toString();
      console.log(selectedText);

      // 添加内容
      navigator.clipboard.writeText(selectedText + "hello world");
    });

    // 获取剪切板内容，如根据剪切板内容进入某个页面 ---------------------------------------------
    // 为了隐私安全，浏览器会提示用户剪切板内容正在被读取，所以是一个 Promise
    navigator.clipboard
      .readText()
      .then((text) => {
        console.log(text);
      })
      .catch((err) => console.log("用户拒绝"));

    // 粘贴图片 ------------------------------------------------------------------------
    // 设置了 contenteditable="true" 的元素会变成可粘贴图片的 input ，但如果不用 JS 处理，不能保证每个浏览器都支持，且只能粘贴截图，不能粘贴复制的图片文件
    const imgBox = document.querySelector(".img-box");

    imgBox.addEventListener("paste", function (e) {
      // 若粘贴的是文本，则长度为 0
      if (e.clipboardData.files.length === 0) return;

      e.preventDefault();

      const reader = new FileReader();
      reader.onload = (res) => {
        const base64 = res.target.result;

        const img = document.createElement("img");
        img.src = base64;

        imgBox.appendChild(img);
      };

      for (const file of e.clipboardData.files) reader.readAsDataURL(file);
    });
  </script>
</html>
```

（3）IntersectionObserver

观察两个元素是否交叉，即被观察元素是否已经进入、离开某个元素，可以替代需要监控浏览器滚动的需求；

```
<!DOCTYPE html>
<html lang="en">
  <body>
    <ul class="list"></ul>
    <div class="loading">loading...</div>
  </body>

  <script>
    const list = document.querySelector(".list");
    const loading = document.querySelector(".loading");

    function addItem(num) {
      const start = document.querySelectorAll("li").length + 1;
      const frag = document.createDocumentFragment();

      for (let i = start; i < num + start; i++) {
        const li = document.createElement("li");
        li.textContent = "" + `${i}`;
        frag.appendChild(li);
      }

      list.appendChild(frag);
    }

    const ob = new IntersectionObserver(
      // 交叉到不交叉，或者不交叉到交叉就执行
      (entries) => {
        // 参数为一个数组，保存了这个 ob 对象所有 sbserve 的对象
        console.log(entries.length);

        // 如果不需要观察了，如图片懒加载，可以卸载
        // ob.unobserve(entries[0].target);

        if (entries[0].isIntersecting) {
          // 被观察的元素
          console.log(entries[0].target);

          addItem(50);
        }
      },

      {
        // 和哪个元素交叉，只能是祖先元素，默认为 null ，即视口
        root: null,

        // 交叉范围，默认 0 ，即被观察元素的大小
        rootMargin: "0px",

        // 交叉阈值，默认 0 ，范围从 0 ~ 1 ，交叉到交叉范围多少百分比才触发
        threshold: 1,
      }
    );

    ob.observe(loading);
  </script>
</html>
```

（4）监听页面显示隐藏

```
<!DOCTYPE html>
<html lang="en">
  <body></body>

  <script>
    // 浏览器兼容性
    let hidden, visibilityChange;
    if (document.hidden !== undefined) {
      hidden = "hidden";
      visibilityChange = "visibilitychange";
    }
    // 低版本 chrome
    else if (document.webkitHidden !== undefined) {
      hidden = "webkitHidden";
      visibilityChange = "webkitvisibilitychange";
    }
    // IE
    else if (document.msHidden !== undefined) {
      hidden = "msHidden";
      visibilityChange = "msvisibilitychange";
    } else throw "不支持";

    // 页面显示、隐藏后触发
    document.addEventListener(visibilityChange, function (e) {
      const info = document[hidden] ? "隐藏" : "显示";
      console.log(info);
    });
  </script>
</html>
```

## 2 BOM

BOM，浏览器对象模型，API 都放在 window ，使用时可以省略 window 。

### 2.1 基本

（1）BOM 常用事件

window 和 document 可注册的事件有些不同，但如果是都可以注册的事件如 click ，则区别在于时间补货和事件冒泡， window 是 document 的外层。

页面加载：

* 在最开始就能拿到 window 、document ，但是只有在 load 后才能拿到最完整的 DOM 结构（或者把 script 放到 body 的后面）

```
<!DOCTYPE html>
<html lang="en">
  <script>
    // 执行顺序：readystatechange - DOMContentLoaded - readystatechange - load - pageshow ------------

    // 不太常用，文档状态变化时触发，如 loading → interactive → complete
    document.onreadystatechange = function () {
      console.log("readyState:", document.readyState);
    };

    // DOM 树构建完成，不等待图片、CSS 加载，可以安全操作 DOM 元素
    document.addEventListener("DOMContentLoaded", function () {
      console.log("DOMContentLoaded");
    });

    // 渲染树完成后触发，即页面所有资源（图片、CSS、iframe、音视频等）完全加载完后触发，当 script 在 body 之前拿不到最终 DOM 就可以用 load
    window.addEventListener("load", function () {
      console.log("load");
    });

    // 与onload基本一样，但是在火狐浏览器中，前进页面后，之前的页面会缓存，再后退不会触发 load，而pageshow可以
    window.addEventListener("pageshow", function () {
      console.log("pageshow");
    });

    // 用户试图离开页面前触发，可用于弹出“是否确定离开”的提示
    window.addEventListener("beforeunload", function () {
      console.log("beforeunload");
    });

    // 页面完全卸载时触发。现在常用于性能分析，不建议做复杂操作
    window.addEventListener("unload", function () {
      console.log("unload");
    });
  </script>

  <body></body>
</html>
```

窗口：

```
<!DOCTYPE html>
<html lang="en">
  <body></body>

  <script>
    // 滚动
    window.addEventListener("scroll", function () {
      console.log("scroll");
    });

    // 缩放
    window.addEventListener("resize", function () {
      console.log("resize");
    });
  </script>
</html>
```

（2）定时器

```
<!DOCTYPE html>
<html lang="en">
  <script>
    /**
     * args：：callback ，ms ，...args
     * return ：定时器 id ，从 1 开始
     */

    // 执行一次
    const timerId = setTimeout(() => {
      console.log(123);
    }, 1000);

    // 重复执行
    const intervalId = setInterval(() => {
      console.log(456);
    }, 2000);

    // 1 2
    console.log(timerId, intervalId);

    // clear 后定时器停止
    clearTimeout(timerId);
    clearInterval(intervalId);
    // 1 2 ，只是用 id 找到定时器并停止，id 不变
    console.log(timerId, intervalId);

    // 传参
    const add = (a, b) => console.log(a + b);
    // 3 = 1 + 2
    const id = setTimeout(add, 1000, 1, 2);
    // 3 ，即使 clear 后 id 也不会再从 1 开始
    console.log(id);
  </script>
</html>
```

注意：

- 定时器在遇到时就开始计时，计时完毕就把回调函数入队红队列：
  
  ```
  const delay = (ms) => {
    const start = Date.now();
    while (Date.now() - start < ms) {}
  };
  
  setTimeout(() => {
    console.log(1);
  }, 0);
  
  // 0s 把回调函数包装成任务入队延时队列 3s 后输出 2 1
  delay(3000);
  console.log(2);
  ```

- 定时器设置为 0ms 也是异步任务，延时参数默认值是 0ms

- 相同延时的定时器，按照代码先后顺序入队

- 定时器无法做到精确计时，因为：
  
  - 计算机硬件本身就有微小偏差；定时器函数调用的操作系统的函数，本身也有微小偏差
  
  - W3C 标准中规定，若嵌套超过 5 层，从第 6 层开始，若 < 4ms ，则会自动变成 4ms ：
    
    ```
    setTimeout(() => {
      console.log(1);
    
      setTimeout(() => {
        console.log(2);
    
        setTimeout(() => {
          console.log(3);
    
          setTimeout(() => {
            console.log(4);
    
            setTimeout(() => {
              console.log(5);
    
              setTimeout(() => {
                console.log("4ms");
              }, 0);
            }, 0);
          }, 0);
        }, 0);
      }, 0);
    }, 0);
    ```
  
  - 切换页面后，浏览器为了优化性能，会把隐藏页面的定时器延长
  
  - 执行同步任务也需要时间，计时完成可能同步任务还没有完成

（3）内置对象

location ，处理 url ，和页面跳转、刷新：

```
// 读写 url'信息
console.log(
  location.href,
  location.host,
  location.pathname,
  location.search,
  location.hasg
);

// 跳转页面（也叫重定向），跳转后可返回原页面
location.assign("url");

// 跳转，但无法返回
location.replace("url");

/**刷新页面
 * true ：强制刷新页面，数据全部清空
 * false 或无参数：非强制刷新，会缓存一些数据，刷新会快一些
 */
location.reload();

// 也可以用 URL 处理 ----------------------------------------------------------
const str = "http://localhost:3000/data?a=1&b=2#123";
const url = new URL(str);

console.log(url);

// http://localhost:3000/data?a=1&b=2#123 ，会补上不影响功能的字符，如 "//"
console.log(url.href, url.toString());

// "http:" "localhost" "3000" "/data" "?a=1&b=2" "#123"
console.log(
  url.protocol,
  url.hostname,
  url.port,
  url.pathname,
  url.search,
  url.hash
);

// localhost:3000
console.log(url.host);

// "[object URLSearchParams]" "1" ，Map 结构
console.log(
  Object.prototype.toString.call(url.searchParams),
  url.searchParams.get("a")
);

/**encode 、decode ，编解码 url -----------------------------------------------------------------------------------
 * 解决特殊字符对 url 结构的影响以及编码不能出现在 url 的字符，如中文
 * url 中可以包含大部分的 ASCII 字符，以及部分其他编码格式的字符
 */
const str1 = "nam e =张三 & age = 18";
const encodeStr1 = encodeURIComponent(str1);

// name编码18 ，用于编码 url 某部分组件，如 search
console.log(encodeStr1);
// true
console.log(decodeURIComponent(encodeStr1) === str1, "\n");

const str2 = "https://example.com/a file.html?x=1&y=2";
const encodeStr2 = encodeURI(str2);
//
// "https://example.com/a%20file.html?x=1&y=2" ，处理整个 url ，保留合法字符
console.log(encodeStr2);
// true
console.log(decodeURI(encodeStr2) === str2, "\n");

const str3 = "Hello";
const base64 = btoa(str3);

// base64 编码 ，只能编码 ASCII ，其他字符需要借助 encodeURIComponent
console.log(base64, btoa(encodeURIComponent("张三")));
// true
console.log(atob(base64) === str3);
```

history ，与浏览器的历史记录进行交互，保存了用户浏览过的地址：

```
// 前进
history.forward();

// 后退
history.back();

// 正数前进、附属后退
history.go(1);
```

navigation ，可以得到浏览器的信息，如当前的设备是 PC 还是移动端、网络状态等：

```
console.log(Navigator.userAgent.match());
```

### 2.2 存储、通信

（1）本地存储

HTML5 新特性，有 WebStorage 和 indexedDB ，可以在调试工具的 application 中查看。

Web Storage ，同步存储，总存储大小 4MB \~ 5mb ，key 、value 都是 string ，分为两种，区别：

- local storage：同源页面共享，永久存储，只有清除浏览器缓存、或主动调用 clear() 才会被清除，关机都不会清除

- session storage：单页面独享（多个相同的标签页也是各自独享），会话存储，只有关闭页面、关闭浏览器才会清空，刷新和页面跳转都不会清空

```
<!DOCTYPE html>
<html lang="en">
  <body></body>

  <script>
    // 以 localStorage 为例，API 都一样

    const data = { a: 1 };

    // set
    localStorage.setItem("test", JSON.stringify(data));

    // get ，没有则 null
    const res = JSON.parse(localStorage.getItem("test"));
    console.log(res);

    // 删除
    localStorage.removeItem("test");
    // localStorage.clear();
    console.log(JSON.parse(localStorage.getItem("test")));
  </script>
</html>
```

indexedDB ，同源页面共享，异步存储，总大小至少 50MB ，多的能到 GB（根据浏览器的策略）；非关系型数据库，存储的是对象，用于存储大量缓存数据；

```
<!DOCTYPE html>
<html lang="en">
  <script>
    // 打开、创建 ----------------------------------------------------------------------------
    /**打开 indexedDB ，版本号为 1
     * 若数据库不存在，则会创建；若没有传入版本号，则为 1
     * 若打开已存在的数据库，且不传入版本号，就为最新的版本号
     * 结构：db - 多个数据库如 myDB - 表
     */
    // 得到一个 IDBOpenRequest 对象，用于处理该数据库的事件监听；而数据库是一个 IDBDatabase 对象
    const myDBOr = indexedDB.open("myDB", 1);

    // 当数据库首次创建或版本更新时触发（用于建表）
    myDBOr.addEventListener("upgradeneeded", function (e) {
      // IDBDatabase 对象
      const myDB = e.target.result;

      // 创建一个 user 对象存储区（相当于 user 表），主键为 "id"
      const store = myDB.createObjectStore("users", { keyPath: "id" });

      // 创建一个索引，基于 "name" 字段，不强制唯一
      store.createIndex("name", "name", { unique: false });
    });

    // 打开数据库发生错误时触发
    myDBOr.addEventListener("error", function (e) {
      console.error("Database error:", e.target.error);
    });

    // CURD ，都是异步的 --------------------------------------------------------------------------
    // db 为 IDBDatabase 对象
    function getUser(db, field, isPromary = true) {
      // 创建一个只读事务，用于访问 "users" 表
      const transaction = db.transaction(["users"], "readonly");

      // 从事务中获取对象存储（即表）"users"
      const store = transaction.objectStore("users");

      // 根据字段 field 查询
      const getter = isPromary ? store : store.index("name");
      const request = getter.get(field);

      // 查询成功后执行回调
      request.onsuccess = () => {
        if (request.result) {
          console.log("查询成功：", request.result);
        } else {
          console.log("没有找到结果");
        }
      };
    }

    function addUser(db, user) {
      const transaction = db.transaction(["users"], "readwrite");
      const store = transaction.objectStore("users");

      const request = store.add(user);

      // 若数据已存在就 err
      request.onsuccess = () => console.log("添加 user 成功");
      request.onerror = (e) => console.error("user 已存在", e);
    }

    function updateUser(db, user) {
      const transaction = db.transaction(["users"], "readwrite");
      const store = transaction.objectStore("users");

      // 使用 put() 方法更新用户记录（如果主键存在就更新，不存在则添加）
      const request = store.put(user);

      request.onsuccess = () => console.log("修改成功", user);
      request.onerror = () => console.log("修改失败", user);
    }

    function deleteUser(db, id) {
      const transaction = db.transaction(["users"], "readwrite");
      const store = transaction.objectStore("users");
      const request = store.delete(id);

      request.onsuccess = () => console.log("删除成功");
    }

    // 当数据库成功打开时触发；打开创建数据库是异步的，所以这里才能拿到 IDBDatabase
    myDBOr.addEventListener("success", function (e) {
      const myDB = e.target.result;

      addUser(myDB, { id: 0, name: "abc" });
      getUser(myDB, 0);
      updateUser(myDB, { id: 0, name: "qwe" });
      getUser(myDB, "qwe", false);
      deleteUser(myDB, 0);

      // 1 ，版本号，只能在 open 时修改，版本只能升级不能降低
      console.log("version", myDB.version);
    });
  </script>

  <script src="https://cdn.jsdelivr.net/npm/dexie@3/dist/dexie.min.js"></script>
  <script>
    // 第三方库能更方便使用 indexedDB ，以 Dexie 为例 -------------------------------

    // 创建数据库，定义数据库版本和表结构
    const db = new Dexie("MyDatabase");
    db.version(1).stores({
      // 主键自增id，索引name和age
      friends: "++id,name,age",
    });

    // 添加数据
    async function addFriend() {
      await db.friends.add({ name: "张三", age: 28 });
      console.log("添加成功");
    }

    // 查询所有数据
    async function getAllFriends() {
      const all = await db.friends.toArray();
      console.log("所有朋友:", all);
    }

    // 修改数据
    async function updateFriend(id, newName) {
      await db.friends.update(id, { name: newName });
      console.log(`更新id=${id}成功`);
    }

    // 删除数据
    async function deleteFriend(id) {
      await db.friends.delete(id);
      console.log(`删除id=${id}成功`);
    }

    // 使用示例
    async function runDemo() {
      await addFriend();
      await getAllFriends();
      await updateFriend(1, "李四");
      await getAllFriends();
      await deleteFriend(1);
      await getAllFriends();
    }

    runDemo();
  </script>
</html>
```

（2）iframe

内联框架，用于嵌入页面、视屏等：

```
<!DOCTYPE html>
<html lang="en">
  <body>
    <!--
      * 可以嵌入跨源的网页
      * 若服务器设置了响应头字段 X-Frame-Options ：
        * "SAMEORIGIN" ：只允许同源嵌入，
        * "DENY" ：不允许被任何网页嵌入
      * 布尔属性 sandbox ：
        * 可以更安全的嵌入网页，默认静止大部分行为,如禁止被嵌入的网页执行 JS ，表单提交，窗口弹出、页面跳转等
        * 也可以单独设置允许的行为，如 sandbox="allow-scripts allow-forms"
    -->

    <!-- 嵌入页面 -->
    <iframe
      class="ifm"
      src="http://localhost:3000/1.html"
      width="600"
      height="400"
    ></iframe>

    <!-- 嵌入视频
      * frameborder ，是否显示边框（0~1）
      * allowfullscreen ，是否允许全屏
    -->
    <iframe
      src="https://www.youtube.com/embed/dQw4w9WgXcQ"
      width="560"
      height="315"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen
    >
    </iframe>
  </body>

  <script>
    const ifm = document.querySelector(".ifm");

    // ifram 页面的 dindow 、document
    const win = ifm.contentWindow;
    const doc = ifm.contentWindow.document;
  </script>
</html>
```

（3）实时通信

在不刷新页面的情况下实时获取其他页面的数据。

跨源通信，用 HTML5 的 postMessage ，数据会深拷贝：

* 配合 window\.open ，缺点是必须打开一个新页面，不推荐：
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <body>
      localhost:4000
    </body>
  
    <script>
      localStorage.setItem("test_data", "123");
  
      const allowOrigins = ["http://localhost:3000"];
  
      function getData(type, key) {
        switch (type) {
          case "localstorage":
            return localStorage.getItem(key);
          default:
            break;
        }
      }
  
      window.addEventListener("message", (from) => {
        // 安全校验
        if (!allowOrigins.includes(from.origin)) return;
  
        // 回复消息，可以实现 localstorage 的跨源通信
        const win = from.source;
        const { type, key } = from.data;
        win.postMessage(getData(type, key), from.origin);
      });
    </script>
  </html>
  ```
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <body>
      localhost:3000
  
      <div>
        <button class="btn">get</button>
      </div>
    </body>
  
    <script>
      // null ，localstorage 只能同源页面获取
      console.log(localStorage.getItem("data from localhost:4000"));
  
      const targetURL = "http://localhost:4000/index.html";
  
      // 监听其他页面 postMessage 发送的消息
      const allowOrigins = ["http://localhost:4000"];
      window.addEventListener("message", function (from) {
        // 安全校验
        if (!allowOrigins.includes(from.origin)) return;
  
        console.log(from.data, from.origin);
  
        from.source.close();
        isOpen = false;
      });
  
      /**open
       * 浏览器为了安全弹窗，只允许在用户交互的情况下 open 才有效，JS 主动触发事件如 click() 都不行
       * 打开新页面并得到新页面的 window ，第二个参数为新窗口的 name ，若已打开相同 name 的网页，open 则不在新打开页面，而是刷新
       * 若不想刷新，可以借助本地存储保存打开状态
       */
      let win = null;
      let isOpen = false;
      document.querySelector(".btn").addEventListener("click", function (e) {
        const data = { type: "localstorage", key: "test_data" };
  
        if (!isOpen) {
          win = window.open(targetURL, "testPage");
          isOpen = true;
        }
  
        /**postMessage
         * targetURL 必须和 win 的 url 相同，作用是给 win 发送消息
         * 若 win 未 load ，postMessage 无效，但是这里 win 监听 load 没反应
         */
        win.postMessage(data, targetURL);
      });
    </script>
  </html>
  ```

* 配合 iframe ：
  
  ```
  // PostMessage.js
  
  class PostMessage {
    constructor(options) {
      options = {
        ...{
          toURL: null,
          fromAllowOrigins: [],
          needEmit: false,
        },
        ...options,
      };
  
      this.toURL = options.toURL;
      this.fromAllowOrigins = options.fromAllowOrigins;
  
      if (options.needEmit) {
        const iframe = document.createElement("iframe");
        iframe.style.display = "none";
        iframe.src = this.toURL;
        document.body.appendChild(iframe);
  
        this.iframe = iframe;
      }
    }
  
    emit = (data) => {
      if (!this.iframe) throw new TypeError("没有 iframe");
      this.iframe.contentWindow.postMessage(data, this.toURL);
    };
  
    on = (callback) => {
      window.addEventListener("message", (from) => {
        // 安全校验
        if (!this.fromAllowOrigins.includes(from.origin)) {
          console.log(this.fromAllowOrigins[0] === from.origin);
          throw new TypeError("不允许的源");
        }
  
        callback(from);
      });
    };
  }
  ```
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <body>
      localhost:4000
    </body>
  
    <script src="http://localhost:3000/post-message.js"></script>
    <script>
      localStorage.setItem("test_data", "123");
  
      // 若跨源页面的 iframe 嵌入了该页面，也能得到 localstorage 的数据
      // console.log(localStorage.getItem("test_data"));
  
      const pm = new PostMessage({
        fromAllowOrigins: ["http://localhost:3000"],
      });
  
      function getData(type, key) {
        console.log(type, key);
        switch (type) {
          case "getLocalstorage":
            return localStorage.getItem(key);
          default:
            break;
        }
      }
  
      pm.on((res) => {
        // 回复消息，可以实现 localstorage 的跨源通信
        const win = res.source;
        const { type, key } = res.data;
        win.postMessage(getData(type, key), res.origin);
      });
    </script>
  </html>
  ```
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <body>
      localhost:3000
  
      <div>
        <button class="btn">get</button>
      </div>
    </body>
  
    <script src="http://localhost:3000/post-message.js"></script>
    <script>
      // null ，localstorage 只能同源页面获取
      console.log(localStorage.getItem("data from localhost:4000"));
  
      const pm = new PostMessage({
        toURL: "http://localhost:4000/index.html",
        fromAllowOrigins: ["http://localhost:4000"],
        needEmit: true,
      });
  
      // 监听其他页面 postMessage 发送的消息
      pm.on((res) => {
        console.log(res.data, res.origin);
      });
  
      document.querySelector(".btn").addEventListener("click", () => {
        pm.emit({ type: "getLocalstorage", key: "test_data" });
      });
    </script>
  </html>
  ```

同源通信；

* window.onstorage ：
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <body>
      <p>1.html</p>
    </body>
  
    <script>
      /**
       * 其他同源的标签页 set 任何一个 localstorage 后触发
       * 当前标签页 set 不会触发
       * 若 set 的值和原来一样，就不会触发
       */
      window.addEventListener("storage", function (e) {
        console.log(e.url, e.key, e.oldValue, e.newValue);
      });
    </script>
  </html>
  ```
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <body>
      <p>2.html</p>
    </body>
  
    <script>
      localStorage.setItem("test", "msg");
      localStorage.setItem("test", "m");
    </script>
  </html>
  ```
  
  ```
  // 封装 window.onstorage ---------------------------------------------------
  
  // 防止 key 和其他项目冲突
  const KEY_PRE = "MY_TEST";
  
  function emit(type, payload) {
    localStorage.setItem(
      KEY_PRE + type,
      JSON.stringify({
        payload,
  
        // 使得 oldValue 、newValue 相同时也触发
        temp: Math.random(),
      })
    );
  }
  
  function on(callback) {
    if (typeof callback !== "function") throw "callback must be a function";
  
    function _callback(e) {
      callback({
        url: e.url,
        key: e.key.replace(KEY_PRE, ""),
        oldValue: JSON.parse(e.oldValue).payload,
        newValue: JSON.parse(e.newValue).payload,
      });
    }
  
    window.addEventListener("storage", _callback);
  
    // 注销
    return () => window.removeEventListener("storage", _callback);
  }
  ```

* BroadCast ，比 onstorage 好的一点是数据不用 JSON.stringify ，而是直接深拷贝数据，就不会受到 JSON API 的限制：
  
  ```
  class Channel {
    #channel = null;
  
    constructor(channelName) {
      // 相互通信的页面要求在同源，且 name 相同的 channel 中
      this.#channel = new BroadcastChannel(channelName);
    }
  
    // on 接收会深拷贝，但拷贝 Proxy 会 err ，如果 emit 一个 Proxy 对象，需要还原原始对象
    emit = (type, payload) => {
      this.#channel.postMessage({ type, payload });
    };
  
    // 只会监听不同页面的 emit ，当前页面 emit 后不会触发
    on = (callback) => {
      if (typeof callback !== "function") throw "callback must be a function";
  
      const _callback = (e) => callback(e.data);
  
      this.#channel.addEventListener("message", _callback);
  
      return () => this.#channel.removeEventListener("message", _callback);
    };
  }
  ```

其他的如本地存储如 cookie 、IndexDB 配合定时器轮询，或配合网络如 websocket 等。

## 3 Web 原理

执行上下文：就是执行栈。

### 3.1 JS 执行机制

#### 3.1.1 事件循环

事件循环（event loop），也叫消息循环（message loop），浏览器和 node 都有事件循环机制。

（1）浏览器进程模型

最重要的 3 个进程：

* 浏览器进程：处理浏览器自身

* 网络进程：处理网络传输

* 渲染进程：处理 HTML 、CSS 的渲染，JS 的执行等。一个页面会开启一个渲染进程，渲染进程中只有一个渲染主线程

由于每个页面都会开启一个渲染进程，会消耗很多内存，所以在未来，浏览器会做改进，让一个站点共用同一个渲染进程。

（2）单线程与同步、异步

JS 是单线程的，这是因为 JS 运行在浏览器的渲染主线程中，而渲染主线程只有一个，渲染主线程又承担很多工作，如渲染页面，执行 JS 等。如果只使用同步方式，JS 就有可能阻塞其他的工作。

因此就需要异步，当 JS 执行时，若遇到异步任务，就会把异步的回调函数包装成任务（浏览器源码中任务是一个结构体），入队到消息队列中等同步任务执行完再执行，实现永不阻塞。

遇到定时器会交给计时线程进行计时，遇到事件会交给交互线程进行监听。

JS 阻塞渲染的例子：

渲染任务是异步的，由于 JS 在同步阶段执行太久，因此阻塞了异步的渲染任务：

```
<!DOCTYPE html>
<html lang="en">
  <body>
    <div><button id="btn">变大</button></div>
    <p id="box" style="font-size: 20px">asdf</p>
  </body>

  <script>
    function delay(ms) {
      var start = Date.now();
      while (Date.now() - start < ms) {}
    }

    var box = document.querySelector("#box");
    var btn = document.querySelector("#btn");

    btn.addEventListener("click", function () {
      // 3s 后才会改变字体大小，因为被 JS 阻塞了
      box.style.fontSize = "50px";
      delay(3000);
    });
  </script>
</html>
```

JS 异步任务分类：

* 微任务：对应微队列，优先级最高，甚至比页面渲染还高：
  
  * 浏览器中，有 Mutation Observer ，Promise ，queueMicrotask ，它们之间没有优先级，由代码顺序决定：
    
    ```
    <!DOCTYPE html>
    <html lang="en">
      <script>
        // Mutation Observer ， 早期的做法，兼容性好，但比较繁琐
        const ob = new MutationObserver(() => {
          console.log("micro 1");
    
          // 清理观察器，防止内存泄露
          ob.disconnect();
        });
    
        const textNode = document.createTextNode("");
        ob.observe(textNode, { characterData: true });
        textNode.data = "1";
    
        // ES6 的 Promise
        Promise.resolve().then(() => console.log("micro 2"));
    
        // HTML 新标准的 queueMicrotask ，原本是在 Promise 内部中放到微任务的 API ，兼容性最差
        queueMicrotask(() => console.log("micro 3"));
      </script>
    </html>
    ```
  
  * node  中，有 Promise ，queueMicrotask ，process\.nextTick ，其中 process\.nextTick 优先级最高：
    
    ```
    Promise.resolve().then(() => console.log("micro 2"));
    queueMicrotask(() => console.log("micro 3"));
    
    // 优先级最高
    process.nextTick(() => console.log("micro 1"));
    ```

* 宏任务：对应红队列，处理定时器、事件、ajax、文件 IO 等，但由于现在的项目越来越复杂，宏队列已经不够用了，因此在 W3C 最新标准中，去掉了宏任务的概念，新增了延时队列、交互队列、网络队列等：
  
  * 不同任务类型的任务允许放到一个队列中；但所有同一个类型的任务只能存在于一个队列中
  
  * 标准中没有规定队列的优先级，具体如何执行由浏览器决定，不过一般会认为：交互队列 \> 延时队列 \> 网络队列
  
  * node 宏任务也有定时器，还多了个 setImmediate ：
    
    ```
    function delay(ms) {
      const now = Date.now();
      while (Date.now() - now <= ms);
    }
    
    // setImmediate 在每一轮事件循环结束时全部回调
    // 若期间产生了新的微任务，也会在本轮执行；产生其他的新任务则在下一轮执行，即便计时完成
    setImmediate(() => {
      console.log("第一轮循环结束 1");
    
      process.nextTick(() => {
        console.log("第一轮中执行 nextTick");
    
        setImmediate(() => console.log("第二轮结束"));
    
        setTimeout(() => console.log("第二轮 setTimeout"));
        delay(1);
      });
    
      setTimeout(() => console.log("第二轮 setTimeout"));
      delay(1);
    });
    
    setImmediate(() => console.log("第一轮循环结束 2"));
    
    // 由于定时器并不精确，再加上计算机环境的影响，造成就算计时 0ms 也不会立刻入队延时队列，就有肯呢会出现第一轮事件循环结束时，0ms 的定时器还未入队的情况
    // 所以这些定时器肯呢在第一轮执行，也可能在其他轮执行
    setTimeout(() => console.log(1), 0);
    setTimeout(() => console.log(2), 0);
    setTimeout(() => console.log(3), 0);
    
    // delay 一下就能保证这些定时器都在第一轮执行
    // delay(1);
    ```

执行顺序，同步任务 \-\> 事件循环（微任务 \-\> 宏任务 ）：

* 自上而下执行，遇到异步任务就入队到对应的消息队列，当执行完所有同步任务后，开始事件循环，事件循环在源码中就是一个死循环，不断查看是否有异步任务需要执行

* 优先级高的队列中的任务先执行

* 若有相同引用的任务，不会去重，会直接入队

（3）模拟事件循环

```
// 同步任务
const sync = () => console.log("同步任务");

// 微队列
const microQueueImportant = [() => console.log("nextTick")];
const microQueue = [
  () => console.log("Promise 1"),
  () => console.log("Promise 2"),
];

// 宏队列
let immediate = [
  () => {
    console.log("第一轮结尾 1");

    microQueue.push(() => {
      console.log("Promise 4");

      immediate.push(() => console.log("第二轮结尾"));
      macroQueue.push(() => console.log("第二轮 setTimeout"));
    });
  },

  () => console.log("第一轮结尾 2"),
];

const macroQueue = [
  () => {
    console.log("setTimeout 1");
    microQueue.push(() => console.log("Promise 3"));
  },

  () => console.log("setTimeout 2"),
];

// 执行 ---------------------------------------------------------------
function run() {
  // 绒布任务
  sync();

  // 根据队列优先级取出异步任务
  function getTask(needMacroTask = false) {
    if (microQueueImportant.length) return microQueueImportant.shift();
    else if (microQueue.length) return microQueue.shift();
    else if (needMacroTask) {
      if (macroQueue.length) return macroQueue.shift();
    }

    return null;
  }

  // 按优先级执行
  function runTask(needMacroTask = false) {
    let task = null;
    while ((task = getTask(needMacroTask))) task();
  }

  for (;;) {
    // 微任务、宏任务全部执行完
    runTask(true);

    // setImmediate ，只执行本轮已有的 setImmediate ，新产生的下一轮执行
    const nowImmediate = [...immediate];
    immediate = [];
    while (nowImmediate.length) {
      nowImmediate.shift()();

      // 若产生了新任务，只执行微任务，宏任务在下一轮执行
      runTask(false);
    }
  }
}

run();
```

#### 3.1.2 多线程

HTML5 新特性 worker ，worker 都无法操作 DOM ，且只能使用部分 Web API 。

（1）Web Worker

也叫 Dedicated Worker ，在当前页面的渲染进程中开启一个新的线程（所以关闭当前页面后 Web Worker 失效且只能和当前页面通信，类似 sessionStorage 的特性），可以开启多个：

```
// localhost:3000/worker.js

// worker 内部可以和其他 worker 通信
// const otherWorker1 = new Worker("/otherWorker1.js");

// self 是 worker 中的全局对象，类似主线程中的 window
console.log("worker 已创建", self);

// worker 无法操作 DOM
try {
  console.log(document);
} catch {
  console.log("没有 DOM");
}
// 只能使用部分 Web API
console.log(setTimeout, fetch);

// 接收主线程的数据并向其发送数据，数据会深拷贝
self.addEventListener("message", (e) => {
  console.log("主线程发给 worker 的数据", e.data);

  // 执行耗时操作
  const now = Date.now();
  while (Date.now() - now < 3000);

  // 因为 Web Worker 在渲染进程中，只有一个页面，所以这样和主线程通信
  self.postMessage(e.data * 2);

  // 发送到其他 worker
  // otherWorker1.postMessage();
});

// 接收其他 worker 的数据
// otherWorker1.addEventListener("mmessage", (e) => {});
```

```
<!DOCTYPE html>
<html lang="en">
  <body>
    localhost:3000
  </body>

  <script>
    // true ，主线程中 self 即 window
    console.log(self === window);

    // 创建 ------------------------------------------------------------------------------------
    // 方式一、worker 必须是网络中同源的 JS 文件，
    const worker1 = new Worker("/worker.js");
    // const worker = new Worker("http://localhost:3000/worker.js");

    // 方式二、通过 Blob URL 创建，可以放到跨域的 JS 文件中，用 <script> 引入，实现跨域 worker
    // 类似的还有 Data URL ，但不推荐，兼容性差且不方便调试
    const worker2 = new Worker(
      URL.createObjectURL(
        new Blob(
          [
            `
              self.addEventListener("message", (e) => console.log("worker2", e.data));
            `,
          ],
          { type: "application/javascript" }
        )
      )
    );

    // 终止 worker
    // worker1.terminate();

    /**主线程与 worker 通信 -----------------------------------------------------------------
     * 数据会深拷贝，所以把 document 传过去也没用
     * 深拷贝用的是一种高效算法，不是 JSON.stringify ，但部分类型的数据无法拷贝
     */
    // 监听 worker 返回的信息
    worker1.addEventListener("message", (e) => {
      console.log("worker 发给主线程的数据", e.data);
    });

    // 发送数据给 worker ，多个 worker 的顺序是不确定的
    worker1.postMessage(123);
    worker2.postMessage(123);
  </script>
</html>
```

（2）Shared Worker

在浏览器主进程内部开启一个新线程，与 Web Worker 的区别就是 Shared Worker 可以在多个同源页面共享，只有连接的所有页面全部关闭时，Shared Worker 才会清除：

```
// http://localhost:3000/worker.js

// 访问 chrome://inspect/#devices 在 Shared Workers -> inspect 中调试；chrome 控制台不会输出

// 每个页面的 port
const portMap = new Map();

// 共享数据
const store = {};

self.addEventListener("connect", (e) => {
  // 每个页面连接后，触发 connect ，拿到页面的 port
  const port = e.ports[0];
  port.start();

  // 闭包使用 port
  function messageHandler(e) {
    if (Object.prototype.toString.call(e.data.data) !== "[object Object]") {
      e.data.data = {};
    }

    const {
      type,
      data: { fromPortName, toPortName, key, value },
    } = e.data;

    switch (type) {
      case "setPort":
        if (!fromPortName || typeof fromPortName !== "string") {
          port.postMessage({
            type: "err",
            errMsg: "fromPortName must be a string and not ‘’ ",
          });
        } else {
          portMap.set(fromPortName, port);
          port.portName = fromPortName;
          port.postMessage({ type: "set", msg: "setPort ok" });
        }

        return;

      case "setStore":
        store[key] = value;
        port.postMessage({ type: "set", msg: "setStore ok" });
        return;

      case "getStore":
        port.postMessage({ type: "get", data: store[key] });
        return;

      case "postOnePort":
        if (toPortName === port.portName) {
          port.postMessage({ type: "err", errMsg: "from === to" });
        } else {
          const p = portMap.get(toPortName);

          if (!p) port.postMessage({ type: "err", errMsg: "toProst not find" });
          else {
            p.postMessage({ type: "get", data: store[key] });
            port.postMessage({ type: "set", msg: "postOnePort ok" });
          }
        }

        return;

      case "postAllPort":
        for (const p of portMap) {
          if (p[0] === port.portName) continue;

          p[1].postMessage({ type: "get", data: store[key] });
        }
        port.postMessage({ type: "set", msg: "postAllPort ok" });

        return;

      default:
        port.postMessage({ type: "err", errMsg: "invalid type" });
        break;
    }
  }

  port.addEventListener("message", messageHandler);
});
```

```
<!DOCTYPE html>
<html lang="en">
  <body>
    localhost:3000
  </body>

  <script>
    function createSharedWorker(url, portName, messageHandler) {
      if (!url || !portName) throw TypeError("args err");

      const worker = new SharedWorker(url);
      worker.port.start();
      worker.port.portName = portName;

      if (typeof messageHandler === "function") {
        worker.port.addEventListener("message", messageHandler);
      }

      worker.port.postMessage({
        type: "setPort",
        data: { fromPortName: portName },
      });

      return worker;
    }

    const worker = createSharedWorker("/worker.js", "page1", (e) => {
      console.log(e.data);
    });

    worker.port.postMessage({
      type: "setStore",
      data: { key: "a", value: 123 },
    });

    worker.port.postMessage({
      type: "getStore",
      data: { key: "a" },
    });

    worker.port.postMessage({
      type: "postOnePort",
      data: { toPortName: "page1", key: "a" },
    });

    worker.port.postMessage({
      type: "postAllPort",
      data: { key: "a" },
    });
  </script>
</html>
```

（3）Service Worker

在浏览器主进程内部开启一个新的线程关闭页面、关闭浏览器、关机后 Service Worker 依然存在，同源页面共享、类似 localStorage 的特性，只能开启一个。

可以作为浏览器和网络之间的中间层，实现缓存后端数据，缓存静态资源实现网络离线后依然能访问，在调试工具 \- application 中可以查看 Service Worker 和 Cache Storage ：

```
// localhost:3000/sw.js

// 只有页面激活 Service Worker 才执行一次
console.log("Service Worker");

self.addEventListener("message", (e) => {
  console.log("from main", e.data);
  e.source.postMessage(e.data * 2);
});

// 应用，离线缓存静态资源 ------------------------------------------------------------------------------------
// 缓存
// console.log(caches);

const CACHE_NAME = "my-cache-v1";

// 需要缓存的静态资源，这里缓存静态文件夹中的 test.html
const url = "/test.html";
const urls = ["/test.html"];

// caches CURD ------------------------------------------------------------------------------
// get
async function getCache(cacheName) {
  const cache = await caches.open(cacheName);
  const requests = await cache.keys();

  return requests.map((req) => req.url);
}

// set
async function setCache(cacheName, url) {
  const cache = await caches.open(cacheName);

  if (Array.isArray(cache)) await cache.addAll(url);
  else await cache.add(url);
}

// delete
async function deleteCache(cacheName) {
  const cache = await caches.open(cacheName);
  return await caches.delete(cacheName);
}

// 缓存静态资源，使得可以离线访问 -----------------------------------------------------------
// Service Worker 开始注册时触发
self.addEventListener("install", async (e) => {
  await setCache(CACHE_NAME, urls);

  const cache = await getCache(CACHE_NAME);
  console.log([...cache]);
});

// 注册完成后，被激活后触发
self.addEventListener("activate", async (e) => {
  // await deleteCache(CACHE_NAME);
});

/**拦截网络请求（仅 https 协议触发），可以实现：
 * 可以根据情况看是使用缓存的资源还是重新请求
 * 可以重新请求加载失败的资源
 * 可以缓存后端接口返回的大型数据
 */
self.addEventListener("fetch", (e) => {});
```

```
<!DOCTYPE html>
<html lang="en">
  <body>
    localhost:3000
  </body>

  <script>
    // Service Worker 和 localStorage 一样，关闭浏览器也不会清除，这里可以手动清除
    const unregister = async () => {
      try {
        const sws = await navigator.serviceWorker.getRegistrations();

        const p = [];
        for (const sw of sws) p.push(sw.unregister());

        const res = await Promise.all(p);
        console.log(res);
      } catch (err) {
        console.log(err);
      }
    };

    /**注册 Service Worker
     * 只能使用同源 JS 文件，不能使用 blob url ，data url
     * 若已注册，则直接 resolve
     */
    const registerServiceWorker = async () => {
      try {
        const registration = await navigator.serviceWorker.register(
          "/script/workers/sw.js"
        );

        if (registration.installing) {
          console.log("正在安装");
          return;
        } else if (registration.waiting) console.log("已安装");
        else if (registration.active) console.log("激活");

        registration.active.postMessage(123);
      } catch (err) {
        console.log(err);
      }
    };

    unregister();
    registerServiceWorker();

    // 通信
    navigator.serviceWorker.addEventListener("message", (e) => {
      console.log("from worker", e.data);
    });
  </script>
</html>
```

（4）共享内存

ES8 新特性，主要用于 worker 通信，解决 postMessage 无法深拷贝部分类型数据的问题：

* ShareArrayBuffer ：用于创建一个给多个线程内存共享的二进制缓冲区，postMessage 只会把 ShareArrayBuffer 对象的引用发送出去

* Atomice ：用于原子操作 ShareArrayBuffer 的数据，这是为了给多线程枷锁，防止多线程同时读写或同时修改时，数据不同步的问题
  
  * 原子操作：操作只有成功和失败，没有中间状态

浏览器为了安全，只有后端服务器设置了跨源隔离的响应头后，访问的 html 才能使用共享内存，否则 ShareArrayBuffer 为 undefined ：

```
// localhost:3000

const express = require("express");
const path = require("path");

const app = express();
const PORT = 3000;

// 添加跨源隔离响应头
app.use((req, res, next) => {
  res.setHeader("Cross-Origin-Opener-Policy", "same-origin");
  res.setHeader("Cross-Origin-Embedder-Policy", "require-corp");
  next();
});

app.use(express.static(path.join(__dirname, "public")));

app.listen(PORT, () => {
  console.log(`Server is running at http://localhost:${PORT}`);
});
```

```
<!DOCTYPE html>
<html lang="en">
  <body>
    localhost:3000
  </body>

  <script>
    // 4 Byre
    const sab = new SharedArrayBuffer(4);
    const view = new Int32Array(sab);
    view[0] = 123;

    const worker = new Worker("./worker.js");
    worker.postMessage(sab);

    worker.addEventListener("message", (e) => {
      // true ，因为内存是共享的
      console.log("from worker", new Int32Array(e.data)[0] === view[0]);
    });
  </script>
</html>
```

```
// localhost:3000/worker.js

self.addEventListener("message", (e) => {
  const view = new Int32Array(e.data);

  // 123
  console.log("接收到的数据：", view[0]);

  // get 、set --------------------------------------------------------------------------
  // 123 ，get
  console.log(Atomics.load(view, 0));

  // 456 ，set
  Atomics.store(view, 0, 456);
  console.log(Atomics.load(view, 0));

  self.postMessage(e.data);

  // 算术运算，会修改原始数据，并返回 oldValue --------------------------------------------
  // 456 457 ，+=
  const n1 = Atomics.add(view, 0, 1);
  console.log(n1, Atomics.load(view, 0));

  // 457 456 ，-=
  const n2 = Atomics.sub(view, 0, 1);
  console.log(n2, Atomics.load(view, 0));

  // 按位与
  const n3 = Atomics.and(view, 0, 0b1111);

  // 按位或
  const n4 = Atomics.or(view, 0, 0b0101);

  // 按位异或
  const n5 = Atomics.xor(view, 0, 0b0011);

  // 阻塞、唤起线程 ------------------------------------------------------------------
  /**阻塞 worker 并等待 notify
   * 仅在 worker 可用，主线程无法使用；主线程可以使用 ES15 的 Atomics.waitAsync
   * args ：
     - 0：必须是 Int32Array 的 view
     - 1：view index
     - 2：value ，若当前 view index 的 value 与 value 相同，则继续 wait ，直到与 value 不同为止或 timeout 到达
     - 3：timeout ms
   * return ："ok" | "not-equal" | "timeout" ，分别是等待、不等于 value ，超时
   */
  Atomics.store(view, 0, 123);
  const waitTag = Atomics.wait(view, 0, 123, 3000);
  // 3s 后输出 “timeout” ，因为没有其他 worker 改动 sab
  console.log(waitTag);

  /**唤起 wait 的线程
   * args ：
     - 0：view ，必须是 Int32Array
     - 1：view index
     - 2：最多唤起的线程数，默认全部
   * return ：唤起的线程数 
  */
  const num = Atomics.notify(view, 0);
  console.log(num);
});
```

### 3.2 渲染帧

渲染任务的优先级比微任务低，但和宏任务的优先级不好比较，不同浏览器的处理不同，有的比宏任务高，有的在宏任务中间适合的时间段渲染，因此执行顺序不好判断。

浏览器帧数为 60 帧，及约 16.67 ms 为 1 帧，

#### 3.2.1 渲染帧 API

浏览器会分配渲染帧，受到机器环境等因素影响，帧数会有不同，每次渲染帧时间就不同。

（1）API

HTML5 新特性提供了两个渲染帧相关的 API 、、一次渲染帧不一定为 16\.67 ms :

* requestAnimationFrame ：简称 raf，下一帧渲染任务之前回调

* requestIdleCallback ：渲染帧结束后，若此次渲染帧小于 16\.67 ms ，即还有剩余时间，就回调，否则会一直等待有剩余时间的帧结束才会回调；兼容性比 raf 差一点

浏览器在 1 帧中的工作流程；

* 执行 JS ，微任务、宏任务，由于宏任务和渲染任务的执行顺序不确定，所以宏任务也可能在后面的帧执行

* raf 、渲染任务（样式计算、布局、绘制等）

* 剩余的时间肯呢还会执行一些宏任务，最后若还有时间则执行 ric ，没有时间则不执行

* raf 、ric 只能注册在下一帧执行，所以是无法注册第 1 帧的 raf 、ric 的

```
<!DOCTYPE html>
<body></body>

<html lang="en">
  <script>
    requestAnimationFrame(() => {
      console.log("第 2 帧，raf ，准备开始渲染任务");

      requestAnimationFrame(() => console.log("第 3 帧，raf"));

      // 测试 ric ，剩余时间不足则 ric 在第 3 帧执行
      // const now = Date.now();
      // while (Date.now() - now < 2000);
    });

    requestIdleCallback(
      (idleDeadline) => {
        console.log(`第 2 帧结束，且剩余 ${idleDeadline.timeRemaining()} ms`);

        // boolean ，在设置了 timeout ，且超时了才为 true ，用于防止长期挂起
        if (idleDeadline.didTimeout) console.log("强制执行一些自定义逻辑");
      },

      // { timeout: 10 }
    );

    console.log("第 1 帧");

    Promise.resolve().then(() => {
      console.log("第 1 帧，微任务 1");

      Promise.resolve().then(() => {
        console.log("第 1 帧，微任务 2");
      });
    });

    setTimeout(() => console.log("不确定，大概率是第 1 帧，宏任务"));

    // 当前帧只能注册下一帧的 raf 、ric ，弱想每一帧都执行，则需要递归 -----------------------------------
    // let frameCnt = 2;

    // function run(maxFrame) {
    //   if (maxFrame <= 0) return;

    //   requestAnimationFrame(() => {
    //     console.log(`第 ${frameCnt++} 帧 raf`);
    //     run(maxFrame - 1);
    //   });
    // }

    // run(5);

    // raf 、ric 返回 number ，可用于取消 -------------------------------------------------------------------
    // const rafID = requestAnimationFrame(() => console.log("raf"));
    // const ricID = requestIdleCallback(() => console.log("ric"));

    // cancelAnimationFrame(rafID);
    // cancelIdleCallback(ricID);
  </script>
</html>
```

（2）分片任务、分时函数

一帧的任务可能有时候在 16\.67 ms 内就完成了，剩余的时间可以利用起来，只要这一次渲染帧渲染时间 + 剩余时间不超过 16\.67 ms 就不影响流畅度。

封装一个分时函数，如一个耗时很长的任务，可以分片，在剩余时间内执行这些分片：

```
<!DOCTYPE html>
<html lang="en">
  <style>
    #box {
      position: relative;
      margin-top: 100px;
      width: 100px;
      height: 100px;
      border: 1px solid #000;
      border-radius: 50px;
      background-color: red;
    }

    @keyframes move_rule {
      from {
        left: 0;
      }
      to {
        left: 200px;
      }
    }
    #box {
      animation: move_rule 1s alternate infinite ease-in-out;
    }
  </style>
  <body>
    <button id="btn1">执行长任务 (requestIdleCallback)</button>
    <button id="btn2">执行长任务 (requestAnimationFrame)</button>
    <div id="box"></div>
  </body>
  <script>
    const datas = new Array(1000000);
    // const datas = 1000000;

    function performChunk(datas, consumer, chunkSplitor, hasTime) {
      if (typeof datas === "number" && !Number.isNaN(datas)) {
        datas = new Array(datas);
      } else if (!Array.isArray(datas) || !datas.length) datas = [];

      if (typeof consumer !== "function" || !consumer) {
        consumer = () => {};
      }

      if (typeof hasTime !== "function" || !hasTime) {
        // 这里的剩余时间设置 > 0ms ，实际情况需要根据任务的执行情况适当增大剩余时间
        hasTime = (remain) => remain > 0;
      }

      if (typeof chunkSplitor !== "function" || !chunkSplitor) {
        /**
         * 之所以用 while 是因为想在下一帧前，尽量利用空闲时间执执行分片任务
         * 如果分片的任务执行超过了空闲时间，那还是会有卡顿的，不过这是分片没分好的问题了
         */
        chunkSplitor = (datas, startIndex) => {
          let nowIndex = startIndex;

          requestIdleCallback((idle) => {
            while (hasTime(idle.timeRemaining())) {
              if (nowIndex >= datas.length) return;
              consumer(datas[nowIndex++]);
            }

            // console.log("下一个渲染帧");
            chunkSplitor(datas, nowIndex);
          });
        };
      }

      chunkSplitor(datas, 0);
    }

    const btn1 = document.querySelector("#btn1");
    btn1.addEventListener("click", function () {
      performChunk(datas, (nowData) => {
        console.log(nowData);
      });
    });

    // 也可以用 raf 实现，兼容性好 一点 -----------------------------------------------
    const btn2 = document.querySelector("#btn2");

    const consumer = (nowData) => {
      console.log(nowData);
    };

    const hasTime = (remain) => remain < 16.6;

    const chunkSplitor = (
      datas,
      startIndex,
      startTime = new Date().getTime()
    ) => {
      let nowIndex = startIndex;

      requestAnimationFrame(() => {
        while (hasTime(new Date().getTime() - startTime)) {
          if (nowIndex >= datas.length) return;
          consumer(datas[nowIndex++]);
        }

        // console.log("下一个渲染帧");
        chunkSplitor(datas, nowIndex, new Date().getTime());
      });
    };

    btn2.addEventListener("click", function () {
      performChunk(datas, consumer, chunkSplitor, hasTime);
    });
  </script>
</html>
```

分片任务如果环境不支持这两个 API ，就使用 web worker（但无法操作 DOM），再不支持只能用定时器了，但是定时器无法准确在两个渲染帧之间执行任务，就会由卡顿，但至少比直接同步执行好。

（3）性能监控

服务监控，监控用户在使用软件中遇到的问题，提供给后台进行数据分析。

数据埋点是服务监控的其中一个环节，在客户端实现，主要分为：

- 非侵入式：程序错误、性能监控。通常封装为一个库，直接在入口文件调用，不影响原本的代码

- 侵入式：行为监控，用户哪些行为导致不继续使用软件，需要在具体的代码中嵌入，开发成本较高

性能监控的简单实现：

```
<!DOCTYPE html>
<html lang="en">
  <body></body>

  <script>
    function delay(ms) {
      const now = Date.now();
      while (1) {
        if (Date.now() - now >= ms) break;
      }
    }

    // 方式一，监控 FPS ，但很局限，很多用户感受的卡顿并不一定是 PDS ，如事件延迟，图片加载，布局等
    function FPSobserver() {
      const now = Date.now();

      requestAnimationFrame(() => {
        if (Date.now() - now > 17) console.log("没有 60 帧");
        FPSobserver();
      });
    }
    // FPSobserver();

    // 方式二，推荐使用
    const ob = new PerformanceObserver((list) => {
      // 便利所有需要监控的类型，目前只监控了 longtask
      for (const i of list.getEntries()) {
        console.log(`类型: ${i.entryType}，耗时：${i.duration} ms`);

        // 如果耗时过长，就判定为卡顿，上报监控中心
        if (i.duration > 100);
      }
    });

    // 配置
    ob.observe({
      // 监控类型，其他类型查阅文档
      entryTypes: ["longtask"],
    });

    delay(3000);
    console.log(123);

    // 网络监控 -----------------------------------------------------------------------------
    function getNetworkInfo() {
      let info;

      if (navigator.onLine) {
        info = {
          type: navigator.connection.effectiveType,
          rtt: navigator.connection.rtt,
          downlink: navigator.connection.downlink,
        };
      } else info = { type: "offline" };

      return info;
    }

    // 分别是在线、离线、改变网络类型触发
    window.addEventListener("online", function (e) {});
    window.addEventListener("offline", function (e) {});
    navigator.connection.addEventListener("change", function (e) {});

    setInterval(() => {
      console.log(getNetworkInfo());
    }, 1000);
  </script>
</html>
```

#### 3.2.2 动画

动画的本质就是数值的变化，因此无论是 JS 还是 CSS 动画，都只能以数值变化作为动画的基础：

```
.box {
  width: 10px;
  border: 1px solid #000;
  background-color: blue;
  transition: all 1s;
}

.box-click {
  /* 这些都有数值变化，就有动画 */
  width: 100px;
  border-width: 0;
  background-color: red;
  transform: translate((100px, 100px));

  /* 没有数值变化就不能做动画 */
  display: none;

  /* 复合属性需要注意，要么写全，要么单独写数值属性 */
  /* 没有动画 */
  /* border: 0; */
  border-width: 0;
  border: 0 solid #000;
}
```

虽然 CSS 动画已经很强大，但一些情况下还是需要 JS 做动画，如修改元素的内容，现在 JS 动画主要通过渲染帧 API 或 Web Animation API 实现，都是 HTML5 新特性。

（1）CSS 动画

分为触发型、自动型：

- transition 只能制作触发型的动画，且只能规定 2 个状态的变化

- animation 触发型、自动型都可以，且可以规定多个状态的变化

transition 过度：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        border: 1px solid #000;
        width: 100px;
        height: 100px;
        background-color: #000;

        /* 1s 后，用 ease 方式过渡 2s width */
        /* transition: width 2s ease 1s; */

        /* 只有过渡时间是必须写的，也可以用 ms */
        /* transition: 2s; */

        /* 多个属性的过渡，不写默认就是 all */
        /* transition: all 2s; */
        transition: width 2s, height 10s, background-color 1s;
      }

      .box:hover {
        width: 200px;
        height: 200px;
        background-color: red;
      }
    </style>
  </head>
  <body>
    <div class="box"></div>
  </body>
</html>
```

animation 动画：

animation 通过 keyframs（关键帧）设置的状态进行动画，如下是一个自动型的动画：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        border: 1px solid red;
        width: 100px;
        height: 100px;
        border-right-color: red;
        animation: box-move 3s alternate infinite;
      }

      @keyframes box-move {
        /* from 可以省略 */
        /* 可以用 n% 替代 from，to 来设置多个状态 */

        from {
          transform: translate(0);
        }

        to {
          transform: translate(200px);
        }
      }
    </style>
  </head>
  <body>
    <div class="box"></div>
  </body>
</html>
```

（2）渲染帧实现动画

JS 动画不能使用定时器 setInterval 定时 16\.67 ms 。因为浏览器会受到机器配置、卡顿等各种原因导致浏览器分配的渲染帧并不平均，就会导致空帧（小于 16\.67 ms ，多个渲染帧没有做任何动画）和跳帧（大于 16\.67 ms ，一个渲染帧做了多次动画，只保留了最后一个动画），

下面虽然使用了 raf 和 transform ，但 raf 终究是工作在渲染主线程中，还是会有阻塞渲染的风险：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      .container {
        width: 500px;
        height: 200px;
        border: 1px solid #000;
      }
      .box {
        top: -1000px;
        width: 20px;
        height: 20px;
        border: 1px solid #000;
        border-radius: 10px;
        background-color: #000;
        line-height: 20px;
        text-align: center;
        font-size: 10px;
      }
    </style>
  </head>

  <body>
    <div>
      <button class="btn1">start</button>
      <span class="price">9999</span>
    </div>

    <div>
      <button class="btn2">start</button>
      <div class="container">
        <div class="box"></div>
      </div>
    </div>
  </body>

  <script>
    // 柯里化
    function currv(fn, ...preArgs) {
      return (...args) => {
        const totalArgs = [...preArgs, ...args];

        // 如果参数足够 fn 使用，就调用 fn
        if (totalArgs.length >= fn.length) return fn.apply(this, totalArgs);
        // 否则继续 currv
        else return currv.call(this, fn, ...totalArgs);
      };
    }

    // 内置的变化曲线
    const defaultTimeMethods = {
      // 匀速运动
      default(duration, from, to) {
        const speed = (to - from) / duration;

        return currv(function (speed, time) {
          return speed * time;
        }, speed);
      },
    };

    // 动画 ----------------------------------------------------------------------------
    function animation(duration, from, to, onProerese, timeMethods) {
      if (!Array.isArray(from)) from = [from];
      if (!Array.isArray(to)) to = [to];
      if (!Array.isArray(timeMethods)) timeMethods = [timeMethods];

      const startTime = Date.now();
      const that = this;

      // 变化曲线
      const methods = from.map((f, i) => {
        if (typeof timeMethods[i] === "function") return timeMethods[i];
        else {
          return (
            defaultTimeMethods[timeMethods[i]]?.(duration, f, to[i]) ||
            defaultTimeMethods["default"](duration, f, to[i])
          );
        }
      });

      // 开始动画
      function _run() {
        requestAnimationFrame(function () {
          const now = Date.now();
          if (now - startTime >= duration) {
            onProerese && onProerese.call(that, ...to);
            return;
          }

          onProerese &&
            onProerese.call(
              that,
              ...methods.map((getValue, index) => {
                return from[index] + getValue.call(that, now - startTime);
              })
            );

          _run();
        });
      }

      _run();
    }
    // -------------------------------------------------------------------------------

    const btn1 = document.querySelector(".btn1");
    const price = document.querySelector(".price");

    btn1.addEventListener("click", function () {
      const from = Number(price.textContent);

      animation(3000, from, 99, function (to) {
        price.textContent = Math.round(to);
      });
    });

    const btn2 = document.querySelector(".btn2");
    const container = document.querySelector(".container");
    const box = document.querySelector(".box");

    const duration = 10000;
    box.textContent = Number.parseInt(duration / 1000);

    btn2.addEventListener("click", function () {
      const boxRect = box.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();

      const toX = containerRect.width - boxRect.width;
      const toY = containerRect.height - boxRect.height;

      const seconds = duration / 1000;
      const acc = (2 * toY) / (seconds * seconds);

      // 水平匀速运动，垂直加速运动
      animation(
        duration,
        [0, 0, duration],
        [toX, toY, 0],

        function (x, y, remainTime) {
          x = Number.parseInt(x);
          y = Number.parseInt(y);

          remainTime = (remainTime / 1000).toFixed(1);
          box.textContent = remainTime;

          box.style.transform = `translate(${x}px, ${y}px)`;
        },

        [
          "default",
          function (time) {
            const seconds = time / 1000;
            return (acc * seconds * seconds) / 2;
          },
          "default",
        ]
      );
    });
  </script>
</html>
```

（3）Web Animation API 

性能接近 CSS3 动画，通过 keyframs 实现，而不是修改 DOM 的 style ：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      .box {
        width: 100px;
        height: 100px;
        border: 5px solid #000;
        border-radius: 50px;
      }
    </style>
  </head>
  <body>
    <div class="box"></div>
  </body>

  <script>
    const box = document.querySelector(".box");

    window.addEventListener("click", function (e) {
      const x = e.clientX - box.offsetWidth / 2;
      const y = e.clientY - box.offsetHeight / 2;
      const { left, top } = box.getBoundingClientRect();

      // 动画对象会保存，为了防止对象越来越多，可以手动删除不用的动画对象
      // console.log(box.getAnimations().length);
      box.getAnimations().forEach((i) => i.cancel());

      /**两个参数
       * keyframs ，默认不用写百分比，会平均分配，也可以用 offset 设置百分比（0 ~ 1）
       * animation options ，可以写一个 ms 数值，也可以写一个对象
       */
      box.animate(
        [
          {
            transform: `translate(${left}px, ${top}px)`,
          },
          {
            transform: `translate(${left}px, ${top}px) scale(2)`,
            offset: 0.5,
          },
          {
            transform: `translate(${x}px, ${y}px)`,
          },
        ],
        {
          duration: 1000,
          fill: "forwards",
        }
      );
    });
  </script>
</html>
```

（4）Flid 动画

First Last Invert Play，一种元素结构变化的动画解决方案，元素结构变化是非数值变化，一般无法做动画，而 flip 的思路是先记录 first 的偏移，元素结构变化后根据 last 偏移和 first 偏移计算变化偏移，在渲染之前移动到 first 位置，再动画移动到 last 位置，形成偏移数值的变化，就能做动画，Vue 的 transition 组件用的就是 flip ：

```
// flip.js

class Flip {
  constructor(dom, duration = ".5s") {
    this.#duration = typeof duration === "number" ? `${duration}s` : duration;
    this.#init(dom);
  }

  #dom = [];
  #duration = "";

  #getPosition(el) {
    const rect = el.getBoundingClientRect();

    return {
      x: rect.left,
      y: rect.top,
    };
  }

  #createDomInfo(dom) {
    return {
      el: dom,
      transition: `${getComputedStyle(dom).transition},transform ${
        this.#duration
      }`,
      firstPos: this.#getPosition(dom),
    };
  }

  // 获取初始偏移
  #init(dom) {
    if (!dom) return;

    if (!dom.length) {
      this.#dom.push(this.#createDomInfo(dom));
      return;
    }

    for (const el of dom) this.#dom.push(this.#createDomInfo(el));
  }

  // 获取变化后的偏移，并开始动画
  play(options = {}) {
    const defaultOptions = {
      refresh: true,
    };
    const { refresh } = { ...defaultOptions, ...options };

    for (const info of this.#dom) {
      const { el, firstPos } = info;

      const { x, y } = this.#getPosition(el);
      const dx = firstPos.x - x;
      const dy = firstPos.y - y;

      // 如果需要刷新新位置
      if (refresh) info.firstPos = { x, y };

      // 此时还没有到渲染任务，先让元素回到原来的位置
      el.style.removeProperty("transition");
      el.style.transform = `translate(${dx}px, ${dy}px)`;

      // 在回到目标位置，形成数值的变化，就可以做动画了
      requestAnimationFrame(() => {
        el.style.transition = info.transition;
        el.style.removeProperty("transform");
      });
    }
  }

  // 有时候外部可能需要手动刷新新位置
  refreshPosition(el, x, y) {
    if (!el) {
      for (const info of this.#dom) info.firstPos = this.#getPosition(info.el);
      return;
    }

    const info = this.#dom.find((i) => i.el === el);
    if (info) info.firstPos = { x, y };
  }
}
```

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      .item {
        margin: 20px 0;
        height: 50px;
        border: 5px solid #fff;
        line-height: 50px;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="box">
      <div class="item">1</div>
      <div class="item">2</div>
      <div class="item">3</div>
      <div class="item">4</div>
      <div class="item">5</div>
    </div>

    <button id="btn">click</button>
  </body>

  <script src="./flip.js"></script>

  <script>
    const btn = document.querySelector("#btn");
    const items = document.querySelectorAll(".item");
    const flip = new FliP(items);

    btn.addEventListener("click", function () {
      // 乱序
      for (const item of items) {
        const index = Number.parseInt((Math.random() * 10) / 2);
        item.parentElement.insertBefore(item, items[index]);
      }

      flip.play();
    });
  </script>
</html>
```

若 flip 都无法实现动画，如一个下拉框，可以通过 jS 获取 auto 后的 height 数值，再修改成 0 再修改成 height ，虽然能实现效果，但是会有多次 reflow 。

另一种方法是过渡 transform 的 scale ，实现简单，性能也高，但效果有一些差异：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .dropdown {
        --selector-padding: 10px;
        --selector-height: 30px;
        --option-item-height: 25px;

        position: relative;
        width: 200px;
      }

      .dropdown > .selector {
        padding: 0 var(--selector-padding);
        border: 1px solid #000;
        height: var(--selector-height);
        line-height: var(--selector-height);
        user-select: none;
      }

      .dropdown > .option {
        position: absolute;
        top: calc(var(--selector-height) + 5px);
        left: 0;
        border: 1px solid #000;
        padding: var(--selector-padding) 0;
        width: 100%;
        transform: scale(0);
        transform-origin: top;
        transition: all 0.3s;
      }

      .dropdown > .option > .option-item {
        padding: 0 var(--selector-padding);
        height: var(--option-item-height);
        line-height: var(--option-item-height);
        cursor: pointer;
        transition: all 0.3s;
      }

      .dropdown > .option > .option-item:hover {
        background-color: orange;
      }
    </style>
  </head>
  <body>
    <div class="dropdown">
      <div class="selector">dropdown</div>
      <div class="option">
        <div class="option-item">item 1</div>
        <div class="option-item">item 2</div>
        <div class="option-item">item 3</div>
        <div class="option-item">item 4</div>
        <div class="option-item">item 5</div>
      </div>
    </div>
  </body>
  <script>
    const selector = document.querySelector(".selector");
    const option = document.querySelector(".option");

    function hiddenOption() {
      option.style.transform = "scale(0)";
      window.removeEventListener("click", hiddenOption);
    }

    function selectorClick(event) {
      event.stopPropagation();

      if (option.style.transform === "scale(1)") {
        option.style.transform = "scale(0)";
        return;
      }

      option.style.transform = "scale(1)";

      window.addEventListener("click", hiddenOption);
    }

    selector.addEventListener("click", selectorClick);
  </script>
</html>
```

（5）transition 、animation 事件

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      .box {
        width: 100px;
        height: 100px;
        border: 10px solid #000f;
        transition: all 1s;
      }

      .box:hover {
        border-radius: 50px;
      }

      @keyframes box-move {
        to {
          transform: translateX(200px);
        }
      }
    </style>
  </head>

  <body>
    <div class="box"></div>
    <button class="btn">animation</button>
    <button class="btn">Web Animation API</button>
  </body>

  <script>
    const box = document.querySelector(".box");
    const btn = document.querySelectorAll(".btn");

    btn[0].addEventListener("click", function (e) {
      // box.style.animation = "box-move 1s alternate infinite";
      box.style.animation = "box-move 1s";
    });

    /**transition 事件 -----------------------------------------------------------
     * 复合属性汇执行多次，如 border-radius 会执行 4 次
     */

    // 取消 transition 后执行
    box.addEventListener("transitioncancel", function (e) {
      console.log("transition cancel");
    });

    // start 执行，若 cancel 后未恢复原始状态就 statr 也会执行
    box.addEventListener("transitionstart", function (e) {
      console.log("transition start");
    });

    // end 执行
    box.addEventListener("transitionend", function (e) {
      console.log("transition end");
    });

    /**animation 事件 -----------------------------------------------------------------
     * 赋合属性只触发一次
     * 只有 CSS 的 animation 会触发，Web Animation API 不会
     */

    box.addEventListener("animationcancel", function (e) {
      console.log("animation cancel");
    });

    box.addEventListener("animationstart", function (e) {
      console.log("animation start");
    });

    box.addEventListener("animationend", function (e) {
      console.log("animation end");
    });

    /**Web Animation API ------------------------------------------------------------------
     * 通过返回的 animation 对象实现，复合属性只执行一次
     */

    btn[1].addEventListener("click", function (e) {
      const animation = box.animate(
        [
          {
            transform: "translateY(200px)",
          },
        ],
        {
          duration: 1000,
          fill: "forwards",
        }
      );

      // 方式 1：使用 Promise
      animation.finished.then((e) => {
        console.log("wa finish");
      });

      // 方式 2：使用事件回调
      animation.onfinish = (e) => {};
    });
  </script>
</html>
```

### 3.3 浏览器渲染原理

渲染，将一个 HTML 字符串（HTML 文档）转变成页面像素信息的过程。

#### 3.3.1 解析 HTML

最终生成 DOM 树（DOM Object Model ）、SOM 树（CSS Object Model ），都是对象，方便后续处理，同时让 JS 有操作 HTML 、CSS 的能力。

JS 不会生成一个树，因为 JS 只执行一次就行了，异步也有事件循环处理。

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      .box {
        font-size: 50px;
      }
    </style>
  </head>
  <body>
    <div class="box" style="font-weight: 700">123</div>
  </body>

  <script>
    // DOM 树根节点，即 <html>
    console.log(document.documentElement);

    // SOM 树，根结点保存了一个存储各个样式表的数组，得到样式表后，除了默认样式表外都可以 CURD选择器、属性等
    // 获取内联样式表
    console.log(document.querySelector(".box").style);
    // 获取内部样式表、外部样式表形成的数组
    console.log(document.styleSheets);
  </script>
</html>
```

（1）解析 HTML 字符串

浏览器的网络进程拿到 HTML 文档后，产生一个渲染任务，交给渲染主线程的消息队列，在事件循环机制的作用下，渲染主线程取出渲染任务并处理：

```
const html = "<div>...</div>";
```

渲染主线程解析 HTML 字符串：

```
const doc = new DOMParser().parseFromString("<div>123</div>", "text/html");

// 123;
console.log(doc.body.textContent);
```

当解析到 \<style\> 和 \{link\> 的 CSS 时，会交给渲染进程中的预解析现成异步解析 CSS ，解析完成后再交给渲染主线程去生成 SOM 树，所以 CSS 不会阻塞 HTML 的解析。

而解析到 \<script\> 时，虽然也会交给预解析线程、网络线程去异步解析下载，但是渲染主线程会停止工作，等待 JS 下载执行完毕，形成同步的效果；之所以解析 JS 不是异步的，是因为 JS 可能修改 DOM 。

因此 JS 就会造成渲染主线程的阻塞：

```
const html = `
<!DOCTYPE html>
<html lang="en">
  <head>
    预解析现成异步解析 CSS
    <style></style>
    <link />

    渲染主线程同步下载或执行 JS
    <script></script>
  </head>
  <body></body>
</html>
`;
```

（2）资源提示符

HTML5 新特性，指定资源如何加载：

* \<script\> 的 async 、defer ，解析下载 JS 时不在停止渲染主线程工作：
  
  ```
  // 1.js ，死循环 3s
  const now = Date.now();
  
  while (1) {
    if (Date.now() - now >= 3000) break;
  }
  ```
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <!-- 会阻塞渲染主线程 -->
    <!-- <script src="./1.js"></script> -->
  
    <!-- async 、defer 只有存在 src 时才生效 ---------------------------------------->
    <!-- async
      * 异步下载，下载完马上在渲染主线程执行，若此时 html 还未渲染完就会阻塞
      * 每个 script 下载完的时间不同，所以 script 顺序会改变 
      * 适用于独立脚本，如广澳
    -->
    <!-- <script async src="./1.js"></script> -->
  
    <!-- 
      * 异步下载异步执行
      * script 顺序不变，全部 defer script 都会在 DOMContentLoader 之前下载完成并执行
      * 适用于依赖 DOM 的 JS 
    -->
    <script defer src="./1.js"></script>
    <body>
      123
    </body>
  </html>
  ```

* \<link\> 的 preload 、prefetch ，使得 \<link\> 可以引入任何资源包括 JS ，效果是预加载资源，未来直接使用缓存，区别在于优先级不同：
  
  ```
  // home.js
  console.log("home");
  ```
  
  ```
  // about.js
  console.log("about");
  ```
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <!-- preload 、prefetch 的资源都只是预加载到缓存，不会执行，只有用到了才会执行 -->
  
      <!-- preload 优先级高，优先下载，适合在本页就需要用到的资源 -->
      <link rel="preload" as="script" href="./home.js" />
      <link rel="preload" as="image" href="./home.jpg" />
  
      <!-- prefetch 优先级低，只有在浏览器空闲时才下载，适合预加载非本页的资源 -->
      <link rel="prefetch" as="script" href="./about.js" />
      <link rel="prefetch" as="image" href="./about.jpg" />
  
      <!-- 提前预加载 type="module" 的 script ，没有 moduleprefetch -->
      <!-- <link rel="modulepreload" href="/scripts/utils.js" /> -->
    </head>
  
    <body>
      <button class="btn">home</button>
      <button class="btn">about</button>
    </body>
  
    <script>
      function render(name) {
        location.hash = name;
  
        const div = document.createElement("div");
        const script = document.createElement("script");
        const img = document.createElement("img");
  
        div.textContent = name;
        script.src = `./${name}.js`;
        img.src = `./${name}.jpg`;
  
        div.className = name;
        script.className = `${name}-js`;
        img.className = `${name}-img`;
  
        document.body.appendChild(div);
        document.documentElement.appendChild(script);
        document.body.appendChild(img);
      }
  
      function destroy(name) {
        const div = document.querySelector(`.${name}`);
        const script = document.querySelector(`.${name}-js`);
        const img = document.querySelector(`.${name}-img`);
  
        document.body.removeChild(div);
        document.documentElement.removeChild(script);
        document.body.removeChild(img);
      }
  
      render("home");
  
      const btn = document.querySelectorAll(".btn");
  
      btn[0].addEventListener("click", () => {
        if (location.hash === "#home") return;
  
        destroy("about");
        render("home");
      });
  
      btn[1].addEventListener("click", () => {
        if (location.hash === "#about") return;
  
        destroy("home");
        render("about");
      });
    </script>
  </html>
  ```

* 网络相关：
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <!-- DNS 与解析 -->
      <link rel="dns-prefetch" href="//example.com" />
  
      <!-- 建立与服务器的早期连接，包括 DNS 查询、TLS 握手和 TCP 握手。 -->
      <link rel="preconnect" href="https://example.com" />
      <!-- 可选：crossorigin 属性用于跨域连接 -->
      <link rel="preconnect" href="https://cdn.example.com" crossorigin />
    </head>
    <body></body>
  </html>
  ```

* prerender ，预加载整个页面，性能较差，用于加载下一个较大的页面，不常用：
  
  ```
  <link rel="prerender" href="https://example.com/next-page">
  ```

（3）重新加载

可以监听 error 事件，当资源加载失败时，重新请求（暂未处理有资源提示符的情况）；

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <script>
      /**JS 执行方式
       * eval() 没有独立的作用域
       * new Function() 有独立的作用域
       * js 写入到 <script> 的 textContent
       */
      function runJS(jsCodeString, parent, before) {
        const script = document.createElement("script");
        script.textContent = jsCodeString;
        parent.insertBefore(script, before);
      }

      /**同步请求 JS
       * document.write() ，不推荐
       * xhr 同步请求
       *
       */
      function xhrSyncRequestJS(url, parent) {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url, false);

        try {
          xhr.send();

          if (xhr.status === 200) return xhr.responseText;
          else return new Error("xhrSyncRequestJS err");
        } catch {
          return new Error("xhrSyncRequestJS err");
        }
      }
    </script>

    <script>
      // 每个域名的最大重发次数
      const maxRetry = 1;

      // 备用域名
      const domains = {
        SCRIPT: [...new Set(["a.com", "localhost:3000"])],
        LINK: [...new Set(["b.com", "localhost:3000"])],
        IMG: [...new Set(["c.com", "localhost:3000"])],
      };

      // 保存重发的状态，type ：{ href: { cnt, domainIndex } }
      const retry = {};
      function createRetryKey(key, cnt = 0, domainIndex = -1) {
        retry[key] = retry[key] ?? {
          cnt,
          domainIndex,
        };
      }

      // 核心代码
      function toRetry(target, tagName, urlKey, url) {
        const parent = target.parentElement;

        // script 需要保证执行顺序
        if (tagName === "script" && !target.async && !target.defer) {
          const res = xhrSyncRequestJS(url);

          if (res instanceof Error) {
            target.src = url;
            res.target = target;
            retryCallback(res);
          } else {
            runJS(res, parent, target);
            parent.removeChild(target);
          }
        } else {
          // 必须是一个新的元素才会重新请求，修改 src 、href 不行
          // 之所以不直接用 cloneNode ，是因为这样 <script> 不会重新请求（但 <link> 可以），所以就创建新元素
          const el = document.createElement(tagName);
          for (const attr of target.attributes) {
            el.setAttribute(attr.name, attr.value);
          }
          el[urlKey] = url;

          parent.insertBefore(el, target);
          parent.removeChild(target);
        }
      }

      // 任何 err 都会触发 error 事件，如 JS 错误，可以判断 e 是哪个 Error 类型
      function retryCallback(e) {
        // 同步请求的 err 会立刻触发 error ；异步请求的 err 则需要执行完全部同步 error 才会执行
        // console.log("err");

        // JS 内部错误的类型是 ErrorEvent ；CSS 内部错误不会触发 error ，就不管了
        if (e instanceof ErrorEvent) return;

        // 重新请求，这里就只处理 <script> 、 <link> 和 \<img> 了
        if (!["SCRIPT", "LINK", "IMG"].includes(e.target.tagName)) return;

        const {
          target,
          target: { tagName },
        } = e;
        const urlKey = target.src ? "src" : "href";
        const url = new URL(target[urlKey]);

        createRetryKey(url.href);
        let nextDomainIndex = retry[url.href].domainIndex + 1;

        // 重新请求
        if (retry[url.href].cnt < maxRetry) ++retry[url.href].cnt;
        else {
          // 若下一个域名还是相同的，就跳过
          if (url.host === domains[tagName][nextDomainIndex]) {
            ++retry[url.href].domainIndex;
            ++nextDomainIndex;
          }

          // 如果还有未尝试的域名，就继续
          if (nextDomainIndex < domains[tagName].length) {
            url.port = "";
            url.host = domains[tagName][nextDomainIndex];
            createRetryKey(url.href, 1, nextDomainIndex);
          } else return;
        }

        toRetry(target, tagName.toLowerCase(), urlKey, url.toString());
      }

      /**error
       * 为了方便，直接给 window 绑定 error 事件
       * 但 error 默认仅在 JS 内部错误才冒泡，请求 err 不冒泡，这里就把参数设为 true ，在捕获阶段触发
       */
      window.addEventListener("error", retryCallback, true);

      // retry 新增的资源在 DOMContentLoader 之后，load 之前加载
      // window.addEventListener("DOMContentLoaded", () => console.log("DOMContentLoaded"));
      window.addEventListener("load", () => {
        window.removeEventListener("error", retryCallback);
      });
    </script>

    <!-- <link rel="stylesheet" href="http://xxx.com:3000/1.css" /> -->

    <script src="http://xxx.com:3000/1.js"></script>
    <script src="http://localhost:3000/2.js"></script>
  </head>

  <body>
    <p>qwer</p>
    <!-- <img src="http://xxx.com/1.jpg" /> -->
    <p>asdf</p>
  </body>
</html>
```

#### 3.3.2 样式计算、布局、分层、生成绘制指令

（1）样式计算

最终生成渲染树。

遍历 DOM 树，每个结点进行样式计算，得到每个节点计算后的最终的样式 computed style（所有 CSS 属性都要有 value ，且都是绝对单位，如 em 变 px ，string 的 color 变 rgb\(\)），最后生成渲染树：

```
// 得到计算后的样式
getComputedStyle();
```

（2）生成布局树

最终生成布局树。

Layout Tree ，有些 CSS 属性值如百分比， auto 到这里才能计算出来，content 的大小也在这里根据盒子模型进行计算。

遍历 DOM 树，根据样式计算出几何信息（尺寸、相对于包含块的位置），得到布局树，大部分时候 DOM 树和布局树会不同，因为：

- 隐藏的节点如 \<head\> 没有几何信息，不会出现在布局树中

- 伪元素是 CSS 产生的，不会出现在 DOM 树中，但会出现在布局树中

- 内容只能在行盒中，行盒、块盒不能在同一级，若出现了这些情况，布局树中会用匿名行盒、匿名快盒填充，这些匿名盒子是不会渲染的

布局中的对象也不是 DOM 对象，而是如浮动对象、flex 对象等，这些对象无法用 JS 获取，但是可以获取部分信息：

```
// offset 、client 、scroll 获取的都是布局树的信息
console.log(body.clientWidth);
```

（3）分层

渲染主线程使用一条复杂的规则进行分层，好处是在将来某一层改变时仅会处理该层，提升性能，但分层不会太多，因为会加大内存消耗，具体分几层由浏览器决定：

```
.box {
  /* 堆叠上下文的属性可能会影响分层，是否分层浏览器视情况而定，如以下属性 */
  opacity: 1;
  z-index: 9;
  transform: translate(-50%, -50%);

  /* 这个属性告诉浏览器可能会经常变动，需要单独分一层，但具体分不分，由浏览器决定 */
  /* 不要滥用，分层太多也不好 */
  will-change: transform;
}
```

（4）生成绘制指令

每一层单独生成绘制指令集，用来描述这一层如何绘制。

canvas 用的就是浏览器提供的绘制指令。

关于回流、重绘：

* 重绘（repaint）：当修改非几何属性如 color ，就引起 repaint ，在渲染流程中，重新计算样式后，跳过布局阶段，可能重新分层，一定生成新的绘制指令
- 回流（reflow）：也叫重排，当修改了几何属性后或新增、删除、移动元素、修改元素位置，就会 reflow ，渲染过程中和 repaint 唯一不同的就是会更新布局树，性能较差，所以 reflow 一定会 repaint ，反之不会
- 浏览器为了提高性能，会有类似防抖的处理，只保留最后一次样式的修改，防止多次无异议的渲染任务

强制 reflow 、repaint ：

* 渲染任务是异步的，当读取元素的几何信息（强制 reflow），非几何信息（强制 repaint），浏览器为了得到最新的样式信息，就会同步渲染

* 常用于处理过渡效果，transition 需要从一个状态过度到另一个状态，如果初始就是最终状态如创建新元素并设置样式再异步渲染，就没有过度效果，此时就可以用强制 reflow 、强制 repaint 同步渲染一次，再修改样式即可；
  
  更好的方式是使用 raf ，在渲染一次后，再在下一帧修改样式

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      .box {
        font-size: 10px;
        transition: all 3s;
      }

      .text {
        font-size: 50px;
      }
    </style>
  </head>

  <body>
    <div>
      <button id="btn1">回流、重绘</button>
      <button id="btn2">强制回流、重绘</button>

      <div>
        <span class="text">456</span>
        <button id="btn3">变小后变大</button>
      </div>
    </div>
  </body>

  <script>
    var btn1 = document.querySelector("#btn1");
    var btn2 = document.querySelector("#btn2");
    var btn3 = document.querySelector("#btn3");
    const text = document.querySelector(".text");

    function addBox() {
      const box = document.createElement("p");
      box.textContent = "123";
      box.className = "box";
      document.body.appendChild(box);

      return box;
    }

    // reflow 、repaint ，浏览器为了提高性能，会把相邻的样式修改作为同一个渲染任务，防止多次不必要的 reflow 、repaint
    btn1.addEventListener("click", function () {
      // 效果：transition 无效，原因是 addBox 和修改字体大小都异步 reflow ，只保留了最后一次字体大小修改，因此等价于创建 box 时  font-size 就是 50px
      const box = addBox();

      // reflow
      box.style.fontSize = "40px";
      box.style.fontSize = "50px";

      // repaint ，同理
      // box.style.backgroundColor = "#0f0";
      // box.style.backgroundColor = "#000";
    });

    // 强制 revlow 、repaint ，transition 生效
    btn2.addEventListener("click", function () {
      const box = addBox();

      // 强制 reflow ，先渲染一次
      box.offsetWidth;

      // reflow ，再异步渲染一次
      box.style.fontSize = "50px";

      // 强制 repaint ，同理
      // getComputedStyle(box).backgroundClip;
      // box.style.backgroundColor = "#000";

      // 更好的方式是使用 raf ，效率高，当前帧渲染完成后，再下一帧修改样式
      // requestAnimationFrame(() => {
      // box.style.fontSize = "50px";
      // box.style.backgroundColor = "#000";
      // });
    });

    // transition 同一时段只能有一次状态过度
    btn3.addEventListener("click", function () {
      // 效果：只有从 50px 到 100px ，没有 50px 到 25px 的过度
      // text.style.fontSize = "25px";
      // text.style.transition = "all 1s";
      // requestAnimationFrame(() => {
      //   text.style.fontSize = "100px";
      // });

      // 解决方法：先不设置 transition（设置了就去掉），到了第二段才开始动画
      text.style.fontSize = "25px";
      text.style.transition = "";

      requestAnimationFrame(() => {
        text.style.fontSize = "100px";
        text.style.transition = "all 1s";
      });
    });
  </script>
</html>
```

添加 DOM 的性能：

```
<!DOCTYPE html>
<html lang="en">
  <body></body>
  <script>
    // 方式一，性能最低，因为要从解析字符串开始
    var div1 = "<div>1</div>";
    document.body.innerHTML = div1;

    // 方式二，性能一般
    var div2 = document.createElement("div");
    div2.textContent = "2";
    document.body.appendChild(div2);

    // 方式三，性能最高，先存储在文档片段中，再一次性 appendChild
    // 文档片段自身不会被渲染
    var frag = document.createDocumentFragment();
    var div3 = document.createElement("div");
    div3.textContent = "3";
    frag.appendChild(div3);
    document.body.appendChild(frag);
  </script>
</html>
```

#### 3.3.3 合成线程

至此，渲染主线程工作结束，将每层的绘制指令交给渲染进程的合成线程。

（1）合成线程

* 分块：合成线程从线程池中启动多个线程，共同将每一层分成一个个小块，并把每一个小块交给 GPU 进程进行光栅化

* 光栅化：生成包含像素信息的位图（优先光栅化视口附近的分块），交换给合成线程，合成线程生成指引信息（指引把位图花在屏幕的位置），交给硬件

关于浏览器滚动：

浏览器滚动不会修改任何 DOM 和样式，只在合成线程中再次分块、光栅化就行，所以不会被 JS 阻塞，也不会回流重绘。

（2）transform

transform 都是对位图的数学矩阵运算，这个过程其实就发生在合成线程的光栅化，且 GPU 处理矩阵运算效率很高，整个过程都不会再渲染主线程中，不会回流重绘、所以性能很高。

transform 后的信息只能通过 getBoundingClientRect 获取。

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      .container {
        position: relative;
        width: 1000px;
        height: 500px;
        border: 1px solid #000;
      }

      .box {
        position: relative;
        margin-top: 100px;
        width: 100px;
        height: 100px;
        border: 1px solid #000;
        border-radius: 50px;
        background-color: red;
      }

      @keyframes move1 {
        to {
          transform: translate(200px);
        }
      }

      @keyframes move2 {
        from {
          left: 0;
        }
        to {
          left: 200px;
        }
      }

      /* 不会卡死，不 reflow 、repaint ，又不在渲染主线程 */
      .box1 {
        animation: move1 1s alternate infinite ease-in-out;
      }

      /* 卡死，引发了 reflow ，又在渲染主线程 */
      .box2 {
        animation: move2 1s alternate infinite ease-in-out;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div><button id="btn">卡死 3s</button></div>
      <div class="box box1"></div>
      <div class="box box2"></div>
    </div>
  </body>
  <script>
    function delay(ms) {
      var start = Date.now();
      while (Date.now() - start < ms) {}
    }

    var btn = document.querySelector("#btn");

    btn.addEventListener("click", function () {
      delay(3000);
    });
  </script>
</html>
```

# 五、TS

typescript 是 javascript 的超集，具有类型检查等功能。

安装；

```
npm install -g typescript @types/node

# 编译 ts 文件
tsc 1.ts
```

ts\-node ，直接编译运行 ts ：

```
npm install -g ts-node

# 运行 ts

ts-node xxx.ts
```

@types/xxx 是类型声明文件，当 TS 需要使用 JS 文件的资源时就需要声明文件，一些老的第三方库没有升级为 TS ，则会提供 @types/xxx ，若没有提供，则需要自己声明：

```
// utils.js
function add(a, b) {
  return a + b;
}
```

```
// 1.ts

import { add } from "./utils.js";

// declare 声明类型
export declare function add(a: number, b: number): number;

console.log(add(1, 2));
```

也可以单独把类型声明放到 \.d\.ts 文件中：

```
// utils.d.ts
export declare function add(a: number, b: number): number;
```

```
// 1.ts ，不需要导入 .d.ts 文件，会自动识别
import { add } from "./utils.js";
console.log(add(1, 2));
```

## 1 类型

### 1.1 基本

type 可以给类型起别名：

```
type Obj = { a: number; b: number };

const obj: Obj = { a: 1, b: 2 };

// err ，type 无法重新赋值，无法输出
// Obj = string;
// console.log(Obj);
```

typeof ，获取变量的类型，但不能获取字面量的类型：

```
let num = 123;
const arr = [1, "a"];
const obj = { a: 1 };
const func1 = () => {};
function func2() {}

// err ，非法，无法用于字面量
// type A0 = typeof { a: 1 };

// err ，非法，不能用于类型
// type A0 = typeof any;

// number
type A1 = typeof num;
// (number | string)[]
type A2 = typeof arr;
// { a: number }
type A3 = typeof obj;

// () => void
type A4 = typeof func1;
type A5 = typeof func2;

// class
class A {}
type A6 = typeof A;
const B: A6 = class extends A {};
```

（1）JS 类型在 TS 的写法：

```
// 声明变量 --------------------------------------------------------------------------
let num1: number = 1;

// err ，无法赋值不同类型的变量、字面量
// const text: string = num1;

// err ，不同类型无法比较；若实在是有这种场景，就先判断类型
// console.log(num1 === '');

// 但不同类型可以计算
console.log(num1 + "");

// err ，不能把包装类对象赋值给 number 类型
// const num2: number = new Number(3);
// 包装类对象
const numObj: Number = new Number(3);

// 未初始化的变量无法赋值给其他变量
let num3: number;
// err
// let num4 = num2;

// 类型转换
const num5: number = Number("2");

// 其他 -------------------------------------------------------------------------
const str: string = "a";
const bool: boolean = true;
const u: undefined = undefined;
const n: null = null;
const sym: symbol = Symbol();
const b: bigint = 1n;

const obj: { a: number } = { a: 1 };

const arr1: number[] = [1, 2];
const arr2: Array<number> = [1, 2];

function func1(a: number): void {}
const func = function (a: number): number {
  return a;
};
const func3 = (a: number): number => a;
```

（2）TS 中与 JS 略有不同以及新增的类型

字面量类型，字面量类型的值只能是这个字面量，等价于 const ：

```
// 都行，建议用 const
let num1: 123 = 123;
const num2: 123 = 123;
// err
// num1 = 456;
// num2 = 456;

// 注意 let 、const 会影响类型推断的结果
// number 123 ，因为 let 可变所以是 number ，const 不可变就是字面量类型了
let num3 = 123;
const num4 = 123;

// 若 const 变量显示声明了类型，就以这个类型优先
const num5: number = 123;
// err ，正确，因为 number 是大类型，不能赋值给小类型
// const num6: 123 = num5;


// 字面量类型的对象，属性也不能百
const obj: { a: 1 } = { a: 1 };
// err
// obj.a = 2;
// obj = {};

// 其他饮用类型也一样
const tup: [1, 2] = [1, 2];
// err
// tup[0] = 100;
// tup = [];

// 模板字符串也得到字面量类型
type Pre = "my-";
type Item = 1 | 2;
type Name = `${Pre}name-${Item}`;
const a: Name = "my-name-1";
const b: Name = "my-name-2";
```

void 、undefined 、null ：

```
// void 类似 undefined，通常作为函数的空返回类型
const v1: void = undefined;
const func = (): void => {};

// 非严格模式下，也能是 null
const v2: void = null;

// err ，但 void 不等价于 undefined ，undefined 是 void 的子类型
const v: void = undefined;
// const u: undefined = v;
```

any 、unknown ：

```
// any 可以是任何类型，不推荐使用，相当于关闭了类型检查
// 显示 any
const num1: any = "a";
// 隐式 any
let num2;

// unknown 是未知类型，有类型检查，表示开发者保证安全的类型，相当于类型安全的 any
let num3: unknown;
num3 = 1;
num3 = "a";

// unknown 类型无法访问属性，而 any 可以
const obj: unknown = { a: 1 };
// err
// obj.a;

// any 类型的值可以赋值给任何的类型
const n1: number = num1;
// err ，unknown 类型的值只能赋值给 unknown 、any
// const n2: number = num3;

// 若 unknown 想要赋值给其他类型，，可以使用类型断言
const n3 = num3 as number;
const n4 = <number>num3;
```

never ，表示不存在的状态，或永远无法达到的状态，主要有连哥哥作用：

- 作为兜底逻辑，提高代码可维护性

- never 是 TS 中最小的子类型，常用于递归类型工具的结束逻辑（如联合类型转元组），或者用于联合（never 和任何类型联合都不会改变原类型，如元组转联合类型）

```
// type：never ，不存在既是 number 又是 string 的类型
type T = number & string;

// 应用一，作为兜底逻辑，提高代码可维护性 --------------------------------------------------------------
type Method = "GET" | "POST";
// type Method = "GET" | "POST" | "DELETE";

const func1 = (method: Method) => {
  switch (method) {
    case "GET":
      break;
    case "POST":
      break;
    default:
      /**类型收缩，此时 method 类型为 never
       * 未来新增功能，如给 method 联合类型新增一个类型，那么此时 default 就会得到 never | 新类型，而
         在协便机制下，大类型是无法赋值给小类型的，就会 err ，开发者就能知道该修改这里的代码了
       * 由于自己并不能定义一个 never 类型的 value ，所以 never 赋值只能像下面的方式
       */
      const tag: never = method;
      break;
  }
};

// 应用二，实现类型取反 ------------------------------------------------------------------
type Not<T, U> = T extends U ? never : T;

// number 取反，除了 number 的类型都接受
const func2 = <T>(a: Not<T, number>) => {};
func2("a");

// err
// func2(123);

// 应用三，利用 never 是最小子类型的特点,实现一些类型工具 ----------------------------------------
// 联合类型转元组
type GetLast<T> = (
  T extends any ? (x: (x: T) => void) => void : never
) extends (x: infer X) => void
  ? X extends (y: infer Y) => void
    ? Y
    : never
  : never;
type UnionToTuple<T, Last = GetLast<T>> = [T] extends [never]
  ? []
  : [...UnionToTuple<Exclude<T, Last>>, Last];

  // ["a", "b", "c"]
type Tuple = UnionToTuple<"a" | "b" | "c">;

// 元组转联合类型
type TupleToUnion<T> = T extends [...infer Pre, infer Last]
  ? TupleToUnion<Pre> | Last
  : never;

// "a" | "b" | "c"
type Union = TupleToUnion<["a", "b", "c"]>;
```

（3）JS 内置对象的类型

```
const reg: RegExp = /1/;

const date: Date = new Date();
const now: number = Date.now();

const err: Error = new Error();

const set = new Set<number>([1, 2]);
const map = new Map<string, number>([["a", 1]]);

const ite: () => ArrayIterator<number> = [1, 2][Symbol.iterator];

// resolve 参数类型通过泛型传入，reject 则需要声明函数类型；若都不设置则为 any
const p1 = new Promise<number>((resolve, reject: (err: string) => void) => {
  resolve(123);
  // reject("err");
});
const p2: Promise<number> = new Promise(
  (resolve, reject: (err: string) => void) => {
    resolve(123);
    // reject("err");
  }
);

// catch 的类型默认是 unknown ，显示声明只能是 unknown 和 any
async function func() {
  try {
    await p1;
  } catch (err) {}
}
```

（4）DOM 、BOM 类型

```
// body 必然可以获取，不用联合 null
const body: HTMLElement = document.body;

// HTMLElement 是 HTMLDivElement 等的父类型；由于获取元素可能获取不到，所以联合 null
const div1: HTMLElement | null = document.querySelector("#box");
const div2: HTMLDivElement | null = document.querySelector("#box");

const items: NodeList = document.querySelectorAll(".item");

div1!.addEventListener("click", function (e: MouseEvent) {});

const t1: number = setTimeout(() => {});
const t2: ReturnType<typeof setTimeout> = setTimeout(() => {});
```

### 1.2 对象、枚举、数组、函数

注意：

- 对象属性可以使用 readonly 和 ? 修饰，而元组成员只能用 ? 修饰，但元组可以使用 rest
  
  * readonly 为只读，但只是限制属性自身，若属性是引用类型，则不限制成员的修改

- 数组、元组自身可以用 readonly 修饰，但不是表示数组/元组为只读，而是无法增删改成员
  
  * 若对象属性是 readonly 的，但 value 是数组/元组，则 readonly 只作用属性自身，不作用于 value

- 枚举自身可以用 const 修饰

（1）对象

```
const oobj1: object = {};

const obj2: {
  a: number;

  // 只读属性
  readonly b: number;

  // 可选属性，但不等价于 c: number | undefined ，这样就是必选了，至少需要传入 undefined
  c?: number;

  // 若是必选的 never 、undefined 、null 属性，也必须传入
  d?: never;

  /**索引签名
   * 允许添加属性，xxx 可以是任何名字，只是一个描述
   * 索引签名可以用 readonly ，不能用 ?
   * key 的类型：
     - 可以是任何类型，但只是编译时，编译为 JS 后还是只能为 string 、symbol
     - key 不限制赋值时的类型，旨在访问属性时限制传入的 key 类型，比如索引签名 kkey 只有 string 类型
       那么赋值依然可以有 symbol key ，但访问属性时无法传入 symbol key
   * 其他属性 value 的类型必须是索引签名的子类型，如下面的写法是错误的：：
       a?: number;  // 可选属性可能是 undefined
       b: string;   // string 不是 number 的子类型
       [Key: string]: number;
   *  若未来需要删除必选属性，只能定义一个新对象类型
  */
  [xxx: string | symbol]: any;
  // readonly [xxx: string | symbol]: any;

  // 注，上面的联合类型写法是 TS 较新版本的特性，旧版本需要写多个，多个索引签名的 Key 必须是不同类型
  // [xxx: string]: any;
  // [xxx: symbol]: any;
} = { a: 1, b: 2, e: 4 };

// 内置类型，string | number | symbol
type Key = PropertyKey;

// 对象类型通常用 interface 定义，当然也可以用 type
interface Obj {
  a: number;
  [Key: string]: number;
}
```

（2）枚举

枚举enum，适合在几个值选择时使用：

```
// 枚举
enum Method {
  GET = 0,
  POST = 1,
}

// 数字枚举，若不给值，则从 0 开始
enum E1 {
  A,
  B,
  C,
}

// 数字增长枚举，无值的会是上一个值 + 1
enum E2 {
  A = 1,
  B = 5,
  C,
}

// 字符串枚举，每个都必须有值
enum E3 {
  A = "a",
  B = "b",
}

const method: Method = Method.GET;
const e1: E1 = E1.B;
const e2: E2 = E2.C;
const e3: E3 = E3.A;

// 0 1 6 "a"
console.log(method, e1, e2, "a");
```

枚举可以被 const 修饰，不是定义变量的 const ，是类型系统的 const 修饰符：

```
const enum E1 {
  A = 0,
  B = 0,
}

enum E2 {
  A = 0,
  B = 1,
}

const e1: E1 = E1.A;
const e2: E2 = E2.A;

// 编译后不同，const 的枚举其实就是单纯赋值
// var E2;
// (function (E2) {
//   E2[(E2["A"] = 0)] = "A";
//   E2[(E2["B"] = 1)] = "B";
// })(E2 || (E2 = {}));
// var e1 = 0;
// var e2 = E2.A;
```

数字枚举的反向映射：

```
// 编译会有 E1["A"] = "a" 的过程
enum E1 {
  A = "a",
}

// 编译会有 E2[E2["A"] = 0] = "A" 的过程，就形成了反向映射
enum E2 {
  A = 0,
}

// { "a": "A", "A": 0 }
console.log(E2);

// err ，但是无法使用
// const e: E2 = E2["0"];
```

（3）数组

数组、伪数组：

```
// 数组，不定长度 --------------------------------------------------------------------
// 一维数组，[] 更常用，Array 适合复杂的类型，能够一眼看出是数组
const arr1: number[] = [];
const arr2: Array<number> = [];

// 二维数组
const arr3: number[][] = [];
const arr4: Array<Array<number>> = [];

// 多种类型的数组
const arr5: (number | string)[] = [];

// 只读数组，无法增删改成员，但不是自身无法修改
let arr6: readonly number[] = [1];
// err
// arr6[0] = 2;
// ok
arr6 = [1];
arr6 = [2];

// 伪数组 ，number 、string 都行，nember 更直观一点
// arguments 的类型就是 Arguments
type Arr1 = {
  [index: number]: any;
};

// 数组对象都行，只是对象的 key 要写成 number
const arr7: Arr1 = [];
const tup1: Arr1 = [];
const obj1: Arr1 = {};
const obj2: Arr1 = { 0: "a" };

// string 也行
type Arr2 = {
  [index: string]: any;
};

const arr8: Arr2 = [];
```

元祖：

```
// 元祖、固定长度，且每个元素都固定类型 -------------------------------------------------
const tup1: [number, string, boolean] = [1, "a", true];

// 只读元组，无法增删改成员，但不是无法修改自身
const tup2: readonly [number, string, boolean] = [1, "a", true];

// 可选
const tup3: [number, string?] = [1];

// rest
const tup4: [number, string?, ...any[]] = [1, "", true];

// 形参列表也是元祖，"a" 、"b" 只是标识作用
const args: [a: number, b: string] = [1, "a"];

// 元祖数组
const tupArr: [number, string][] = [];

// TS 只有元祖可以使用扩展运算符，数组类型、对象类型无法使用 -------------------------------------
type T1 = [number, string];

// type：[number, string, boolean]
type T2 = [...T1, ...[boolean]];
```

对象数组、对象元组：

```
type Obj = {
  readonly info: { name: string };
  readonly child: any[];
};

let arr: readonly Obj[] = [
  {
    info: { name: "asdf" },
    child: [2],
  },
];

// ok ，readonly 只限制属性自身，不限制更深层次的修改
arr[0].info.name = "qwer";
// err
// arr[0].info = { name: "qwer" };

// ok ，readonly 的数组/元组只是限制成员的增删改，不限制自身重新赋值
// arr = [];
// err
// arr[0] = { info: { name: "qwer" }, child: [] };

// ok ，若对象属性是 readonly 的，但 value 是数组/元组，则 readonly 只作用属性自身，不作用于 value
arr[0].child[0] = 2;
// err
// arr[0].child = [];
```

（4）函数

```
const func1: Function = (a: number) => {};

// 形参类型只和类型有关，和形参名无关
const func2: (a: number) => void = (b: number) => {};

/**
 * 函数也会类型推断
 * 可以设置可选参数，必须放在必选参数后，剩余参数前；设置了默认值就是可选参数了，不用加 ?
 * 可以设置 rest 参数
 */
const func3 = (a: number, b?: number, ...args: any[]) => {};

// 使用元祖实现前置不定量参数
function func4(...args: [...preArgs: any[], a: number]) {}
func4("a", 1);
func4("a", "b", 1);

// 可以声明 this 的类型，但必须放在最前面；运行时不用传入 this
const func5: (this: HTMLElement, e: Event) => void = (e: Event) => {};
```

函数重载，只能重载具名函数：

```
// 多个函数签名
function func(): number;
function func(a: string): string;
function func(a: boolean): boolean;
function func(a: number, b: number): void;

// 实现只能有一个，且类型必须涵盖所有重载
function func(
  a?: number | string | boolean,
  b?: number
): number | string | boolean | void {
  // 类型守卫
  if (typepf a === "undefined" && typeof b === "undefined") return 123;
  else if (typeof a === "string") return "asdf";
  else if (typeof a === "boolean") return true;
  else if (typeof a === "number" && typeof b === "number") return;
}

func();
func("a");
func(true);
func(1, 2);
```

对象、class 内的函数重载：

```
// type 也行，只是 class 只能实现接口
interface Obj {
  func(): number;
  func(a: string): string;
}

function func(a?: string): any {
  if (typeof a === "undefined") return 123;
  else if (typeof a === "string") return "asdf";
}

const obj: Obj = { func };

class A implements Obj {
  public func = func;
}
```

当函数形参是子类型，而实参是父类型无法传入时，可以用重载解决：

```
type Method = "GET" | "POST";

function func1(method: Method) {}

// 正常
func1("GET");

// err ，因为 obj 的 method 类型推断为 string ，string 无法传给子类型 "get" | "post"
const obj = { method: "GET" };
// func1(obj.method);

// 方法一，用类型断言解决 ---------------------------------------------------------
func1(obj.method as Method);

// 方法二，函数重载 -----------------------------------------------------------------
// 类型守卫函数，本来返回值是 boolean ，使用 is 后有更好的提示
function isMethod(value: any): value is Method {
  return value === "GET" || value === "POST";
}

function func2(method: Method): any;
function func2(method: string): any;
function func2(method: any) {
  if (!isMethod(method)) new Error();
}

func2(obj.method);
```

TS 的函数重载依然需要再函数中进行类型的分支判断，还是不太方便，可以自己实现：

```
/**jQurey源码的函数重载，有几个缺点 ------------------------------------------------------

* 需要借助对象
* 只能实现参数长度的重载，类型不行，且 fn.length 在一些情况如有参数默认值时不准确
  */
  const fn = {};

function addMethod(target, methodName, fn) {
  const oldFn = target[methodName];

  target[methodName] = function (...args) {
    if (args.length === fn.length) {
      return fn.apply(this, args);
    } else if (typeof oldFn === "function") {
      // 通过递归寻找闭包的 oldFn 实现函数重载
      return oldFn.apply(this, args);
    }
  };
}

addMethod(fn, "test", () => console.log("无参"));
addMethod(fn, "test", (a, b) => console.log(a, b));
addMethod(fn, "test", (a) => console.log(a));

fn.test();
fn.test(1);
fn.test(1, 2);
```

```
// 更好的实现 ------------------------------------------------------------------------------

type jsType = {
  number: number;
  string: string;
  boolean: boolean;
  symbol: symbol;
  bigint: bigint;
  undefined: undefined;
  null: null;

  // 对象可以再细化，这里就不处理了，也可以加入一些自定义的类型
  object: object;
};

type jsTypeUnion = keyof jsType;

type ArgsTypes<T extends jsTypeUnion[]> = {
  [index in keyof T]: jsType[T[index]];
};

function createOverload() {
  // 参数列表和函数的映射
  const fnMap = new Map<string, Function>();

  function overload(...args: any[]) {
    const key = args.map((i) => typeof i).join(",");
    const fn = fnMap.get(key);

    if (typeof fn !== "function") {
      throw new TypeError(`没有找到参数列表 ${key} 对应的函数实现`);
    }

    return fn.apply(this, args);

  }

  overload.addImplementation = function <T extends jsTypeUnion[]>(
    ...args: [...T, (...args: ArgsTypes<T>) => any]
  ) {
    const fn = args.pop();

    // 把参数列表作为 fnMap 的 key
    fnMap.set(args.join(","), fn as Function);

  };

  return overload;
}

const func = createOverload();

func.addImplementation(() => console.log("无参"));

func.addImplementation("number", "string", (a, b) =>
  console.log("number string", a, b)
);

func.addImplementation("string", "number", (a, b) => {
  console.log("string number", a, b);
  return "ok";
});

func();
func(123, "asdf");
console.log(func("asdf", 123));

try {
  func(123, 456);
} catch {
  console.log("err");
}
```

### 1.3 联合类型、交叉类型

联合类型、获得并集，可以使用 keyof ：

* 注意，引用类型联合是联合自身，不是联合成员
* 注意，函数联合，不会逆便

```
// 联合类型 ------------------------------------------------------------------------------
type Test1 = number | string;

// 注意，联合类型的变量（和 let 、const 无关），类型会收窄为单个的类型
// 其他场景则不会收窄，如联合类型的函数形参
const d1: Test1 = 123;
// 正常赋值，因为 d1 类型是 number ，不是 number | string
const d2: number = d1;

// type：string
type test2 = "a" | string;

// type：number
type Test3 = number | never;

// 对象联合类型，获得 obj 并集，并的是 obj 而不是 key ---------------------------------------------
type T1 = { a: number; b: number };
type T2 = { b: string; c: number };
type U1 = T1 | T2;

// ok ，赋值正常、访问正常
const uo1: U1 = { a: 1, b: 2 };
const uo2: U1 = { b: "a", c: 3 };

// err ，赋值允许，但访问 a 、c 不允许，只能访问 b ，因为对象联合类型不是 kkey 联合
const uo3: U1 = { a: 1, b: 2, c: 3 };
const uo4: U1 = { a: 1, b: 2, c: 3 };
// console.log(uo3.a, uo3.c, uo4.a, uo4.c);

// err
// const uo5: U1 = { b: 1 };

// readonly ，? 同理
type T3 = { a: number; b?: number };
type T4 = { readonly b: string; c: number };
type U2 = T3 | T4;

// ok ，有 a 时 b 是可选的
const uo6: U2 = { a: 1 };
const uo7: U2 = { a: 1, b: 2 };
const uo8: U2 = { b: "a", c: 3 };
// err ，有 c 时 b 是 readonly 且必选的
// uo8.b = "b";
// const uo9: U2 = { c: 3 };

// 同样的，赋值允许（此时 b 是 readonly 可选的），访问不允许
const uo10: U2 = { a: 1, c: 2 };
const uo11: U2 = { a: 1, b: "a", c: 2 };
// err
// console.log(uo10.a, uo10.c);
// uo11.b = "b";

// 其他引用类型和对象一样 ----------------------------------------------------------------------
type Tup = [number, string] | [string, number];

// ok
const tup1: Tup = [1, "a"];
const tup2: Tup = ["a", 2];

// err
// const tup3: Tup = [1, 2];
// const tup4: Tup = ["a", "b"];

type Arr = number[] | string[];

// ok
const arr1: Arr = [1, 2];
const arr2: Arr = ["a", "b"];

// err
// const arr3: Arr = [1, "b"];
// const arr4: Arr = ["a", 2];

// 函数，注意 => 优先级低于 |
type Func = ((a: number) => number) | ((a: string, b: boolean) => string);

// ok
const func1: Func = (a: number) => 123;
const func2: Func = (a: string, b: boolean) => "asdf";

// err
// const func3: Func = (a: number | string, b: boolean) => 123;
```

交叉类型，获得交集；

* 注意，引用类型交叉得到共同的最接近的子类型

* z注意，函数交叉时，得到函数子类型，形参逆便为父类型

```
// 交叉类型 ----------------------------------------------------------------------------
// type："a""
type Test4 = "a" & string;

// type：never
type Test5 = number & string;

// type：never
type Test6 = "a" & never;

// 对象交叉类型，获得 obj 焦集，即共同的子类型，类似 interface 继承 ------------------------------------------------
type T1 = { a: number; readonly b: "str" };
type T2 = { b?: string; c: number };
type A1 = T1 & T2;

// 只能是这种情况，才是共同的子类型
const ao1: A1 = { a: 1, b: "str", c: 3 };
// 可修改，虽然对象属性 readonly 和子类型无关，但交叉后会尽量放宽
ao1.b = "str";

// 混入，得到交叉类型
// type：{ a:number, b: never, c: number }
const ao2 = Object.assign({ a: 1, b: 2 }, { b: "2", c: 3 });

// 其他引用类型也一样 --------------------------------------------------------------------------
type Tup = readonly [number, string, boolean] & [1, "a", boolean?];
const tup: Tup = [1, "a", true];

type Arr = number[] & 123[];
const arr: Arr = [123];

// 注意，=> 优先级低于 &
// 注意，函数交叉，得到子类型，形参就逆便为最近的父类型，即 a: number
type Func = ((a: number) => number) & ((a: 123) => 123);
const func1: Func = (a: number) => 123;
// 下面也可以验证得到 a: number ，赋值时形参逆便，可以是更大的父类型
const func2: Func = (a?: number) => 123;
const func3: Func = (a: any) => 123;
const func4: Func = (a?: any) => 123;
```

### 1.4 类型推断、收缩、断言

（1）类型推断

当未指定类型时，会自动根据值推断出类型，开发中可以多用这种方式；

```
// number
let num1 = 1;

// 2 ，因为是 const 的基本类型敞亮，类型就被推断为字面量了
const num2 = 2;

// number[]
const arr1 = [1];

// (number | string)[]
const arr2 = [1, "a"];

// { a: number }
const obj = { a: 1 };

// () => void
const func1 = () => {};

// () => number
const func2 = () => 123;

// 匿名函数指定了类型，赋值时就不需要给类型了，也能类型推断
const func3: (a: number) => void = (a) => {};

// 回调函数也会推断
type Fn = (a: number) => void;
const func4 = (fn: Fn) => {};
// type: a; number
func4((a) => {});
```

（2）类型收缩

分支逻辑会收窄类型，但循环不会；

```
// 分支逻辑 -----------------------------------------------------------------------------------
function func1(text: "a" | "b" | "c") {
  // type: "a"
  if (text === "a") console.log(text);
  // type: "b"
  else if (text === "b") console.log(text);
  // type: "c"
  else console.log(text);

  switch (text) {
    // type: "a"
    case "a":
      console.log(text);
      break;

    // type: "b"
    case "b":
      console.log(text);
      break;

    // type: "c"
    case "c":
      console.log(text);
      break;

    // type: never
    default:
      console.log(text);
  }
}

// in ，循环每次都无法确定类型，需要配合 in ------------------------------------------------------
type Data = Array<{ id: string } | { prop: string }>;

function func2(data: Data) {
  for (const item of data) {
    // 可以类型断言 item ，但不推荐

    if ("id" in item) console.log(item.id);
    else if ("prop" in item) console.log(item.prop);
  }
}

// is ，也是循环无法确定类型，用 is 判断的同时确定类型 -------------------------------------------------------
type InputInfo = { type: "input" };
type RadioInfo = { type: "radio"; options: any[] };
type CheckboxInfo = { type: "checkbox"; options: any[] };

type NormalType = InputInfo["type"];
type OptionType = (RadioInfo | CheckboxInfo)["type"];
type AllType = NormalType | OptionType;

type Info = Array<InputInfo | RadioInfo | CheckboxInfo>;

// 测试函数
function getOptionXxx(type: OptionType) {}

// 判断的同时用 is 确定 item 的类型
function isOptions(item: Info[number]): item is RadioInfo | CheckboxInfo {
  return ["radio", "checkbox"].includes(item.type);
}

function func3(info: Info) {
  for (const item of info) {
    // 可以类型断言 item ，但不推荐

    // ok ，但是如果 type 太多了就很麻烦，要写很多判断，且不好维护
    if (item.type === "radio" || item.type === "checkbox") {
      getOptionXxx(item.type);
    }

    // err ，形如这样的方式无法类型收缩，因为判断结果是不确定的
    // if (["radio", "checkbox"].includes(item.type)) getOptionXxx(item.type);

    // ok ，is 可以提高代码可维护性，方便在任何地方使用
    if (isOptions(item)) getOptionXxx(item.type);
  }
}
```

（3）类型断言

告诉编译器类型，谨慎使用：

```
// 类型断言 -------------------------------------------------------------------------
const arr: (number | string)[] = [1, 2, "a", "b"];

// 测试函数
function test(num: number) {}

// err ，因为 test 函数只能接受 number 类型，而 arr 的成员类型为 number | string
// test(arr[0]);

// 两种类型断言方式
test(arr[0] as number);
console.log(<number>arr[0]);

// 非空断言 ----------------------------------------------------------------------------
const obj: {
  child1?: any[];
  child2: { name: string } | null;
} = { child1: [1], child2: [2] };

// err ，因为可能为 null
// console.log(obj.child1[0],obj.child2.name);

// ok ，如果很确定是非空的，就可以用非空断言
console.log(obj.child1![0], obj.child2!.name);

// ok ，也可以用 ?. ，但不属于断言，不会改变类型
console.log(obj.child1?.[0],obj.child2?.name);
```

类型断言 as const ，断言为字面量类型：

```
// as const ，得到字面量类型，只能用于字面量 ------------------------------------------------------
// 未使用 as const ，类型推断为 { a: string }
const obj1 = {
  a: "a",
};

// { a: "a" } ，as const 使得某个属性变为字面量类型
const obj2 = {
  a: "a" as const,
};

// { readonly a: "a" } ，as const 也可以放在最后面，使得全部属性变为字面量类型，且是 readonly 的
const obj3 = {
  a: "a",
} as const;

// 若已经显示声明类型，则 as const 无效，类型为 { a: string }
const obj4: { a: string } = {
  a: "a" as const,
};
const obj5: { a: string } = {
  a: "a",
} as const;

// number 123 ，基本类型中，若未显示声明类型，则 const 会推断为字面量类型
let num1 = 123;
const num2 = 123;
// 123 ，因此 let 未生命类型时，可以使用 as const
let num3 = 123 as const;

// (number | string)[]
const arr = [1, "a"];
// (1 | string)[] ，单个变为字面量类型
const tup1 = [1 as const, "a"];
// readonly [1, "a"] ，as const 整个数组会变为 readonly 的字面量元组
const tup2 = [1, "a"] as const;

/**复杂类型举例
 * Array<{
     id: string, 
     value: number,
     children: Array<{ id: string, value: number }> 
   }>
*/
const data1 = [
  { id: "1", value: 1, children: [{ id: "11", value: 11 }] },
  { id: "2", value: 2, children: [{ id: "22", value: 22 }] },
];

/**as const
 * readonly [
 *   {
       readonly id: "1", 
       readonly value: 1,
       readonly children: [{ readonly id: string, readonly value: number }] 
     },

     { 同上，只是字面量改变 }
   ]
*/
const data2 = [
  { id: "1", value: 1, children: [{ id: "11", value: 11 }] },
  { id: "2", value: 2, children: [{ id: "22", value: 22 }] },
] as const;
```

```
//  satisfies ，使得类型推断具有类型检查 ----------------------------------------------------------------
type Num = 123;

// type 为 123
let n1: Num = 123;
// type 为 number ，因为 satisfies 只是具有类型检查，并不会影响类型推断的机制
let n2 = 123 satisfies Num;

// as const 通常配合 satisfies 一起使用 --------------------------------------------------------
// readonly [1, "a"]
const tuple1 = [1, "a"] as const;

// [1, "a"] ，与单独使用 as const 不同的是会去掉元组自身的 readonly
const tuple2 = [1, "a"] as const satisfies [number, string];

// readonly [1, "a"] ，除非 satisfies 也是 readonly 的
const tuple3 = [1, "a"] as const satisfies readonly [number, string];

// 用在对象则和单独使用 as const 一样，全部属性变为 readonly 的字面量类型
const obj = {
  a: 1,
} as const satisfies { a: number };

/**应用举例，由于使用 as const 必须不能显示指定类型，就没有类型提示，satisfies 就能解决这个问题
 * [
 *   {
       readonly id: "1", 
       readonly value: 1,
       readonly children: [{ readonly id: string, readonly value: number }] 
     },

     { 同上，只是字面量改变 }
   ]
*/
type Data = Array<{ id: string; value: number; children?: Data }>;
const data3 = [
  { id: "1", value: 1, children: [{ id: "11", value: 11 }] },
  { id: "2", value: 2, children: [{ id: "22", value: 22 }] },
] as const satisfies Data;
```

函数泛型的字面量类型，注意 ，只有函数泛型才能使用 const ：

```
const func1 = <T>(data: T) => data;
const func2 = <const T>(data: T) => data;

// (number | string)[]
const res1 = func1([1, "a"]);

// readonly [1, "a"]
const res2 = func2([1, "a"]);
```



## 2 类、接口

### 2.1 类

（1）基本

与 JS 略有不同：

```
class Person {
  // 省略默认为 public
  public name: string;
  private age: number;
  protected password;

  // readonly 只能修饰属性
  public readonly sex;

  // 多个修饰符一起使用
  public static readonly xxx;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;

    // err ，设置的属性必须已经在类内声明
    // this.a = 1;

  }
}

const obj: Person = new Person("asdf", 18);

// "asdf"
console.log(obj.name);

// err ，无法访问 private 属性
// console.log(obj.age);

// 但 private 不是 ES13 的 # 语法层面上的约束，只是类型检查而已，而下面这种方式就能访问 private 属性
console.log(obj["age"]);
```

构造函数可以简写：

```
class Person {
  // 声明并赋值，除了 static 外都可以
  constructor(
    public name: string,
    private age: number,
    protected password: string,
    public readonly sex
  ) {}
}

const obj = new Person("asdf", 18, "123456", "male");
console.log(obj);
```

（2）装饰器

类似于面向切面编程，若报错，则说明该语法还在实验阶段，需要在 tsconfig\.json 配置：

```
{
  "compilerOptions": {
    "target": "ES5",
    "experimentalDecorators": true
  }
}
```

使用：

```
// 类装饰器
const classDes1: ClassDecorator = (target: Function) => {
  // target 为类的构造函数，可以给原型添加属性方法
  target.prototype.a = 1;
};
const classDes2 = (target: any) => {};

// 属性装饰器
const propDes: PropertyDecorator = (target: any, propName: string) => {
  // target 是类的原型
};

// 方法装饰器
const funcDes: MethodDecorator = (
  target: any,
  funcName: string,
  tag: PropertyDescriptor
) => {
  // target 是类的原型，tag 是修饰符如 public
};

// 参数装饰器
const paramsDes: ParameterDecorator = (
  target: any,
  funcName: string,
  paramsLoc
) => {
  // target 是类的原型，paramsLoc 是参数在形参列表的索引
};

// 可以同时用多个装饰器
@classDes1
@classDes2
class A {
  // @propDes
  public name: string;

  @funcDes
  public func(@paramsDes a: number) {}
}

const obj = new A();
console.log((obj as any).a);
```

装饰器工厂：

（3）控制反转

控制反转（Inversion of Control，IoC）是面向对象的一种设计原则，可以降低代码之间的耦合度，最常见的一种实现方法是依赖注入（Dependency Injection，DI）。

依赖注入就是在创建对象时，将该对象所依赖的其他对象通过参数、属性等方式传递进去，而不是让该对象自己去创建这些依赖对象。这样做的好处是，使得对象之间的依赖关系更加清晰，降低代码的耦合度，同时也更容易进行单元测试和模块化设计。

```
// 未使用依赖注入的例子 ---------------------------------------------------------------------
// B 类使用 A 类的属性方法，如果修改了 A 类，就需要改动 B 类，形成了耦合
class A {
  constructor(public name: string) {}
}

class B {
  public name: string;

  constructor() {
    this.name = new A("asdf").name;
  }
}

const obj1 = new B();
console.log(obj1.name);

// 使用依赖注入 ----------------------------  ----------------------------------
// 定义一个依赖注入容器
class Container {
  private module: any;

  constructor() {
    this.module = {};
  }

  public provide(key: string, instance: any) {
    this.module[key] = instance;
  }

  public inject(key: string) {
    return this.module[key];
  }
}

const container = new Container();

// 使用
class C {
  constructor(public name: string) {}
}

container.provide("class_A_instance", new A("asdf"));

class D {
  public name: string;

  constructor(instance: string) {
    this.name = container.inject(instance).name;
  }
}

const obj2 = new D("class_A_instance");
console.log(obj2.name);
```

（4）抽象类

当父类涵盖的范围比较大，具体的属性方法不好定义，而且我们也不想实例化这个父类，这时候，就可以使用抽象类，专门用来做继承。抽象类不能被实例化。

抽象类可以有普通类的属性方法构造器，抽象类内还可以写抽象方法

抽象方法：

- 抽象方法，只定义方法的结构，不做具体实现，若不知道方法具体要怎么实现，就先不实现，使用抽象方法

- 抽象方法没有方法体，只能在抽象类/接口内定义，继承的子类必须重写抽象方法来实现

```
abstract class Person {
  public abstract func: (a: number) => void;
}

class A extends Person {
  // 抽象方法必须重写
  public func = (a: number): void => {};
}
```

### 2.2 接口

接口用来定义类或对象的结构，和 type 的区别：

- 接口只能定义对象类型，而type 可以定义任何的类型

- 接口无法使用 in 映射类型，而 type 可以

- 接口可以重复声明，type 不行

- 接口可以继承，而 type 不行，但type 也可以用交叉类型实现类似效果

和抽象类的区别：

- 接口的属性不能初始化，而抽象类可以

- 接口的方法不加 abstract 但都是抽象方法，而抽象类可以有普通方法

- 接口的属性方法不能加除 readonly 外的修饰符，而抽象类都可以加

```
interface A {
  name: string;
  func(): void;
}

/**若重复声明接口
 * 相同的属性类型、readovly、是否可选必须一样；会加上没有的属性
 * 相同的方法会被忽略，不会重载
 */
interface A {
  name: string;
  age: number;
  func(a: number): void;
}

interface B {
  age: string;
  sex: "male";
}

// 给对象使用
const obj: A = {
  name: "asdf",
  age: 18,
  func() {},
};

// class 实现接口，可以多实现，相当于接口的交叉类型 --------------------------------------------
interface P1 {
  name: string;
}

interface P2 {
  age: number;
}

class Person implements P1, P2 {
  // 若 constructor 声明了属性，就不需要再声明
  constructor(public name: string) {}

  // 若在 constructor 外声明，就必须赋值
  public age: number = 18;
}

// 类可以在继承的同时实现接口，也是相当于交叉类型
// 类无法多继承
interface P3 {
  sex: boolean;
}

class Child extends Person implements P3 {
  public sex: boolean = true;
}
```

接口扩展，即接口继承：

```
interface A {
  name: string;
  func(): void;
}

interface B {
  age: number;
}

// 可以多继承，若有相同的属性则类型必须相同
interface C extends A, B {
  // err ，若子接口有相同的属性，则类型必须相同，只能从可选变成必选（反之不行），readonly 无所谓
  // age: string;
  // age?: number;

  // err ，子接口不能有同名方法，即不能重写
  // func(a: number): void;

  sex: boolean;
}

const obj: C = { name: "asdf", age: 18, sex: true, func() {} };
```

## 3 泛型

### 3.1 基本

用于建立类型的联系，相同的泛型会传递下去：

```
// 泛型 ----------------------------------------------------------------------------------
function func1<T>(a: T) {}
const func2 = <T>(a: T, b: T) => {};
const func3 = <T, U>(a: T, b: U) => {};

// 使用
func1<number>(123);
func3<number, string>(123, "asdf");

// 也可以不用传入泛型，会自动推断，第一个参数推断为 number ，那么其他 T 也是 number
func2(123, 456);
// 多个泛型也能推断
func3(123, "asdf");

// class 、。interface 、type 也可以使用泛型
interface PersonInterface<T> {}

class Person<T> implements PersonInterface<T> {}

type T1<T> = T;
type T2<T> = T1<T>;

// 泛型约束，限制泛型必须是某个类型的子类型 --------------------------------------------
// 如限制只能是引用类型，限制 key 只能是该对象的联合类型子类型
function getObjectValue<T extends object, K extends keyof T>(obj: T, key: K) {}

// ok
getObjectValue({ a: 1 }, "a");
// err
// getObjectValue({ a: 1 }, "b");

// 泛型默认值 -----------------------------------------------------------------------------------
const func4 = <T = number>(a?: T) => a;

// number | undefined ， string | undefined ，和未使用默认值效果一样
let res1 = func4(123);
let res2 = func4("asdf");

// number | undefined ，泛型默认值作用是，当无法推断泛型的类型时，提供一个默认类型
let res3 = func4();

// unknown ，无默认值
const func5 = <T>(a?: T) => a;
const res4 = func5();

// 泛型默认值无法确定类型 --------------------------------------------------------------------
function test(a: number) {}
function func6<T = number>(a: T) {
  // err ，T 不是 number
  // test(a);
}

type Num<T extends number> = 123;
type A1<T extends number | string = number> = {
  // err ，T 的类型还是 number | string
  // num: Num<T>;
};
```



泛型的条件类型运算，分支会类型受说：

```
// 类型取反 -------------------------------------------------------------------------------
type Not<T, U> = T extends U ? never : U;

// 除了 number 外的类型都可以
function func3<T>(a: Not<number, T>) {}

func3("123");

// err
// func3(123);

// 生成对象类型 ----------------------------------------------------------------------------
type NormalType = "input";
type OptionType = "radio" | "checkbox";
type AllType = NormalType | OptionType;

type OptionInfo<T extends OptionType> = Array<{ value: string; label: string }>;

type Info<T extends AllType = AllType> = T extends OptionType
  ? {
      type: T;
      options: OptionInfo<T>;
    }
  : T extends NormalType
  ? {
      type: T;
    }
  : never;

const info: Info[] = [
  {
    type: "input",
    // err
    // options: [],
  },

  {
    type: "radio",
    options: [],
  },

  {
    type: "checkbox",
    options: [],
  },
];
```



### 3.2 类型安全、类型关系

（1）协变、逆变

为了保证类型安全，ts 就有协变、逆变的机制（注意，由于使用字面量赋值时会即时类型检查，所以此时只能使用固定的类型）：

* 协变：具体的类型只能赋值给宽泛的类型，即父类型只能接收子类型，这是为了保证父类型始终安全可用，不会出现自己没有的类型，如：
  
  ```
  interface Parent {
    name: string;
  }
  
  interface Child extends Parent {
    age: number;
  }
  
  const parent: Parent = { name: "parent" };
  const child: Child = { name: "child", age: 18 };
  
  // ok ，协变，保证 p 始终可用
  const p1: Parent = parent;
  const p2: Parent = child;
  
  // err ，因为当 c 访问 age 时，可能访问不到，就不安全了
  // const c: Child = parent;
  
  // err ，注意，使用字面量会即时类型检查
  // const p3: Parent = { name: "child", age: 18 };
  ```

* 逆便：反方向的协变，子类型只能接收父类型，出现在函数形参中（注意，函数返回值、函数调用是协变）,如：
  
  * 形参逆便场景如函数赋值，函数 extends 判断，函数交叉
  
  ```
  interface Parent {
    name: string;
  }
  
  interface Child extends Parent {
    age: number;
  }
  
  // 函数形参是逆变 ---------------------------------------------------------------------------
  type ReadParent = (parent: Parent) => void;
  type ReadChild = (child: Child) => void;
  
  // ok ，逆变，反方向协变，即父类型可以赋给子类型
  const readChild1: ReadChild = (child: Child) => {};
  const readChild2: ReadChild = (parent: Parent) => {};
  
  // 但实际上也可以理解为协变，因为 readChild2 预期传入的是 Child ，实际上用 Parent 接收了
  readChild2({ name: "child", age: 18 });
  
  // err ，不安全，因为预期传入的是 Parent ，却用 Child 接收
  // const readParent: ReadParent = (child: Child) => {};
  
  // 函数返回值是协变 ---------------------------------------------------------------------------
  type GetParent = () => Parent;
  type GetChild = () => Child;
  
  // ok
  const getParent: GetParent = () => ({ name: "child", age: 18 });
  const parent = getParent();
  
  // err
  // const getChild: GetChild = () => ({ name: "parent" });
  
  // 若形参、返回值都有，也是一样，形参逆便，返回值协便
  type SetChild = (child: Child) => Child;
  const setChild: SetChild = (parent: Parent) => ({ name: "child", age: 18 });
  
  // 函数调用是协便 --------------------------------------------------------------------------------
  function func1(parent: Parent) {}
  function func2(child: Child) {}
  
  const p: Parent = { name: "parent" };
  const c: Child = { name: "child", age: 18 };
  
  // ok ，协便
  func1(p);
  func1(c);
  func2(c);
  
  // err
  // func2(p);
  
  // err ，注意，传入字面量会即时类型检查
  // func1({ name: "child", age: 18 });
  
  // 其他例子 -----------------------------------------------------------------------------------
  type Func = (a: number) => void;
  
  // 注意，不给形参，形参默认就是 any 类型
  // 形参都逆便为父类型
  const f1: Func = () => {};
  const f2: Func = (a: any) => {};
  const f3: Func = (a?: any) => {};
  const f4: Func = (a?: number) => {};
  ```

（2）类型关系

判断子类型的方式：

```
// true ，extends 判断左边是否是右边的子类型
type A1 = 123 extends number ? true : false;

// 123 ，得到交际，说明 123 是 number 的子类型
type A2 = 123 & number;
```

基本：

```
// true ，自身是自身的子类型
type A1 = 123 extends 123 ? true : false;

// true ，字面量是自己数据类型的子类型
type A2 = 123 extends number ? true : false;

// true true ，联合类型的子项是联合类型的子类型
type A3 = "a" extends "a" | "b" | "c" ? true : false;
type A4 = "a" | "b" extends "a" | "b" | "c" ? true : false;

// true false ，若联合类型的各个子项都是某个类型的子类型，呢么整个联合类型就是子类型
type A5 = 1 | 2 extends number ? true : false;
type A6 = 1 | "a" extends number ? true : false;

// true ，交叉类型先运算，再 extends
type A7 = 123 & number extends 123 ? true : false;

// true ，never 是任何类型的子类型；除了 never 自身，没有任何类型是 never 的子类型
type A8 = never extends number ? true : false;

// true ，交叉类型是联合类型的子类型
type A9 = 1 & 2 extends 1 | 2 ? true : false;
type A10 = { a: number } & { b: number } extends { a: number } | { b: number }
  ? true
  : false;
```

any 、unknown ：

```
// true ，"a" | "b" ，any 可以是所有类型的子类型或父类型；any 在右则是付类型，在左则同时是付类型、子类型
type A1 = 123 extends any ? true : false;
type A2 = any extends 123 ? "a" : "b";

// true false ，unknown 是最安全的顶级类型，是所有类型的父类型
type A3 = 123 extends unknown ? true : false;
type A4 = unknown extends 123 ? true : false;

// true true ，特殊规则
type A5 = any extends unknown ? true : false;
type A6 = unknown extends any ? true : false;
```

void 、undefined 、null 、\{\}  、\[\] ：

* 非严格模式下，undefined 、null 可以是任何类型的子类型，但 ts 默认是严格模式

* undefined 是 void 的子类型

* 类型 \{\} 表示除了 undefined 、null 外的任何类型，等价于 Record\<never, never\>，非严格模式下则等价于 unknown
  
  * 空对象：
    
    ```
    // 等价于 {}
    type A1 = Record<never, never>;
    
    // 空对象，即索引签名为 { [Key: string]: never } 
    type A2 = Record<string, never>;
    ```

* 类型 \[\] 表示空数组，等价于 never\[\] ，非严格模式下也能赋值 undefined 、null

* 修改为非严格模式：
  
  ```
  // tsconfig.json
  {
    "compilerOptions": {
      "strict": false
    }
  }
  ```

```
// false false ，设置非严格模式后都为 true
type A1 = undefined extends 123 ? true : false;
type A2 = null extends 123 ? true : false;

// false false ，设置非严格模式后都为 true
type A3 = undefined extends null ? true : false;
type A4 = null extends undefined ? true : false;

// true false ，设置非严格模式后都为 true
type A5 = undefined extends void ? true : false;
type A6 = null extends void ? true : false;

// true false ，非严格模式下为 true true
type A7 = 123 extends {} ? true : false;
type A8 = null extends {} ? true : false;

// false false ，设置非严格模式后为 false true
type A9 = 123 extends [] ? true : false;
type A10 = null extends [] ? true : false;
```

对象：

* 参考父类、子类即可：
  
  * 属性更多的是子类型，除非多的是可选属性
  
  * 必选是可选的子类型
  
  * readonly 和子类型无关

* 不要使用大写 Object ，是运行时，ts 应使用小写 object

* object 表示引用类型，子类型有数组、函数等

```
interface Parent {
  name: string;
}

interface Child extends Parent {
  age: number;
}

// true false
type A1 = Child extends Parent ? true : false;
type A2 = Parent extends Child ? true : false;

// true ，如果多的属性是可选的，就无所谓
type A3 = { a: number } extends { a: number; b?: number } ? true : false;

// true true false
type A4 = number[] extends object ? true : false;
type A5 = Function extends object ? true : false;
type A6 = 123 extends object ? true : false;

// 都是 true ，必选是可选的子类型，readonly 和子类型无关
type A7 = { a: number } extends { a?: number } ? true : false;
type A8 = { a: number } extends { readonly a: number } ? true : false;
type A9 = { readonly a: number } extends { a: number } ? true : false;
```

枚举，没有子类型关系：

```
enum E1 {
  GET = 0,
}

enum E2 {
  GET = 0,
  POST = 1,
}

const enum E3 {
  GET = 0,
  POST = 1,
}

// false false
type A1 = E2 extends E1 ? true : false;
type A2 = E1 extends E2 ? true : false;

// false false
type A3 = E3 extends E2 ? true : false;
type A4 = E2 extends E3 ? true : false;
```

数组、元组：

* 必选是可选的子类型；可增删改是 readonly 的子类型

```
// true false false true ，空数组是数组的子类型，但不是定长元组的子类型
type A1 = [] extends number[] ? true : false;
type A2 = [] extends [number] ? true : false;
type A3 = [] extends [never] ? true : false;
type A4 = [] extends [number?] ? true : false;

// true true false false ，可增删改是 readonly 的子类型
type A5 = number[] extends readonly number[] ? true : false;
type A6 = [number] extends readonly [number] ? true : false;
type A7 = readonly number[] extends number[] ? true : false;
type A8 = readonly [number] extends [number] ? true : false;

// true true ，对象的类型关系和 readonly 属性无关
type A9 = readonly [{ a: number }] extends readonly [{ readonly a: number }]
  ? true
  : false;
type A10 = readonly [{ readonly a: number }] extends readonly [{ a: number }]
  ? true
  : false;

// true
type A11 = number[] extends (number | string)[] ? true : false;

// false true true ，元组和长度、顺序强相关
type A12 = [number] extends [number, number] ? true : false;
type A13 = [number] extends [number, number?] ? true : false;
type A14 = [number] extends [number, ...any[]] ? true : false;

// true ，元组是数组的子类型
type A15 = [number] extends number[] ? true : false;
```

函数：

* 注意，=\> 优先级低于 extends 、\| 、\& 等

* 函数 extends ，形参逆变，返回值协变

```
// type UnionToIntersection<U> = (U extends any ? (x: U) => 0 : never) extends (
//   x: infer I
// ) => 0
//   ? I
//   : never;

// type LastOf<T> = UnionToIntersection<
//   T extends any ? (x: T) => 0 : never
// > extends (x: infer L) => 0
//   ? L
//   : never;

// type UnionToTuple<T, Last = LastOf<T>> = [T] extends [never]
//   ? []
//   : [...UnionToTuple<Exclude<T, Last>>, Last];

// type A = LastOf<"a" | "b">;

// type A1<T> = UnionToIntersection<T extends any ? (x: T) => 0 : never>;

// type T1 = ((a: number) => void) & ((a: string) => void);

// -----------------------------------------------------------------------------
// () => true ，因为 extends 优先级高于 =>
type A0 = () => number extends number ? true : false;

// true true
type A1 = ((a: number) => void) extends Function ? true : false;
type A2 = ((a: number) => void) extends (...args: any[]) => any ? true : false;

// true false true，函数形参只和类型有关，和形参名、顺序无关
type A3 = ((a: number) => void) extends (b: number) => void ? true : false;
type A4 = ((a: number, b: string) => void) extends (
  b: string,
  a: number
) => void
  ? true
  : false;
type A5 = ((a: number) => void) extends (a: number, b: number) => void
  ? true
  : false;

// true true ，形参逆变，extends 右边的函数是父类型，则形参逆变为子类型
type A6 = ((a?: number) => void) extends (a: number) => void ? true : false;
type A7 = ((a: any) => void) extends (a: number) => void ? true : false;
// true ，不给形参，形参就是 any
type A8 = (() => void) extends (a: number) => void ? true : false;

// false true ，返回值协变，void 不是 number 的子类型
type A9 = (() => void) extends () => number ? true : false;
type A10 = (() => number) extends () => number | string ? true : false;

// true ，形参逆便、返回值协便都符合
type A11 = ((a?: number) => number) extends (a: number) => number | string
  ? true
  : false;

// { name: string } & { age: number } ，在 infer 作用下 extends 始终成立，即 extends 右边的函数是父类型，形参就逆便为子类型
type A12 =
  | ((a: { name: string }) => void)
  | ((a: { age: number }) => void) extends (a: infer A) => void
  ? A
  : never;

// (x: "a" | "b") => void
type A13 = ((x: "a") => void) & ((x: "b") => void);
// "b" ，形参逆变 "a" & "b" ，最终本该得到 never ，但 ts 这里做了特殊处理，把他看作重载签名，因此才会得到最后一个即 "b"
type A14 = A13 extends (x: infer A) => void ? A : never;
```

### 3.3 类型运算

（1）type

主要用于开发类型工具：

```
// type 可以开发类型工具，用 extends 三目运算判断是否为右边的子类型 ------------------------------
type T1 = 123 extends number ? { a: number } : { a: string };

// 也可以使用泛型
type T2<T> = T extends number ? { a: number } : { a: string };

// 对象索引访问 ----------------------------------------------------------------------------------------
type Obj1 = { a: number };
type obj2 = { a: number } | { a: string };

// number ，可以用索引获取 key 的类型
type key1 = Obj1["a"];
// err ，key 必须 extends 这个对象 key 的联合类型
// type key2 = Obj1["b"];
// type key2 = {}["a"];

// number ，除非有索引签名
type key2 = { [K: string]: number }["b"];

// number | string ，联合类型会展开
type key3 = obj2["a"];

// 数组、元组索引访问 ---------------------------------------------------------------------------------
type Arr1 = number[];
type Arr2 = number[] | string[];
type Tup1 = [number, string];
type Tup2 = [number, string] | [boolean];

// number
type E1 = Arr1["0"];
type E2 = Arr1[0];
type E3 = Tup1[0];
// string
type E4 = Tup1[1];

// number ，允许，因为数组不定长度
type E5 = Arr1[100];
// err ，因为元组定长
// type E6 = Tup1[100];

// number | string ，展开
type E7 = Arr2[0];
// number | boolean ，展开
type E8 = Tup2[0];
// string | undefined ，展开，若是联合类型的元组，允许访问其中最长的索引
type E9 = Tup2[1];

// TS 语法中允许 [number] 得到数组、元组所有成员形成的联合类型
// number
type U1 = Arr1[number];
// number | string ，展开
type U2 = Arr2[number];
// number | string
type U3 = Tup1[number];
// number | string | boolean ，展开
type U4 = Tup2[number];

// never
type U5 = [][number];
```

（2）keyof

获得联合类型：

```
type Obj = { a: number; b: number };

// 得到所有 key 形成的联合类型 ----------------------------------------------------------
// type："a" | "b"
type K1 = keyof Obj;

// type：string | symbol | number ，内置类型有些是对象类型
type K2 = keyof any;
type K3 = keyof never;

// 得到一堆 key 形成的联合类型，因为也是对象类型
// number ，string ，boolan ，symbol
type K4 = keyof number;

// type："length" | ... 等等
type K5 = keyof Number[];

// type："0" | "1" | "length" | ... 等等
type K6 = keyof [number, string];
type K7 = keyof [a: number, b: number];

// type：never
type K8 = keyof unknown;
type K9 = keyof void;
type K10 = keyof null;
type K11 = keyof undefined;
```

（3）\|

前置的 \| 会分开运算，注意：

* extends 中，只有泛型的联合类型才会分开运算，分开后会类型收缩，普通的联合类型 extends 是不会分开运算的

* 若泛型是联合类型，又不想展开，可以：
  
  * 把泛型放入 \[\] 成为元组，这种情况不会展开
    
    把需要展开的部分放在小括号里面

* 注意，泛型是函数联合类型时，形参不会逆便

```
// 联合类型、交叉类型运算
// "a" | "b" ，等价于 ("a" & string) | ("b" & string) | (1 & string)
type T1 = "a" | "b" | (1 & string);

// number | string | boolean ，获取联合类型元组的成员形成的联合类型
type T2 = ([number, string] | [boolean])[number];

// "a" ，去掉 Symbol key
type T3 = keyof { a: number; [sym: symbol]: number } & string;

// 模板字符串，只能用于字面量字符串类型，通常配合联合类型，运算规则和上面一样
// symbol 无法做任何运算，所以也会使用 T3 去掉 symbol key
// "mouseEvent" | "inputEvent"
type T4 = `${"mouse" | "input"}Event`;

// 联合类型、extends 运算，必须是泛型 ------------------------------------------------------
type Obj1<T> = T extends any ? { key: T } : never;
/**{ key: "a" } | { key: "b" }
 * 等价于：
("a" extends any ? { key: "a" }) |
("b" extends any ? { key: "b" })
 */
type Obj2 = Obj1<"a" | "b">;

type MyExclude<T, U> = T extends U ? never : T;
// "a" | "c"
type T5 = MyExclude<"a" | "b" | "c", "b">;

// 泛型是联合类型，又不想展开 ----------------------------------------------------------------
// { key: "a" | "b" } ，不会分开运算
type Obj3<T> = [T] extends [never] ? never : { key: T };
type Obj4 = Obj3<"a" | "b">;

// boolean ，因为不用小括号就整段展开，得到 true | false
type S1<T> = T extends { value: infer V }
  ? V extends number
    ? true
    : false
  : false;
type S2 = S1<{ value: number } | 123>;

// false ，因为只有小括号内会展开，得到 number | false extends number ，由于 number | false 不是泛型，就又不会展开，得到 false
type S3<T> = (T extends { value: infer V } ? V : false) extends number
  ? true
  : false;
type S4 = S3<{ value: number } | 123>;

// 用小括号包裹需要展开的部分

// 泛型是函数联合类型，形参不会逆便 ---------------------------------
type A1<T> = T extends (a: infer U) => any ? U : never;
type A2<T> = T extends () => infer U ? U : never;

// number | string
type A3 = A1<((a: number) => void) | ((a: string) => void)>;
// number | string
type A4 = A2<(() => number) | (() => string)>;
```

（4）in 映射类型

只能在 type 中使用，interface 中无法使用：

```
/**映射类型，只能有一个
 * 便利一个联合类型并得到各个 key ，相当于反向 keyof
 * 设置了映射类型就不能设置其他 key
 * 可以用 readonly 和 ? 修饰
 * as 给 key 重命名
 * as extends 可以泛型判断，过滤属性
 */
type T1 = {
  // [xxx in "a" | "b"]: number;

  // 每个属性都是 readonly 且可选
  readonly [xxx in "a" | "b"]?: number;

  // in 优先级较低
  // [xxx in ("a" | "b") & string]: any;

  // Capitalize 是字面量字符串首字母大写的内置泛型工具
  // [key in "a" | "b" as `key${Capitalize<key>}`]: number;

  // type：{} ，key 为 never 就去掉
  // [key in "a" | "b" as never]: number;

  // type：{ a: any, c: any } ，筛选属性
  // [key in "a" | "b" | "c" as key extends "a" | "c" ? key : never]: number;
};

// 便利对象生成新类型，会保留 readonly 和 ?
type T2 = {
  // [Key in keyof T1]: T1[Key];

  // 去掉 readonly 和 ?
  -readonly [Key in keyof T1]-?: T1[Key];
};

// 内置的类型工具，底层实现是映射类型
type T3 = Record<"a" | "b", number>;

// number ，因为 keyof number 等基本类型会包装为 Number 包装类对象类型
type T4 = {
  [key in keyof number]: number[key];
};

// 得到索引签名
type T5 = {
  [key in string | symbol]: any;
};

// 数组也是一样得到数组
type Tup = [number, string];
type T6 = {
  [Index in keyof Tup]: Tup[Index];

  // 两种等价，比起上面少了 "length" 等
  // [Index in "0" | "1"]: Tup[Index];
  // [Index in 0 | 1]: Tup[Index];
};
```

（5）infer

借助 TS 的类型推断，设计类型工具，infer 可以有效简化类型运算：

* 注意，infer 只能用在判断成功的那个分支

```
// 获取函数返回值类型
type Reture<T> = T extends (...args: any[]) => infer R ? R : T;
// type：number
type R = Reture<() => number>;

// 获取函数第一个形参的类型
type First<T> = T extends (first: infer F, ...args: any[]) => any ? F : T;
// type：number
type F1 = First<(a: number) => void>;
// type：unknown
type F2 = First<() => void>;

// 获取数组元素的类型
type ArrayType<T> = T extends (infer U)[] ? U : T;
// type：number
type U1 = ArrayType<number[]>;
// type：number | string
type U2 = ArrayType<[number, string]>;

// 获取元祖首尾元素形成的联合类型，可以配合扩展运算符
type TupleFirst<T> = T extends [infer first, ...infer args, infer last]
  ? first | last
  : T;
// type：number | boolean
type TU1 = TupleFirst<[number, string, boolean]>;

// 获取元祖剩下的元素
type RemainArgs<A extends any[], PA extends PreArgs<A> | A> = A extends
  | [...PA, ...infer Reamin]
  | A
  ? Reamin
  : A;
// type：[a: number, c:number]
type TU2 = RemainArgs<[a: number, b: number, c: number], [a: number]>;

// 递归 infer --------------------------------------------------------------------------
// 多维数组需要递归
type DeepArrayType<T> = T extends (infer F)[] ? DeepArrayType<F> : T;
// type：number
type D = DeepArrayType<number[]>;

// 获取 Promise resolve 的类型，因为 resolve 的参数肯呢还是 Promise ，所以需要递归 infer
type PromiseType<T> = T extends Promise<infer V> ? PromiseType<V> : T;
// type：number
type V = PromiseType<Promise<Promise<number>>>;

// 翻转元祖类型
type ReverseTuple<T> = T extends [infer first, ...infer args]
  ? [...ReverseTuple<args>, first]
  : T;
// type：[string, number]
type rt = ReverseTuple<[number, string]>;
```

### 3.4 Utility Types

TS 内置的类型工具。

（1）基本

```
// 筛选联合类型的某些类型
// type："a" | "b"
type T1 = Extract<"a" | "b" | "c", "a" | "b">;
type MyExtract<T, U> = T extends U ? T : never;

// 去掉联合类型的某些类型
// type："a" | "b"
type T2 = Exclude<"a" | "b" | "c", "c">;
type MyExclude<T, U> = T extends U ? never : T;

// 去掉联合类型的 null 和 undefined
// type：number
type T3 = NonNullable<number | null | undefined>;
type MyNonNullable<T> = T extends null | undefined ? never : T;
```

（2）函数相关

```
// 获得返回值类型
// type：number
type T1 = ReturnType<() => number>;
type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : T;

// 获得形参列表
// type：[a:number, b:number]
type T2 = Parameters<(a: number, b: number) => void>;
type MyParameters<T> = T extends (...args: infer A) => any ? A : never;

// 获得构造函数实例化对象的类型 ---------------------------------------------------------
class Obj {
  public a: number = 1;
}

// type：{ a: number }
type T3 = InstanceType<typeof Obj>;
type MyInstanceType<T> = T extends new (...args: any[]) => infer R ? R : T;
```

（3）对象类型相关

```
// 所有属性变成可选属性
// type：{ a?: number}
type T1 = Partial<{ a: number }>;
type MyPartial<T> = { [key in keyof T]?: T[key] };

// 所有属性变成必选属性
// type：{ a: number }
type T2 = Required<{ a?: number }>;
type MyRequired<T> = { [key in keyof T]: T[key] };

// 所有属性变成 readonly
// type：{ readonly a: number }
type T3 = Readonly<{ a: number }>;
type MyReadonly<T> = { readonly [key in keyof T]: T[key] };

// 筛选需要的对象属性
// type: { a: number, b: number }
type T4 = Pick<{ a: number; b: number; c: number }, "a" | "b">;
type MyPick<T, K extends keyof T> = { [key in K]: T[key] };

// 去掉不需要的对象属性
// type：{ c: number }
type T5 = Omit<{ a: number; b: number; c: number }, "a" | "b">;
type MyOmit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

// 生成一个所有 key 都是相同 value 的类型
// type：{ a: number, b: number }
type T6 = Record<"a" | "b", number>;
type MyRecord<K extends keyof any, T> = { [key in K]: T };
```

（4）自定义

```
// 部分可选
type SubPartial<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;
// type：{ a?: number, b?:number, c:number }
type T1 = SubPartial<{ a: number; b: number; c: number }, "a" | "b">;

// 深度可选
type DeepPartial<T> = {
  [key in keyof T]: DeepPartial<T[key]>;
};

// 筛选出可选属性，{} 是 {a?: any} 的子类型
type PickPartial<T extends object> = {
  [key in keyof T as {} extends Pick<T, key> ? key : never]: any;
};
// type：{ a?: number }
type T2 = PickPartial<{ a?: number; b: number }>;
```

## 4 模块、配置

（1）模块

可以直接使用 ESM ：

```
// 2.ts

export let a = 1;
export type T1 = number;

// export { a };
// export type { T1 };
```

```
// 1.ts

// 不要加后缀 .ts ，会自动识别，加了就 err ，因为编译后 JS 文件导入 TS 就出错了
import { a } from "./2";

// 不加 type 也可以导入类型，加了有更好的类型提示
import type { T1 } from "./2";

// 一起导入时也可以加上 type 同样的也可以不加
// import { a, type T1 } from "./2";

// 如果没有导入，点击快速修复也能加上导入语句，前提不能是 export default ，因为需要知道名字
console.log(a);
```

如果使用 CommpnJS ，会失去类型提示，全部变成 any ，需要改一下代码：

```
// ts

let a = 1;

// 失去类型提示
// module.exports = { a };

// 修改后
export = { a };
```

```
// 1.ts

// 失去类型提示
// const { a } = require("./");

// 修改后
import MyModule = require("./2");

// 1
console.log(MyModule.a);
```

命名空间，可以实现内部模块，内部是独立的作用域，其实编译成 JS 后就是立即执行函数：

```
namespace A {
  export type T1 = number;
  export let a = 1;
}

// 重复声明则加上没有的 export 资源，export 的资源不能相同，否则 err
namespace A {
  export let b = 2;
}

namespace B {}

// { a: 1, b: 2 } 1
console.log(A, A.a);
// err ，空的 namespace 不会编译
// console.log(B);

// 可以嵌套
namespace C {
  export namespace CC {
    export let a = 1;
  }
}

// { CC: {a: 1} }
console.log(C);

// 起别名
import CCa = C.CC.a;
// 1
console.log(CCa);

// 也可以 export 给其他文件使用
exports = {
  A,
  C,
};
```

（2）配置

tsconfig\.json ，与其他 json 文件不同的是这个可以写注释：

```
# 不会使用 tsconfig.json
tsc 1.ts

# 会使用 tsconfig.json
tsc
ts-node 1.ts
```

配置：

```
{
  "compilerOptions": {
    // 编译的 JS 版本，默认是 ES3 ，可以设置 "es2015" "esnext" 等 ，"esnext" 为最新版本
    "target": "esnext",
    // 去掉编译后的注释，默认 false
    "removeComments": true,

    // 是否允许导入时加上 .ts ，默认 false ，若为 true ，则 noEmit 必须为 true
    "allowImportingTsExtensions": false,
    // 是否生成编译的 JS 文件，默认 false ，true 通常用于纯 ts 的环境如 node 的 ts-node
    "noEmit": false,

    // 模块解析方式，默认 node ，老版本是 classic
    "moduleResolution": "node",

    /**开启所有严格的类型检查
     * 类型检查不通过直接 err
     * 也可以单独设置各种类型检查，默认部分为 true
     * 如 "strictNullChecks" ，默认 false ，true 则不允许 null 、undefined 为所有类型的子类型
     * 设置 "strict" 还会使编译后的 JS 变为严格模式；单个设置则不会
     */
    "strict": true
    // "strictNullChecks": true
  }
}
```

有时候可以临时关闭类型检查：

```
const a: number = 1;

// 只有下面一行会关闭类型检查
// @ts-ignore
const b: string = a;
```
