# 一、Vue

浏览器 Vue 调试插件：vue devtools（Vue3 至少需要 v6 版本）。

## 1 基本

Vue2 、Vue3 主要区别：

* Vue2 使用 Options API ，Vue3 使用 Composition API（即 hook）， Vue3 依旧支持 Options API ，但不推荐混用，防止冲突以及可读性差。
  
  * Composition API 使得开发的颗粒度更小，可以抽离不同组件中相同的数据处理逻辑；而 Vue2 开发的最小单元是组件，就会有很多无法拆分的重复代码，虽然有 mixin 但远远不如 hook 方便
  
  * Composition API 也让同一个业务的代码更集中，不像 Vue2 不同的业务都集中在 data 、methods 等

* Vue3 中不再是用 Vue 构造函数创建 vue ，而是用 createApp 工厂函数创建；Vue 中的各种属性、方法都转移到 app 中：
  
  ```
  // Vue2
  import Vue from "vue";
  import App from "./App";
  new Vue({
    render: h => h(APP)
  }).$mount("#app");
  
  // Vue3
  import { createApp } from "vue";
  import App from "./App";
  createApp(App).mount("#app");
  ```

* Vue2.7 比 Vue3.0 晚发布，具备 Vue3 部分特性，作用是让 Vue2 老项目平滑升级 Vue3 。

### 1.1 使用 CDN

Vue2 ：

```
<!DOCTYPE html>
<html lang="en">
  <body>
    <div id="app"></div>
  </body>

  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
  <script>
    // 子组件
    const Cpn = Vue.extend({
      template: `<div>cpn</div>`,
    });

    // 注册全局组件
    // Vue.component("cpn2", cpn1);

    // 根组件，各个配置项叫 OptionsAPI (选项式 API)，内部的 this 指向 vue 实例
    // Options API 谨慎使用箭头函数，确保 this 为组件实例
    const App = new Vue({
      // document.querySelector("#app").appendChild(vue);
      el: "#app",

      // 注册局部组件，仅当前组件可用
      components: { Cpn },

      data() {
        return {
          list: [10, 20, 30],
        };
      },

      methods: {
        itemClick(e) {
          console.log(e);
        },
      },

      // 渲染
      render(h) {
        return h(
          "ul",
          { attrs: { class: "list" } },

          [
            ...this.list.map((item) => {
              return h(
                "li",
                {
                  attrs: { class: "item" },
                  on: { click: this.itemClick },
                },
                item
              );
            }),

            h("li", {}, [h(this.$options.components.Cpn)]),
          ]
        );
      },

      // 或者使用 template ，会编译为 render 函数，优先级低于自己配置的 render
      template: `
        <ul class="list">
          <li class="item" v-for="item in this.list" @click="this.itemClick">
            {{ item }}
          </li>
          <li><Cpn></Cpn></li>
        </ul>
      `,
    });
  </script>
</html>
```

Vue3 ：

```
<!DOCTYPE html>
<html lang="en">
  <body>
    <div id="app"></div>
  </body>

  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script>
    // Vue3 用 Composition API（组合式 API）
    const { createApp, defineComponent, h, reactive } = Vue;

    // 子组件
    const Cpn = defineComponent({
      setup() {
        return () => h("div", "cpn");
      },
    });

    // 根组件
    const App = defineComponent({
      components: { Cpn },

      setup() {
        // undefined
        console.log(this);

        const list = reactive([10, 20, 30]);

        const itemClick = (e) => console.log(e);

        // return 一个 render 函数
        // return () => {
        //   return h("ul", { class: "list" }, [
        //     ...list.map((item) =>
        //       h(
        //         "li",
        //         {
        //           class: "item",
        //           onClick: itemClick,
        //         },
        //         item
        //       )
        //     ),
        //     h("li", {}, [h(Cpn)]),
        //   ]);
        // };

        // 或者 return 数据给 template 使用
        return { list };
      },

      template: `
        <ul class="list">
          <li class="item" v-for="item in this.list" @click="this.itemClick">
            {{ item }}
          </li>
          <li><Cpn></Cpn></li>
        </ul>
      `,
    });

    createApp(App).mount("#app");
  </script>
</html>
```

### 1.2 单文件组件（SFC）

最常用的写法，允许在 \.vue 文件编写代码。

氛围 script 、template 、style ：

* script ，编写 JS ，必须导出一个组件的配置对象

* template ，编写 html ，最终编译为 render 函数：
  
  - template 是编译时，不生成虚拟 DOM ，不渲染真实 DOM ，只作包裹作用
  - 只能使用编译时指令

* style ，编写样式：
  
  - scoped ：样式不会影响外部但会受到外部影响，原理是设置 scoped 后组件内的 html 元素会多一个自定义属性 data-v\-xxx ，再用属性选择器
  - 一般 App 不加 scoped ，做一些全局样式；其他组件加 scoped ，防止冲突

Vue2 、Vue3 区别：

* Vue2 template 必须要有一个根元素，用于虚拟 DOM 插入；Vue3 的 \<template\> 不再必须有一个根元素，原理是 Vue3 没有根元素时会自动加上一个虚拟元素 Fragment ：
  
  - 若有一个根元素，则不使用 Fragment ，这个组件的根节点就是这个根元素，行盒、块盒由根元素决定
  
  - 若没有根元素，而是多根元素的形式，就会用一个空文本节点作为根节点，但只是用在虚拟 DOM ，不渲染
  
  - 若没有任何元素，则就是一个空注释节点，同样也只用在虚拟 DOM ，不渲染

* 除了模板最外层和插槽外，其他地方也可以使用 template 作为包裹容器（不生成虚拟 DOM ，也不会渲染为真实 DOM），但这些 template 在 Vue2 、Vue3 编译行为不同：
  
  ```
  <script setup lang="ts">
  import { ref } from "vue";
  const isShow = ref(true);
  </script>
  
  <template>
    <div>
      <button @click="isShow = !isShow">click</button>
  
      <!-- Vue2 、Vue3 编译区别
         * Vue2：不会生成虚拟 DOM 、不渲染成真实 DOM ，只作包裹作用
         * Vue3：只有在使用了 template 可以使用的指令（如 v-if），行为才和 Vue2 一样，其他情况如没有任何指令，
                 就会真的渲染到真实 DOM ，这种情况由于 <template> 是非法的 html 标签，内容就显示不出来 
      -->
      <!-- <template> -->
      <template v-if="isShow">
        <p v-for="i in 5">{{ i }}</p>
      </template>
    </div>
  </template>
  ```

* 修改带有 scoped 的子组件样式可以使用样式穿透，Vue2 使用 /deep/ select ，Vue3 使用 \:deep\(select\)

Vue2 ：

```
<script>
// 导入样式，但一般不会这么做，都是写在 vue 文件的 <style> 中，或在 main.js 中导入全局样式
// import "./xxx.css";

// 定义子组件，但一般不会这么做，都是导入一个单独的 vue 文件
const Cpn = {
  render(h) {
    return h("p", "Cpn");
  },
};

// 可以导出资源
// export const a = 0;

// Vue2 响应式会修改原始数据
const obj = { a: 1 };

// 导出组件
export default {
  // this 指向 Vue 组件实例

  components: { Cpn },

  /**data ，都是响应式数据
   * 除根组件 App 外，其他组件的 data 必须是函数 return obj 的形式，这是为了防止组件多次使用的 data 冲突
   * 当然 App 也可以用函数形式
   */
  data() {
    return {
      list: [10, 20, 30],
      obj,
    };
  },

  methods: {
    itemClick(e) {
      console.log(e);
    },
  },

  mounted() {
    // true ，Vue2 响应式给原始数据使用 Object.defineProperty
    console.log(obj === this.obj);
  },
};
</script>

<template>
  <ul class="list">
    <!-- 可以省略 this -->
    <li class="item" v-for="item in list" :key="item" @click="itemClick(item)">
      {{ item }}
    </li>
    <li>
      <Cpn />
    </li>
  </ul>
</template>

<style scoped>
/* 引入样式，会受到 scoped 影响加上属性选择器 */
/* @import "./1.css"; */

/**修改有 scoped 的子组件样式，如组件库
 * 在无 scoped 的组件如 App.vue 修改，写对应的选择器
 * 在有 scoped 的组件用样式穿透 /deep/ 修改
 */
/deep/ .el-input__inner {
}
</style>
```

Vue3 ：

```
<script setup lang="ts">
// script setup ，Vue3.2 支持

import { ref, reactive, toRef } from "vue";

// 响应式、函数等 ------------------------------------------------------------------------
const obj = { a: 1 };

// ref ，定义基本类型的响应式数据，若传入引用类型，则会再使用 reactive
const d1 = ref(0);
const d2 = ref(obj);
// ref 用 Object.defineProperty 的 ES6 语法糖访问器实现，所以需要 .value
console.log(d1.value, d2.value);

// reactive ，定义引用类型的响应式数据
const d3 = reactive(obj);
// reactive 使用 Proxy 实现
console.log(d3, d3.a);
// false ，所以不会处理原始数据，而是得到一个新对象
console.log(d3 === obj);

// 函数
const func = (e: MouseEvent) => console.log(e);

// 注意 -------------------------------------------------------------------------------------
const t1 = ref(0);
const t2 = reactive({ a: 1 });

// 谨慎响应式丢失，如取出原始值
const t3 = t1.value;
const t4 = t2.a;
console.log(t3, t4);
// 可以用 toRef 解决响应式丢失问题
const t5 = toRef(t1, "value");
const t6 = toRef(t2, "a");
console.log(t5, t6);
// true true ，和 ref 的区别是，toRef 会和原来的数据关联
t5.value = 123;
t6.value = 123;
console.log(t5.value === t1.value, t6.value === t2.a);

// 禁止直接赋值，重新赋值就不是原来的响应式数据了
let t7 = ref({ a: 1 });
// t7 = ref({ b: 2 });
// 正确做法，如果是 reactive ，就只能遍历 key 处理了
t7.value = { b: 2 };

// 其他 -------------------------------------------------------------------------------
// 定义 Options API ，defineOptions 是一个宏定义，不需要导入
defineOptions({
  name: "Cpn",
});

// script setup 中只能导入类型，且不能默认导出
// export type T = number;
</script>

<!-- 
<script lang="ts">
// Vue3 基础写法，script setup 会编译为这种形式

import { defineComponent, ref, reactive, toRef, toRefs, h } from "vue";

// 和 Vue2 一样可以 export ，不像 script setup 只能 export 类型
// export const a = 1;
// export type T = number;

// 使用 defineComponent 是为了得到 ts 类型提示，也可以不用
export default defineComponent({
  name: "Cpn",

  setup() {
    const d1 = ref(0);
    const d2 = reactive({ a: 1 });
    const d3 = ref({ a: 1 });
    const func = (e: MouseEvent) => console.log(e);

    // 只有 return 的资源，template 才能使用；script setup 编译后自动补上 return
    return { d1, d2, d3, func };

    // 也可以把资源都放到一个变量中，在使用 toRefs
    // return { ...toRefs(data) };

    // 也可以 return render 函数，覆盖 template
    // return () => h("p", "123");
  },
});
</script> 
-->

<!-- 不需要根元素，会自动加上虚拟节点 Fragment -->
<template>
  <!-- ref 可以省略 .value -->
  <p>{{ d1 }}</p>
  <p>{{ d2 }}</p>
  <p>{{ d3 }}</p>
  <button @click="func">click</button>
</template>

<style scoped lang="less">
// 样式穿透
:deep(.box) {
}

// 也可以指定穿透某个组件的样式
:deep(ChildCpn 。box) {
}
</style>
```

defineOptions 在 Vue3.4 才支持，若版本不够且使用 script setup ，择有两种方式：

* 写两个 \<script\> ，lang 必须一样；
  
  ```
  <script setup lang="ts"></script>
  
  <script lang="ts">
  // 多个 script 属于不同的作用域，变量不共享，但资源不用重复导入
  export default {
    name: "Cpn",
  };
  </script>
  
  <template></template>
  ```

* 使用 vite 插件，如配置组件 name ：
  
  ```
  npm install -D vite-plugin-vue-setup-extend
  ```
  
  ```
  // /src/vite.config.ts
  
  import vueSetupExtend from "vite-plugin-vue-setup-extend";
  
  export default defineConfig({
    plugins: [vue(), vueSetupExtend()],
  });
  ```
  
  ```
  <script setup lang="ts" name="home"></script>
  ```

### 1.3 JSX

```
pnpm add vue @vitejs/plugin-vue @vitejs/plugin-vue-jsx -D
```

```
// vite.config.ts

import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import vueJsx from "@vitejs/plugin-vue-jsx";

export default defineConfig({
  plugins: [
    vue(), // 支持 .vue 文件
    vueJsx(),
  ],
});
```

```
// Cpn.tex ， css 可以使用 css in js 、style component 等，这里就不写了

import { defineComponent, onMounted } from "vue";

// defineComponent 可以传入 props 泛型，但是运行时还要配置 props 选项，所以就不用泛型了
export default defineComponent({
  props: { count: { type: Number, required: true } },
  emits: ["add"],

  setup(props, { emit }) {
    onMounted(() => console.log("mount"));

    // 注意，返回一个 render 函数
    return () => (
      <p>
        <button onClick={() => emit("add")}>add</button>
        <span>{" " + props.count}</span>
      </p>
    );
  },
});

// Vue 的函数式组件使用 props 等比较方便，但只作纯渲染，无法使用 Composition API
// interface Props {
//   count: number;
// }
// export default function Cpn(props: Props) {
//   // err
//   // onMounted(() => console.log("mount"));

//   return <p>{props.count}</p>;
// }
```

```
<script setup lang="ts">
// App.vue ，单文件组件和 JSX 可以互相导入使用
import { ref } from "vue";
import Cpn from "./Cpn";
const count = ref(0);
</script>

<template>
  <Cpn :count="count" @add="++count" />
</template>
```

## 2 语法

Vue2 中，在非生产环境会有提示（Vue3 则没有），这个提示是为了提醒开发者：上线时要开启生产模式（通过构建工具，打包压缩，去除调试信息等，这个提示可以关闭：

```
// /src/main.js
Vue.config.productionTio = false;
```

Vue2 入口：

```
// /src/main.js

import Vue from "vue";
import App from "./App.vue";

Vue.config.productionTip = false;

new Vue({
  render: (h) => h(App),
}).$mount("#app");
```

Vue3 入口：

```
// /src/main.ts

import { createApp } from "vue";
import App from "./App.vue";

const app = createApp(App);
app.mount("#app");
```

### 2.1 插值语法、数据绑定、指令、事件绑定

Vue 指令分类：

* 编译时指令，直接影响编译后的 render 函数：
  
  * 指令：v\-for 、v\-if 、v\-else\-if 、v\-else 、v\-pre 、v\-once、v\-memo 
  
  * 可用范围：任何节点，包括 template 、slot 这些不生成虚拟 DOM 也不会渲染真实 DOM 的站位节点、只是它们使用 pre 、once 、memo 没有意义

* 运行时指令，运行时才起作用：
  
  * 指令：除了编译时外的其他指令，包括自定义指令
  
  * 可用范围：只能用在真实的元素节点：
    
    * 其中 v\-model 只能用在表单、组件，若 v\-model 、v\-bind 、v\-on 用在组件，则用 props 和 emit 接收
    
    * templat 、slot 使用 v\-bind 是用于传值，而不是绑定真实元素属性，所以可以使用
    
    * 其中 v-text 、v-html 用在组件实际上是传入 attrs ，此时子组件必须有且一个根元素
    
    * 若使用在内置组件：
      
      * Component ：可以使用，因为会渲染为真是元素
      
      * Teleport ：本身可以使用，但是作为子组件跟元素时，父组件中无法使用
      
      * Fragment 、keep\-alive 等其他内置组件：若未传入插槽，则 Vue 会直接忽略，所以即使使用这些指令也不会报错；同样的传入插槽后再使用这些指令就会报错

Vue2 ，Vue3 用法基本一样，区别：

* Vue2 、Vue3 的自定义指令的回调函数名字不同

* Vue3 新增指令 v\-memo

* Vue3 删除了事件修饰符 navtie 、keycode

* Vue3 新增 CSS 相关新特性：
  
  * style v\-bind ；支持在 CSS 中绑定 JS 变量，原理是 JS 添加 CSS 变量
  
  * CSS Module ：支持写多个 \<style\> 并标注 module ，每个 CSS Module 都是独立的

Vue2 ：

```
<script>
// Vue2

export default {
  data() {
    return {
      text: "msg",
    };
  },

  methods: {
    func: () => console.log("func"),
  },

  // 自定义指令，只有 3 个钩子
  directives: {
    yyy: {
      bind(e, binding) {},
      inserted(e, binding) {
        console.log("yyy mounted");
      },
      update(e, binding) {},
    },
  },
};
</script>

<template>
  <div>
    <!-- this 可以省略，编译模板时会补上 -->

    <div>{{ text }}</div>
    <div v-yyy></div>
    <button @click="func">click</button>

    <!-- 使得组件可以监听原生事件、Vue3 已删除
       * 组件绑定的事件默认会认为是自定义事件、Vue3 更是只认 emits 声明的事件
       * .native 其实是给组件根元素绑定事件，不推荐，所以 Vue3 就删除了，让具体触发
         事件的元素 emit 自定义事件即可
      -->
    <!-- <Cpn @click.native="console.log('native')">native</Cpn> -->

    <!-- keycode 修饰符，按下某个案件触发,Vue3 已删除，原因是兼容性差
       * 若要使用 keycode，只能用原生 JS
       * input 的 enter 键，可以用 <form> 包裹 input 、监听 submit 即可
      -->
    <div @keydown.13="console.log('keycode')">keycode</div>
  </div>
</template>

<style scoped></style>
```

Vue3 ：

```
<script setup lang="ts">
// Vue3

import { ref, reactive, useCssModule } from "vue";
import type { Directive, DirectiveBinding } from "vue";

// 数据、函数 ----------------------------------------------------------------------------------
// 响应式数据，用 ref 、reactive 定义
const hello = ref("hello");
const inpValue = ref(123);
const isDisable = ref(true);
const title = ref("title");
const titleClass2 = ref("title2");

// style v-bind ，根据需求，看是否需要响应式
const size = "50px";
const border = ref("1px solid #000");
const center = reactive({
  a: "center",
});

// 默认 CSS Module 和其他 CSS Module ，若需要 JS 操作则可以使用 hook
// const dm = useCssModule();
// const m1 = useCssModule("m1");

// v-memo
const memoValue = ref(123);

// 函数
function say() {
  return "world";
}

// 事件 -----------------------------------------------------------------------------
const click1 = (): void => console.log("click 1");

const click2 = (e: MouseEvent): void => console.log("click 2", e);

const click3 = (num: number, e: MouseEvent): void =>
  console.log("click 3", num, e);

const click4 = (a: number, b: number): void => console.log("click 4 ，", a, b);

/**自定义指令 ------------------------------------------------------------------------------------
 * 共 7 个钩子 ，从 created 到 unMounted
 * 原始写法是 Options API ，也可以在 script setup 中写但必须加上 v 前缀，以便编译处理
 *
 */
// 简写
const vXxx = (el: HTMLElement, dir: DirectiveBinding) => {
  console.log("v-xxx", dir.value, el);
};

// 完整写法
const vYyy: Directive = {
  mounted(el: HTMLElement, dir: DirectiveBinding) {
    console.log("v-yyy", dir.value, el);
  },
};
</script>

<!-- Options API 自定义指令 --------------------------------------------------------------------->
<script lang="ts">
import { defineComponent } from "vue";

export default defineComponent({
  directives: {
    zzz(el: HTMLElement, dir: DirectiveBinding) {
      console.log("v-zzz", dir.value, el);
    },
  },
});
</script>

<template>
  <!-- 插值语法，也叫 Mustache 语法，内容为 JS 表达式，作用是使用 Model -->
  <div>{{ hello + " " + say() }}</div>

  <!-- 数据绑定指令，v-bind 可以省略 -->
  <input type="text" v-bind:value="inpValue" :disabled="isDisable" />

  <!-- 绑定样式 ---------------------------------------------------->
  <p class="title1" :class="titleClass2">{{ title }}</p>

  <p :class="{ title1: true, [titleClass2]: true }">{{ title }}</p>

  <p :style="{ backgroundColor: '#000', color: '#fff' }">{{ title }}</p>

  <p :style="[{ backgroundColor: '#000' }, { color: '#fff' }]">
    {{ title }}
  </p>

  <!-- style v-bind -->
  <div class="box">box</div>

  <!-- CSS Module -->
  <div class="a b c">无效，CSS Module 是独立的</div>
  <div :class="$style.a">默认 module</div>
  <div :class="[m1.b, m1.c]">m1</div>

  <!-- 指令 ---------------------------------------------------->
  <!-- v-once ，只 render 一次，并缓存，以后每次 render 都会忽略它 -->
  <div v-once>v-once</div>

  <!-- v-pre ，跳过模板编译，如不解析差值语法 -->
  <div v-pre>{{ 不解析插值语法 }}</div>

  <!-- v-cloak ，JS 未解析完成时，隐藏该元素（display: none;），防止闪烁 -->
  <div v-cloak>v-clock</div>

  <!-- v-text 、v-html，即 innerText、innerHTML -->
  <div v-text="'123'"></div>
  <div v-html="'<input />'"></div>

  <!-- v-memo ，缓存
     - 只有依赖的数据变化时才会重新 render，无变化直接跳过 VDOM 构建、diff 和 patch 
     * 空数组即等价于 v-once
     * 为了避免不必要的错误，v-for 的 item 不要使用 v-memo ，只能和 v-for 用在一个元素中
  -->
  <div v-memo="[memoValue]">v-memo</div>

  <!-- 自定义指令 -->
  <div v-xxx="'a'" v-yyy v-zzz></div>

  <!-- v-on 绑定事件，可以简写为 @ -------------------------------------------------------->
  <ul>
    <!-- 只有一行逻辑就可以简写 -->
    <li @click="console.log('click 0')">click 0</li>

    <!-- 无参 -->
    <li @click="click1">click 1</li>

    <!-- 简写则默认传入 $event，也可以主动控制传入 $event -->
    <li @click="click2">click 2-1</li>
    <li @click="click2($event)">click 2-2</li>
    <li @click="click3(1, $event)">click 3</li>

    <!-- 不需要 $event -->
    <li @click="click4(1, 2)">click 4</li>

    <!-- 事件修饰符 -->
    <li @click.stop="console.log('stop')">阻止事件冒泡</li>
    <li @click.prevent="console.log('prevent')">阻止默认行为</li>
    <li @click.once="console.log('once')">只执行一次</li>
  </ul>
</template>

<style scoped lang="less">
.title1 {
  background-color: #000;
}

.title2 {
  color: #fff;
}

.box {
  font-size: v-bind("size");
  border: v-bind("border");
  text-align: v-bind("center.a");
}
</style>

<!-- CSS Module ----------------------------------------------------------------------------------- -->
<style module scoped lang="less">
.a {
  width: 100px;
  height: 100px;
  border: 1px solid #000;
}
</style>

<style module="m1" scoped lang="less">
.b {
  width: 50px;
}

.c {
  height: 50px;
  border: 10px solid #000;
}
</style>
```

### 2.2 表单 v-model 双向绑定

Vue2 ，Vue3 用法一样：

* 用于绑定表单，是数据绑定、事件绑定的语法糖，所以必须传入响应式数据：
  
  * ttext 、textarea 等默认绑定 value ，监听 input 事件，由于每次输入撤销都会重新 render ，性能就比较差，特别是有动画的场景，解决方法：
    
    * 使用 lazy 修饰符改为 change 事件，只有 enter 或失焦才触发
    
    * 使用防抖，最佳实现是 Vue3 的 customRef
  
  * radio 、checkbox 绑定 checked 和 change
  
  * select 绑定 value 和 change

* from 的 reset 只会清空表单信息，不会同步到 v\-model 的响应式数据，需要自己手动修改

示例：

```
<script>
// Vue2

export default {
  data() {
    return {
      text: "msg",
    };
  },
};
</script>

<template>
  <div>
    <input type="text" v-model="text" />
    <span>{{ text }}</span>
  </div>
</template>

<style scoped></style>
```

```
<script setup lang="ts">
// Vue3

import { ref, reactive } from "vue";

const inpValue = ref("input");
const textAreaValue = ref("textarea");

const radios = reactive({
  value: "b",
  items: [
    { value: "a", text: "选项 A" },
    { value: "b", text: "选项 B" },
    { value: "c", text: "选项 C" },
    { value: "d", text: "选项 D" },
  ],
});

const checkboxs = reactive({
  value: ["b", "c"],
  items: [
    { value: "a", text: "选项 A" },
    { value: "b", text: "选项 B" },
    { value: "c", text: "选项 C" },
    { value: "d", text: "选项 D" },
  ],
});

const agree = ref(true);

const select = reactive({
  value: "2000",
  items: [
    { value: "", text: "请选择年份" },
    { value: "1999", text: "1999年" },
    { value: "2000", text: "2000年" },
    { value: "2001", text: "2001年" },
  ],
});

const inp1 = ref("1");
const inp2 = ref<string | number>("2");
const inp3 = ref("3");
</script>

<template>
  <!-- text、textarea ， :value @input -->
  <div>
    <input type="text" v-model="inpValue" />
    <span>{{ inpValue }}</span>
  </div>
  <div>
    <textarea v-model="textAreaValue"></textarea>
    <span>{{ textAreaValue }}</span>
  </div>

  <!-- radio ， :checked @change -->
  <div>
    <label v-for="i in radios.items" :key="i.value">
      <input type="radio" v-model="radios.value" :value="i.value" />
      <span>{{ i.text }}</span>
    </label>
    <p>我已选中 {{ radios.value }}</p>
  </div>

  <!-- checkbox :checked @change -->
  <div>
    <label v-for="i in checkboxs.items" :key="i.value">
      <input type="checkbox" v-model="checkboxs.value" :value="i.value" />
      <span>{{ i.text }}</span>
    </label>
    <p>我已选中 {{ checkboxs.value }}</p>
  </div>

  <!-- 单个 checkbox ， :checked @change -->
  <div>
    <label for="single">
      <input type="checkbox" id="single" v-model="agree" />
      <span>{{ agree }}</span>
    </label>
  </div>

  <!-- select ， :value @change -->
  <div>
    <select v-model="select.value">
      <option v-for="i in select.items" :key="i.value" :value="i.value">
        {{ i.text }}
      </option>
    </select>
  </div>

  <!-- 表单 v-model 修饰符 -------------------------------------------------------------->
  <!-- 改为 change 事件 -->
  <div>
    <input type="text" v-model.lazy="inp1" />
    <span>{{ inp1 }}</span>
  </div>

  <!--转为 number 
    * 若初始绑定为 string 则还是 string ，需要触发 input 才转 number 
    * 空字符串不转换
    * 若将转为 NaN ，则会去掉后面的字符，直到能转为正常数字为止，如 2a3 转为 2 ，2.. 转为 2
  -->
  <div>
    <input type="text" v-model.number="inp2" />
    <span>{{ inp2 }}</span>
    <span>{{ " " + typeof inp2 }}</span>
  </div>

  <!-- 去掉 string 首尾空格 -->
  <div>
    <input type="text" v-model.trim="inp3" />
    <span>{{ inp3 }}</span>
  </div>
</template>

<style scoped lang="less">
input,
textarea,
select {
  margin: 10px;
}
</style>
```

Vue3 customRef 实现表单 v\-model 防抖：

```
// /src/hooks/vmodel.ts

import { customRef } from "vue";

export function useDebouncedRef<T>(value: T, delay = 1000) {
  let timeout: ReturnType<typeof setTimeout>;

  return customRef<T>((track, trigger) => {
    let current = value;

    return {
      get() {
        track();
        return current;
      },

      set(newValue: T) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          current = newValue;
          trigger();
        }, delay);
      },
    };
  });
}
```

```
<script setup lang="ts">
import { useDebouncedRef } from "@/hooks/vmodel";
const text = useDebouncedRef("msg", 500);
</script>

<template>
  <input type="text" v-model="text" />
  <span>{{ text }}</span>
</template>
```

### 2.3 计算属性、过滤器、侦听器

Vue2 ，Vue3 用法基本一样，区别：

* Vue3 都是 Composition API
  
  * Vue3 的 watch 接收 2 个函数参数，第 1 个为 effect（若不是函数则会参数归一化为函数），第 2 个不是 effect 而只是在 effect 调用完后执行‘；Vue2 只能配置一个函数，即 Vue3 watch 的第 2 个函数参数
  
  * Vue2 的 watch 配置项 immediate 、deep 默认值都是 false ；Vue3 的 immediate 默认为 false ，deep 默认为 true
  
  * ue3 watch 可以同时监听多个数据
  
  * Vue3 watch 引用类型的 oldVal 有 bug ，值为 newVal

* Vue3 删除了过滤器，新增 watchEffect

Vue 的 effect ：

* Vue 的 effect 是响应式数据变化后，派发更新执行的函数

* Vue 的 effect 只有 4 种：render 、computed 、watch 、watchEffect

不同 effect 区别；

- 应用场景不同：
  
  * render 渲染
  
  * computed 主要是做数据处理
  
  * watch 、watchEffect 则在数据变化时处理一些逻辑，且 watch 在 Vue3 才支持同时监听多个数据

- track 不同：
  
  * watch 在 Vue3 有两个函数参数：
    
    * 第一个函数参数初始就会执行一次，进行 track ，若这个参数不是函数，watch 内部也会转为函数；监听的数据变化就会重新执行这个函数
    
    * 第二个函数参数：等价于 Vue2 watch 的函数，注意这个不是 effect ，不需要 track ，初始不会执行除非 immdiate 为 true ，监听的数据变化会重新执行这个函数是因为这个函数是第一个函数参数执行完后再执行
  
  * watchEffect 的函数参数是 effect ，初始需要执行一次进行 track
  
  * computed 的 effect 只有在 dirty 为 true 且 get 后才会执行，初始 dirty 为 true ，没有 get 就不会执行
  
  * 当 effect 为异步函数时需要注意，异步 get 的响应式数据无法 track ；watch 的第二个函数参数不是 effect 所以可以放心使用异步

- trigger 不同：
  
  * render 、watch 、watchEffect 在依赖数据变化后马上执行
  
  * computed 在依赖数据变化后只会设置 dirty 为 true ，不会马上重新执行，直到再次被 get

代码：

```
<script>
// Vue2

export default {
  data() {
    return {
      a: 1,
      b: 2,
      obj: { k1: 4, k2: { kk: 5 } },
    };
  },

  computed: {
    // 简写
    sum() {
      console.log("computed sum run");
      return this.a + this.b;
    },
  },

  // 过滤器，Vue3 已删除，完全可以用 computed、function 代替
  filters: {
    myToFixed(value) {
      return Math.round(value);
    },
  },

  watch: {
    obj: {
      handler(newVal, oldVal) {
        console.log("obj", newVal, oldVal);
      },

      immediate: true,
      deep: true,
    },

    "obj.k1": function (newVal, oldVal) {
      console.log("obj.k1", newVal, oldVal);
    },
  },
};
</script>

<template>
  <div>
    <div>
      <span>{{ sum }}</span>
      <button @click="++a">add a</button>
    </div>

    <div>{{ 3.14 | myToFixed }}</div>

    <div>
      <button @click="++obj.k2.kk">watch obj</button>
      <button @click="++obj.k1">watch obj.k1</button>
    </div>
  </div>
</template>

<style scoped>
button {
  margin: 0 10px;
}
</style>
```

```
<script setup lang="ts">
// Vue3

import { ref, reactive, computed, watch, watchEffect } from "vue";

/**计算属性 --------------------------------------------------------------------------------
 * 当成属性使用，所以无法传参；不能 return function
 * 具有缓存功能，内部通过 dirty 判断是否需要重新执行 getter（dirty 初始为 true）：
   - 模板中多个相同 computed 只会执行一次 getter ，因为执行一次后 dirty 就设为 false ；而函数每个都会执行
   - 只有依赖的响应式数据修改了，dirty 设为 true 且再次被 get 才会重新执行 getter ；而函数每次重新 render 都会执行
 */
const a = ref(1);
const b = ref(2);

// 简写
const sum1 = computed(() => {
  console.log("computed sum1 run");
  return a.value + b.value;
});

// 返回一个 ref 对象
console.log(sum1.value);

// 完整写法
const sum2 = computed({
  get() {
    console.log("computed sum2 get run");
    return a.value + b.value;
  },

  // 参数类型会自动推断
  set(newValue) {
    console.log("computed sum2 set run", newValue);

    // err ，setter 不能修改计算属性本身，只用来处理一些逻辑
    // sum2 = newValue;
  },
});

/**侦听器 ----------------------------------------------------------------------------------
 * 用于监听响应式数据的变化，第一个参数为 effect（不是函数则会转为函数），第二个参数为 effect 执行完成后回调的函数
 * 响应式数据可以传入单个，也可以是数组形式传入多个，多个则 oldValue 、newValue 也是数组
 * 第二个函数一开始不执行，除非设置了 immediate ；deep 控制是否深度监听
 */
const c = ref(3);
const obj = reactive({ k1: 4, k2: { kk: 5 } });

// 简写，回调的参数类型会自动推断
watch(c, (newVal, oldVal) => {
  console.log("watch c run", newVal, oldVal);
});

// 完整写法并监听多个
watch(
  [c, obj],
  (newVal, oldVal) => {
    console.log("watch [c, obj] run", newVal, oldVal);

    // true true ，Vue3 监听引用类型的 oldVal 有 bug ，值为 newVal ；immediate 首次 oldVal 为 undefined 才为 false
    console.log(oldVal[1]?.k1 === newVal[1]?.k1);
    console.log(oldVal[1]?.k2.kk === newVal[1]?.k2.kk);
  },
  { immediate: true, deep: true }
);

// 第一个参数完整写法是一个函数
watch(
  () => obj.k1,
  (newVal, oldVal) => {
    console.log("watch obj.k1 run", newVal, oldVal);

    // console.log()
  }
);

/**watchEffect -----------------------------------------------------------------------------------
 * 内部使用的响应式数据变化时，就重新执行
 * 一开始执行一次，进行 track
 */
watchEffect(() => {
  a.value;
  b.value;
  console.log('watchEffect run""');
});
</script>

<template>
  <!-- 计算属性，watchEffect 测试 -->
  <div>
    <span>sum1：{{ sum1 + " , " }}</span>
    <span>sum2：{{ sum2 }}</span>
  </div>
  <div>
    <button @click="++a">add a</button>
    <button @click="++b">add b</button>
    <button @click="sum2 = 123">set sum2</button>
  </div>

  <!-- watch 测试 -->
  <div>
    <button @click="++c">test watch c ，add c</button>
    <button @click="++obj.k2.kk">test watch [c, obj] ，add obj.k2.kk</button>
    <button @click="++obj.k1">test watch obj.k1 ，add obj.k1</button>
  </div>
</template>

<style scoped lang="less">
button {
  margin: 10px 10px 10px 0;
}
</style>
```

可传参的 computed ：

```
<script setup lang="ts">
import { ref, reactive, computed } from "vue";
import type { ComputedRef } from "vue";

const list = reactive<Array<{ id: number; value: number }>>([]);
for (let i = 1; i <= 5; i++) list.push({ id: i, value: i });

function changeData() {
  for (const i of list) ++i.value;
}

const num = ref(2);
const clickedId = ref(0);

// 每次点击 li 都会重新执行 ---------------------------------------------------------------------
// function sum(value: number) {
//   console.log("func run");
//   return value * num.value;
// }

// 可传参的 computed -----------------------------------------------------------------------------
function useComputed<A extends any[], R>(
  callback: (...args: A) => R
): (...args: A) => R {
  const computedMap = new Map<A, ComputedRef<R>>();

  const compareKey = (args1: A, args2: A) => {
    if (args1.length !== args2.length) return false;

    for (let i = 0; i < args1.length; i++) {
      if (!Object.is(args1[i], args2[i])) return false;
    }

    return true;
  };

  // 返回一个新函数
  return (...args) => {
    const key = [...computedMap.keys()].find((key) => compareKey(key, args));
    if (key) return computedMap.get(key)!.value;

    const result = computed(() => callback(...args));
    computedMap.set(args, result);

    return result.value;
  };
}

const sum = useComputed((value: number) => {
  console.log("func run");
  return value * num.value;
});
</script>

<template>
  <button @click="changeData">change data</button>
  <button @click="++num">增加倍率 num</button>

  <ul>
    <li
      v-for="i in list"
      :class="{ clicked: clickedId === i.id }"
      @click="clickedId = i.id"
    >
      <span>{{ i.value }}</span>
      <span>{{ sum(i.value) }}</span>
    </li>
  </ul>
</template>

<style scoped lang="less">
span {
  margin-right: 20px;
}

.clicked {
  border: 1px solid #000;
}
</style>
```

嵌套 effect ：

* 响应式源码中，用一个栈保存嵌套的 effect ：
  
  * track 只会收集最近的 effect 即栈顶 effect  ，因此栈对 render 嵌套 render 并无作用
  
  * 使用栈是因为 computed 本身也是 ref ，也需要 track

* 嵌套 effect 只有梁总情况：
  
  * render 嵌套 render（即组件嵌套），响应式数据只会 track 最近的 render effect ，即栈顶的 effect ：
    
    * 若传给子组件的是 ref ：由于父 render 传参需要 \.value ，因此这个 ref 数据就会 track 父 render ，但不会 track 子组件 render 因为子组件只接收到 value
      
      * ref 变化后，重新执行父 render ，子组件虽然没有被 track ，但 props 由于也变化了，也会重新执行子 render
    
    * 若传给子组件的是 rective ：由于是传的引用，不需要父组件 get ，因此不会 track 父 render ；当子组件 get 这个 reactive ，就会 track 子 render
      
      * 因此 reactive 变化，只会重新执行子 render
    
    * 若响应式数据没有给子组件，仅父组件使用且 get ，当响应式数据变化，重新执行父 render ，子 render 既没有被 track ，props 也没有变化所以不会重新执行
    
    * 实例：
      
      ```
      <script setup lang="ts">
      // 子组件
      
      import { onBeforeUpdate } from "vue";
      
      defineProps<{ cnt: number; data: { cnt: number } }>();
      defineEmits(["addCnt", "addDataCnt"]);
      
      onBeforeUpdate(() => console.log("Cpn"));
      </script>
      
      <template>
        <p>{{ cnt }}</p>
        <p>{{ data.cnt }}</p>
      </template>
      ```
      
      ```
      <script setup lang="ts">
      // 父组件
      
      import { ref, reactive, onBeforeUpdate } from "vue";
      import Cpn from "./Cpn.vue";
      
      const c = ref(0);
      const cnt = ref(0);
      const data = reactive({ cnt: 0 });
      
      onBeforeUpdate(() => console.log("App"));
      
      // 输出：App
      setTimeout(() => ++c.value, 1000);
      // 输出：App Cpn
      setTimeout(() => ++cnt.value, 2000);
      // 输出：Cpn
      setTimeout(() => ++data.cnt, 3000);
      </script>
      
      <template>
        <p>{{ c }}</p>
        <Cpn :cnt="cnt" :data="data" />
      </template>
      ```

* computed 被任意 effect 嵌套：
  
  * 依赖的数据变化只会把 computed 的 dirty 设置为 true ，不会马上重新执行，但由于 computed 本身也是一个 ref ，也会 track 外层 effect ，设置 dirty 为 true 后会马上 trigger 外层 effect ，使得外层 effect 重新执行并再次 get computed ，因此 computed 才会重新执行
  
  * 若外层还是 computed ，则 trigger 也只会设置外层 dirty 为 true ，不会重新执行外层 computed
  
  * Vue3.5 优化：在执行外层 effect 之前，会先执行 dirty 的 computed ，检查 computed 是否真正变化了，若没有变化则不执行外层 effect （比如 computed 依赖多个数据，虽然多个数据修改使得 computed 变为 dirty ，但是可能 computed 的 value 没有变化），提升性能
  
  * 实例：
    
    ```
    <script setup lang="ts">
    import { ref, computed, watchEffect } from "vue";
    
    const a = ref(1);
    const b = ref(2);
    
    const sum = computed(() => {
      console.log("sum");
      return a.value + b.value;
    });
    
    watchEffect(() => {
      console.log("watchEffect");
      sum.value;
    });
    
    /**输出
     * 3.5 之前：watchEffect sum ，因为修改 cnt 使得 sum 的 dirty 为 true ，sum trigger watchEffect 重新执行，执行过程中再次 get sum
     * 3.5：sum watchEffect ，因为在执行 watchEffect 之前，先执行 sum 判断是否有变化，有变化再执行 watchEffect
     */
    setTimeout(() => ++a.value, 1000);
    
    /**输出
     * 3.5 之前：watchEffect sum
     * 3.5：sum ，因为执行 sum 后发现没有变化，就不执行 watchEffect 了
     */
    setTimeout(() => {
      ++a.value;
      --b.value;
    }, 2000);
    </script>
    ```

### 2.4 条件渲染、列表渲染

Vue2 ，Vue3 基本一样，区别：

* Vue2 的 v\-if 优先级低于 v\-for ，一起使用则 warn ，因为便利出来再删除没有必要也浪费性能

* Vue3 的 v\-if 优先级高于 v\-for ，一起使用时，若 v\-if 使用了 v\-for 的变量则 err ，因为 if 的时候元素还没有便利出来；若 v\-if 不使用 v\-for 的变量则不会 err 、warn ，但是也最好不要这么做，直接在父容器 v\-if 性能更好，不用多次比较

* v\-if 。v\-for 一起使用的替代：
  
  - 渲染部分子项的场景，使用 computed filter 一个新 Array
  
  - 显示隐藏整个 list 的场景，v\-if 父容器，如 template 

v\-if 、v\-show 的区别：

* false 时，v\-if 直接删除元素，适合不需要重复切换的场景，提升初始性能

* false 时，v\-show 则设置 display: none; ，适合需要平凡切换的场景，防止删除元素消耗性能

* 因此两者一起使用，v\-if 生效，应该避免这么做

```
<script>
export default {
  data() {
    return {
      isShow: true,
      list: [
        { id: 1, value: 10 },
        { id: 2, value: 20 },
        { id: 3, value: 30 },
      ],
    };
  },
};
</script>

<template>
  <div>
    <div>
      <button @click="isShow = !isShow">switch show</button>
      <div v-show="isShow">v-show</div>
      <div v-if="isShow">v-if</div>
    </div>

    <ul>
      <li v-for="i in list" :key="i.id">{{ i.value }}</li>
    </ul>
  </div>
</template>
```

```
<script setup lang="ts">
// Vue3

import { ref, reactive, computed } from "vue";

const isShow = ref(true);

const list = reactive([
  { id: 1, value: 10 },
  { id: 2, value: 20 },
  { id: 3, value: 30 },
]);

const filterList = computed(() => {
  return list.filter((i: (typeof list)[0]) => i.value > 15);
});
</script>

<template>
  <!-- 条件渲染 
     * v-show 和 v-if、v-else、v-else-if
     * v-if 优先级高于 v-show ，只有 v-if 显示元素时，v-show 才有意义
     * v-show、v-if 和 v-once 一起使用时，由于 v-once 只渲染一次，所以显示隐藏状态只会是初始状态 
  -->
  <div>
    <button @click="isShow = !isShow">switch show</button>
    <div v-show="isShow">v-show</div>
    <div v-if="isShow">v-if</div>
  </div>

  <!-- 列表渲染 
     * 便利 arr 编译后是使用 arr.map() ，不需要 index 也可以 i in list
     * 也可以遍历 Object ，(value, key, index) in obj
     * 也可以用数字 i in 10
     * key 默认为 index ，最好给 key 唯一的 id ，提高 diff 算法性能 
  -->
  <ul>
    <li v-for="(i, iIndex) in list" :key="i.id">
      {{ `index: ${iIndex}，value: ${i.value}` }}
    </li>
  </ul>

  <!-- v-if 、v-for 结合，不要直接写在一起 --------------------------------------------------------------
     * 显示部分子项，就用 computed filter 新的 arr
     * 显示隐藏整个 list ，就 v-if 父节点或者虚拟节点 template
  -->

  <!-- err
  <ul>
    <li v-if="i.value > 15" v-for="i in list" :key="i.id">
      {{ i.value }}
    </li>
  </ul> 
  -->

  <!-- computed filter -->
  <ul>
    <li v-for="i in filterList" :key="i.id">{{ i.value }}</li>
  </ul>

  <!-- v-if 父节点 -->
  <ul v-if="false">
    <li v-for="i in list" :key="i.id">{{ i.value }}</li>
  </ul>

  <!-- template 默认 false -->
  <template v-if="true">
    <div v-for="i in list" :key="i.id">{{ i.value }}</div>
  </template>
</template>

<style scoped lang="less">
ul {
  margin: 20px 0;
}
</style>
```

长列表渲染，会消耗大量性能，解决方法：

* 分页

* 分片加载更多

* 虚拟列表，也叫虚拟滚动，只渲染当前看得见的元素

* 若必须一次性全部渲染：
  
  * 可以用 v\-once 、v\-memo ，但场景不太常见
  
  * raf 延迟加载，通常用于组件分片

```
pnpm add vue-virtual-scroller@next
```

```
declare module "vue-virtual-scroller" {
  import { DefineComponent } from "vue";

  export const RecycleScroller: DefineComponent<any, any, any>;
  export const DynamicScroller: DefineComponent<any, any, any>;
  export const DynamicScrollerItem: DefineComponent<any, any, any>;
}
```

```
<script setup lang="ts">
import { ref, reactive, computed, onMounted } from "vue";

import { RecycleScroller } from "vue-virtual-scroller";
import "vue-virtual-scroller/dist/vue-virtual-scroller.css";

interface ListItem {
  id: number;
  value: number;
}

const list = reactive<ListItem[]>([]);
for (let i = 1; i <= 1000; i++) {
  list.push({
    id: i,
    value: i,
  });
}

// 分页 ---------------------------------------------------------------------------------
const page = ref(1);
const size = ref(5);

const pageList = computed(() => {
  const start = (page.value - 1) * size.value;
  const end = start + size.value;
  return list.slice(start, end);
});

const addPage = () => {
  if (page.value >= Math.ceil(list.length / size.value)) return;
  ++page.value;
};

const reducePage = () => {
  if (page.value <= 1) return;
  --page.value;
};

// 分片加载更多 --------------------------------------------------------------------------
const loadingRef = ref<HTMLDivElement | null>(null);
const scrollerRef = ref<HTMLDivElement | null>(null);

const loadingFlag = ref(true);
const loadingSize = ref(10);
const endIndex = ref(10);

const isEnd = computed(() => currentList.value.length >= list.length);

const currentList = computed(() => {
  return list.slice(0, endIndex.value);
});

onMounted(() => {
  const ob = new IntersectionObserver(
    (entries) => {
      if (!entries[0].isIntersecting || !loadingFlag.value || isEnd.value) {
        console.log(123);
        return;
      }

      loadingFlag.value = false;
      setTimeout(() => {
        endIndex.value += loadingSize.value;
        loadingFlag.value = true;
      }, 1000);
    },

    {
      root: scrollerRef.value,
    }
  );

  ob.observe(loadingRef.value!);
});
</script>

<template>
  <!-- 分页 -->
  <div class="container page">
    <div>
      <div v-for="i in pageList" :key="i.id">{{ i.value }}</div>
    </div>
    <div>
      <button @click="reducePage">-</button>
      <span>{{ " " + page + " " }}</span>
      <button @click="addPage">+</button>
    </div>
  </div>

  <!-- 分片加载更多 -->
  <div class="container load-scroller">
    <div v-for="i in currentList" :key="i.id">{{ i.value }}</div>
    <div ref="loadingRef" v-show="!isEnd">loading...</div>
  </div>

  <!-- 虚拟滚动 -->
  <RecycleScroller
    class="container"
    :items="list"
    :item-size="20"
    key-field="id"
  >
    <template #default="{ item }">
      <div class="item">{{ item.value }}</div>
    </template>
  </RecycleScroller>
</template>

<style scoped lang="less">
.container {
  margin: 20px;
  width: 100px;
  height: 200px;
  border: 1px solid #000;
}

.page {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.load-scroller {
  overflow: scroll;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.item {
  text-align: center;
}
</style>
```

### 2.5 生命周期

生命周期函数、也叫生命周期钩子，在 Vue 特定时刻回调。

Vue2 、Vue3 区别：

* Vue3 都是 Composition API ，且有 on 前缀；若混用，则 Composition API 比 Options API 先执行，如 setup 比 created 先执行

* setup 相当于 beforeCreate 、created ，没有这两个的 Composition API ；this 为 undefined ；

* Vue3 中无 el 就不会执行任何生命周期，而 Vue2 会直行道 created 阶段，若无 el 就不会继续生命周期
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <body>
      <div id="app"></div>
  
      <!-- vue2 -->
      <!-- <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
      <script>
        new Vue({
          // el: "#app",
          created() {
            console.log(123);
          },
        });
      </script> -->
  
      <!-- vue3 -->
      <script src="https://unpkg.com/vue@3.5.4/dist/vue.global.js"></script>
      <script>
        const { createApp, ref } = Vue;
        createApp({
          created() {
            console.log(123);
          },
        });
        // .mount("#app");
      </script>
    </body>
  </html>
  ```

* Vue3 可以注册多个相同的生命周期钩子，按照代码顺序执行，注意必须在 setup 阶段同步执行；Vue2 直接配置注册，但只能配置一个

* 销毁阶段 destroyed 改为 unMounted

* Vue3 新增 3 个钩子 ，onRenderTracked ，onRenderTriggered ，onServerPrefetch,

代码：

```
<script>
// Vue2

export default {
  data() {
    return {
      a: 1,
    };
  },

  beforeCreate() {},
  created() {
    console.log("created");
  },

  beforeMount() {},
  mounted() {
    console.log("mounted");
  },

  beforeUpdate() {},
  updated() {
    this.$nextTick(() => console.log("nextTick", this.a));
  },

  beforeDestroy() {},
  destroyed() {},

  activated() {},
  deactivated() {},
};
</script>

<template>
  <div>
    <button @click="++a">add a</button>
    <span>{{ " " + a }}</span>
  </div>
</template>
```

```
<script setup lang="ts">
// Vue3

import {
  ref,
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  nextTick,
  onBeforeUnmount,
  onUnmounted,
  onActivated,
  onDeactivated,
  onErrorCaptured,
  onRenderTracked,
  onRenderTriggered,
  onServerPrefetch,
} from "vue";

// 组件生命周期 ----------------------------------------------------------------------------------

/**初始化阶段
 * 等价于 Vue2 的 create 阶段
   - beforeCreate ：准备数据，初始化
   - created ：数据准备完毕，可以使用 data 、computed 等，可以 ajax
 * 此时组件未挂载，所以整个 setup 的 this 都是 undefined
 * 此时数据已经准备完毕
 */
console.log(this);

const a = ref(1);
const spanRef = ref<HTMLSpanElement | null>(null);

/**挂载阶段
 * beforeMount ：template 编译为 render 函数，生成 VDOM
 * mounted ：真实 DOM 已经生成，可以获取 DOM，并准备异步渲染
 */
onBeforeMount(() => console.log("beforeMount"));

//1 2 3 , Vue3 可以注册多个相同生命周期钩子
onMounted(async () => {
  console.log("mounted", 1);

  // 生命周期使用 async await 语法没问题，但可能会有歧义，因为异步执行已经不是这个生命周期的时机了
  await Promise.resolve();
  console.log("mounted", 3);
});
onMounted(() => console.log("mounted", 2));

// err ，禁止这么做，必须在 setup 时机中同步注册，因为异步执行注册时 mounted 已经过去了
// setTimeout(() => onMounted(() => console.log("mounted", 4)));

/**DOM 更新阶段
 * 钩子：
   - beforeUpdate ：生成新 VDOM ，diff 比较
   - updated ：真实 DOM 更新完毕，但需要异步渲染
 * 异步更新：
   - 通过异步派发更新，多次数据更新只会执行一次依赖更新，更新时：beforeUpdate - render - updated
   - 若在 updated 外想要得到更新完的真实 DOM ，则使用 nextTick ，在异步更新后下一个微任务中获取
   - beforeUpdate 在所有非 render 内的 computed 依赖执行完后，且只有 render 用到的数据修改后才会执行；这是因为只有执行 render 才会有生命周期
     因此只有模板中用到了响应式数据，render 函数才会被依赖收集，修改响应式数据才会重新 render ，才会执行更新阶段的钩子；
 * 禁止在更新钩子内部修改响应式数据，防止无线执行更新
 */
onBeforeUpdate(() => {
  // 2 1 ，此时真实 DOM 还未更新
  console.log("beforeUpdate", a.value, spanRef.value?.textContent);

  // 2 2 ，真实 DOM 更新完毕
  nextTick(() => console.log("nextTick", a.value, spanRef.value?.textContent));

  // 也可以
  // await nextTick();
});

onUpdated(() => {
  // 2 2 ，真实 DOM 更新完毕
  console.log("updated", a.value, spanRef.value?.textContent);

  // 禁止这么做
  // ++a.value;
});

/**卸载阶段（销毁）
 * beforeUnMount ：卸载之前，DOM 还在，用于清除需要调用 DOM 的副作用，如事件监听等
 * unMounted ：卸载完毕，DOM 清除了，此时只能清除不需要调用 DOM 的副作用，如定时器 、window 事件等
 */
onBeforeUnmount(() => console.log("beforeUnMount"));
onUnmounted(() => console.log("unMounted"));

// 路由组件钩子 ---------------------------------------------------------------------------

// 路由激活
onActivated(() => console.log("activated"));

// 路由失活
onDeactivated(() => console.log("deactivated"));

// err 捕获钩子 -----------------------------------------------------------------------------
onErrorCaptured((err, instance, info) => {
  console.log("errorCaptured 捕获错误", err, info);

  // 是否进一步向上冒泡传播，默认 undefined 等同于 true
  return false;
});

/**响应式 -------------------------------------------------------------------------------------
 * e.effect ：收集的依赖
 * e.target ：响应式数据
 * e.key ：reactive 的 key ，如果是 ref 则是 "value"
 * e.type ：操作类型，如 get
 * 在 beforeMount 后，mounted 之前执行；在 beforeUpdate 后，updated 之前执行
 */
// track 时回调
onRenderTracked((e) => console.log("track"));

// trigger 时回调
onRenderTracked((e) => console.log("trigger"));

// SSR ------------------------------------------------------------------------------------------
// SSR 渲染前执行异步数据加载，仅在服务端执行，客户端不执行
onServerPrefetch(async () => {});
</script>

<template>
  <button @click="++a">add a</button>
  <span ref="spanRef">{{ " " + a }}</span>
</template>
```

父子组件生命周期的顺序，多个子组件就按顺序依次走完各个子组件的生命周期：

```
初始化、挂载
父：bc -> c -> bm                    | -> m 
子：            |-> bc -> c -> bm -> m

更新
父：bu ->         | -> u
子：   | -> bu -> u 

销毁
父：bd ->         | -> d
子：   | -> bd -> d 
```

## 3 组件

基本：

* 组件命名：大驼峰，如 AaaBbb ，aaa-bbb ，可以单标签、双标签

* 局部注册，仅当前组件可用：
  
  ```
  export default {
    // key 为组件标签名，不是组件 name
    components: { Cpn: Cpn },
  };
  ```

* 全局注册，全部组件均可用，若全局注册分包的组件，由于必须在 main.ts 中注册，打包后的主包就也会存一份分包代码，这样分包的意义就不大了，所以全局注册适合不分包的小组件：
  
  ```
  // /src/main.ts ，第一个参数为组件标签名，不是组件 name
  
  // Vue2
  Vue.component("Cpn", Cpn);
  // Vue3
  createApp(App).component("Cpn", Cpn).mount("#app");
  ```

* 也可以定义临时组件，但模板写法中必须使用 h 函数：
  
  ```
  <script setup lang="ts">
  import { defineComponent, h } from "vue";
  
  const Cpn = defineComponent({
  setup() {
    return () => h("h1", null, 123);
  },
  });
  </script>
  
  <template>
  <Cpn />
  </template>
  ```

* v-if 都会走一遍组件生命周期；而 v-show 不会，因为不删除组件；应该避免大量 v-if 组件的场景、组件渲染性能消耗比原生 DOM 大得多

### 3.1 组件通信

#### 3.1.1 props 、emit 、透传、获取 DOM 和组件实例

实现父子组件通信，props 、emits 除了基础用法外，也可以用 v\-bind 、v\-on 传入一个对象，多传的 props 会覆盖，多传的 emits 会入队，多次执行。

Vue2 、Vue3 区别：

* props ：
  
  * Vue2 也会把 props 代理到 this 中，因此 data 等就无法声明同名资源
  
  * Vue3 把 props 抽离出来，单独使用
- 自定义组件默认无法绑定原生事件，编译时都认为是自定义事件：
  
  - Vue2 可以使用 .native 绑定原生事件，绑定的是子组件根元素
  
  - Vue3 删除了 .native ，只能在子组件内部触发原生事件再 emit 自定义事件

- Vue3 新增 emits 选项 ：
  
  - Vue2 可以 emit 任何自定义事件
  
  - Vue3 若未配置 emits 选项也是可以 emit 任何自定义事件，但若配置了 emits 则只能 emit 已声明的自定义事件

- Vue3 新增 expose 函数：
  
  * Vue2 子组件所有的资源父组件都可以使用
  
  * Vue3 默认和 Vue2 一样，但若执行了 expose 函数就只能使用暴露的资源

- 透传：
  
  * 作用：
    
    * 将非 props 需要的属性收集起来，用于继续向下传递
    
    * 透传的资源会放在子组件根元素，因此：
      
      * 像非 props 的属性，以及像 id 、style 、class 等这些 DOM 属性、以及 style scoped 的自定义属性等都会透传，因此即使是 Vue3 ，子组件也必须有一个根元素接收：
        
        ```
        <script setup lang="ts">
        // 子组件
        </script>
        
        <template>
          <div>
            <p>123</p>
            <p>{{ $attrs }}</p>
          </div>
        </template>
        ```
        
        ```
        <script setup lang="ts">
        // 父组件
        import Cpn from "./Cpn.vue";
        </script>
        
        <template>
          <!-- 调试工具可以看到 h1 和 Cpn 跟元素的 scoped 自定义属性一样 -->
          <h1 class="app">App</h1>
          <Cpn class="cpn"/>
        </template>
        
        <style scoped lang="less">
        .app {
          border: 1px solid #000;
        }
        
        // 因此 .cpn 自身不用样式穿透
        .cpn {
          :deep(p) {
            border: 1px solid #000;
          }
        }
        </style>
        ```
      
      * 但是不需要透传的属性如 key 、ref 、is 、slot 等就不需要根元素，Fragment 即可
* Vue2：
  
  * this\.\$attrs 保存了所有父组件传入但未在 props 声明的资源
  
  * this\.\$listeners ：保存了所有父组件监听的自定义事件，不保存 \.native 原生事件
  
  * this\.\$slots ：保存了所有插槽

* Vue3：
  
  * attrs 、slots 存放于 setup 第二个参数 context ；script setup 则需要 useAttrs 、useSlots 获取
  
  * Vue3 删除 listener ，整合到了 attrs ：且 Vue3 新增了 emits 选项，使得 attrs 只会保存父组件已传入但未在 emits 声明的自定义事件
  
  * 获取 DOM 、组件实例：

* Vue2 直接用 this\.\$refs\.xxx 获取实例；还可以用 this\.\$children 、this\.\$parent 、this\.\$root

* Vue3 需要 ref 定义；删除了 \$children ，另外两个还可以用 getCurrentInstance 获取

（1）Vue2

```
<script>
// 子组件

export default {
  // props 三种写法

  // props: ["num", "arr"],

  // props: {
  //   num: Number,
  //   fn: Array,
  // },

  props: {
    num: {
      type: Number,
      required: true,
      default: 0,
    },

    arr: {
      type: Array,
      required: false,
      default: () => [],
    },

    fn: {
      type: Function,
      required: false,
      default: () => "props fn",
    },
  },

  methods: {
    clickBtn() {
      this.$emit("myevent", 123);
    },
  },

  created() {
    console.log(this.num, this.arr, this.fn());

    console.log(this.$attrs);
    console.log(this.$listeners);
    console.log(this.$slots);
  },
};
</script>

<template>
  <div>
    <div>{{ num }}</div>
    <div>{{ arr }}</div>
    <div>{{ fn() }}</div>

    <div>{{ typeof $emit }}</div>
    <button @click="clickBtn">emit</button>
  </div>
</template>
```

```
<script>
// 父组件

import Cpn from "./Cpn.vue";

export default {
  components: { Cpn },

  data() {
    return { p: { num: 0, xxx: "xxx" } };
  },

  methods: {
    mouseenterFn() {
      console.log("原生事件");
    },

    myevent(e) {
      console.log(e);
    },
  },

  mounted() {
    // 所有子组件、一个或没有父组件、一个根组件 App
    console.log(this.$children, this.$parent, this.$root);

    // 指定子组件或 DOM 元素
    console.log(this.$refs["cpnRef"]);
  },
};
</script>

<template>
  <div>
    <Cpn
      ref="cpnRef"
      :num="0"
      @mouseenter.native="mouseenterFn"
      @myevent="myevent"
      :xxx="'xxx'"
      @yyy="() => 'yyy'"
    />

    <!-- props 解构简写 -->
    <!-- 
    <Cpn
      v-bind="p"
      ref="cpnRef"
      @mouseenter.native="mouseenterFn"
      @myevent="myevent"
      @yyy="() => 'yyy'"
    /> 
    -->
  </div>
</template>
```

（2）Vue3 script setupt

```
<script setup lang="ts">
/**子组件 -----------------------------------------------------------------------------------
 * defineProps, withDefaults, defineEmits, defineExpose 都是宏定义，不需要导入
 * 每种宏只能存在一个，其中 defineProps, withDefaults 只能有一种
 */

import { ref, useAttrs, useSlots } from "vue";
import type { Ref } from "vue";

const cpnData = ref(456);

// props ，属性只读的响应式数据，父传子，也可以通过传递 fn 实现子传 父 ----------------------------------------------
// props 的类型必须是一个 object
interface Props {
  num: number;
  fn: (cpnData: number) => void;
  msg?: string;
  arr?: number[];
}

// const props = defineProps<Props>();

const props = withDefaults(defineProps<Props>(), {
  // 默认值，必选参数就不必设置默认值了，ts 会检查
  msg: "msg",

  // 除了 function外，其他引用类型需要写成函数形式，防止多个父组件使用该组件时共享引用
  arr: () => [],
});

console.log(props.num, props.fn);
console.log(props.msg, props.arr);

// 自定义事件，子传父 -------------------------------------------------------------------------
export type EventPayload = { text: string; data: number };

interface Emits {
  (type: "myevent", payload?: EventPayload): void;
  (type: "mouseenter", payload?: EventPayload): void;
}

const emit = defineEmits<Emits>();

// 也可以这么写，但是 payload 类型为 any
// const emit = defineEmits(["myevent", "mouseenter"]);

/**defineExpose ---------------------------------------------------------------------------
 * 父组件 cpnRef.value 是 Proxy 响应式数据，保存了 expose 的资源和 $el 等，类似反过来的 props
 * 规范中应该通过组件通信修改数据，不太推荐 exposed 暴漏方法修改
 * 注意：
   - Vue3.2 secript setup 只有 expose 暴漏的资源，父组件才能使用，防止父组件修改数据；
     原理是 script setup 编译为 setup() {} 后，执行了 expose 函数
   - Vue3.0 setup() {} 的写法，默认不会执行 expose 函数，这种情况下全部 setup() 中 return 的资源父组件都可以使用；
     当然这种写法也可以手动执行 expose 函数
 */
interface Expose {
  btnRef: Ref<HTMLButtonElement | null>;
  a: Ref<number>;
}

const btnRef = ref<HTMLButtonElement | null>(null);
const a = ref(0);

defineExpose<Expose>({ btnRef, a });
// 等价于
// import { getCurrentInstance } from "vue";
// const vm = getCurrentInstance();
// vm!.exposed = { btnRef, a };
// defineExpose({} as Expose);

// 测试响应式
setInterval(() => {
  console.log(a.value);
}, 2000);

// 透传，都是 Proxy 响应式数据 ----------------------------------------------------------------------
const attrs = useAttrs();
const slots = useSlots();

console.log(attrs, slots);

// 测试 ------------------------------------------------------------------------------------------
// 原生事件
const keydownFn = () => {
  // props.fn(cpnData.value);
  // emit("mouseenter", { text: "mouseenter", data: cpnData.value });
};

// 自定义事件
const myEventFn = () => {
  // props fn 或 emit 自定义事件 ，emit 第二个参数为自定义事件对象
  // props.fn(cpnData.value);
  emit("myevent", { text: "myevent", data: cpnData.value });
};
</script>

<!-- 
<script lang="ts">
export default {
  mounted() {
    // 依然可用
    console.log(this.$attrs, this.$slots);

    // undefined ，已删除
    console.log(this.$listeners);
  },
};
</script> 
-->

<template>
  <div @mouseenter="keydownFn">
    <button ref="btnRef" @click="myEventFn">btn</button>

    <!-- 若 props 和当前组件定义的变量冲突，优先使用当前组件定义的变量 -->
    <p>{{ num }}</p>
    <p>{{ props.num }}</p>
    <p>{{ $props.num }}</p>

    <p>{{ typeof emit }}</p>
    <p>{{ typeof $emit }}</p>

    <p>{{ $attrs }}</p>
    <p>{{ $slots }}</p>
  </div>
</template>
```

```
<script setup lang="ts">
// 父组件 ，子组件不需要注册，编译后会自动配置注册

import {
  ref,
  reactive,
  useTemplateRef,
  onMounted,
  getCurrentInstance,
} from "vue";
import Cpn from "@/Cpn.vue";
import type { EventPayload } from "@/Cpn.vue";

const num = ref(123);
const fn = (cpnData: number) => console.log(cpnData);
const p = reactive({
  num,
  fn,
  msg: "hello",
  xxx: "xxx",
});

const callback = (e?: EventPayload) => console.log(e);

/**获取子组件实例 ---------------------------------------------------
 * 若是 setup() 写法，则需要 return cpnRef
 * DPM 和组件实例都只有在 mpunted 后才能拿到
 * ref 也可以传入一个函数
 * Vue3.5 新增 useTemplateRef ，优点是把变量和 ref 绑定的字符串分离，且组建实例的类型会自动推导
 */
const cpnRef = ref<InstanceType<typeof Cpn> | null>(null);

// ref 也可以 v-bind 一个函数，在子组件 mounted 后，不用等父组件 mounted 就执行
// const getRef = (exposed: InstanceType<typeof Cpn>) => console.log(exposed.$el);
// onMounted(() => console.log("父组件 mounted"));

// cpn 等价于上面的 cpnRef
// const cpn = useTemplateRef("cpnRef");

onMounted(() => {
  const { $el, btnRef, a } = cpnRef.value!;

  /**$el 不需要 expose
   * 若子组件有且只有一个根元素，则 $el 就是该根元素
   * 若没有根元素：
     - 则使用虚拟节点 <Fragment> 包裹，生成一个空文本节点 #text 来保证 DOM 树结构
     - 这种情况只能在子组件中 ref 需要的 DOM 元素再 expose 给父组件使用
  * 若子组件为空 template ，则得到一个空注释节点
  */
  console.log($el, btnRef);

  console.log(a);

  // 测试响应式
  cpnRef.value!.a++;

  // getCurrentInstance 不能获取子元素、子组件
  const instance = getCurrentInstance();
  const parent = instance?.proxy?.$parent;
  const root = instance?.proxy?.$root;
  console.log(parent, root);
});
</script>

<!-- 
<script lang="ts">
export default {
  mounted() {
    // 依然可用
    console.log(this.$parent, this.$root);

    // undefined ，已删除
    console.log(this.$children);
  },
};
</script> 
-->

<template>
  <!-- 或者 :ref="getRef" -->
  <Cpn
    ref="cpnRef"
    :num="num"
    :fn="fn"
    msg="hello"
    @mouseenter="callback"
    @myevent="callback"
    :xxx="'xxx'"
    @yyy="console.log('yyy')"
  />

  <!-- props 解构简写 v-bind -->
  <!-- 
  <Cpn
    v-bind="p"
    ref="cpnRef"
    @mouseenter="callback"
    @myevent="callback"
    @yyy="console.log('yyy')"
  /> 
  -->
</template>
```

（3）script setup 编译为 setup\(\)

```
# 这个 vite 插件可以查看编译结果
pnpm add -D vite-plugin-inspect
```

```
// /src/vite.config.ts ，npm run dev 会打印 Inspect 地址，浏览器打开查看即可

import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import inspect from "vite-plugin-inspect";

export default defineConfig({
  plugins: [vue(), inspect()],
});
```

```
<!-- 
<script setup lang="ts">
// 子组件

import { ref, useAttrs, useSlots } from "vue";

interface Props {
  num?: number;
}

interface Emits {
  (type: "myevent", payload?: any): void;
}

const props = withDefaults(defineProps<Props>(), { num: 0 });
console.log(props.num);
const num = ref(-1);

const emit = defineEmits<Emits>();
emit("myevent");

const attrs = useAttrs();
const slots = useSlots();
console.log(attrs, slots);

const a = ref(0);
defineExpose({ a });
</script> 
-->

<script lang="ts">
// 编译后的大概结构

import { defineComponent, ref } from "vue";

export default defineComponent({
  // 写法和 Vue2 一样
  props: {
    num: {
      type: Number,
      required: false,
      default: 0,
    },
  },

  // Vue3 新增，若不配置，则 Vue 不会校验 emit ，即和 Vue2 一样可以 emit 任何自定义事件；若配置了，则只能 emit 这里声明的自定义事件
  // script setup 由于必须 defineEmits 才能拿到 emit ，所以编译后必然会有这个选项
  emits: ["myevent"],

  setup(props, context) {
    const { emit, attrs, slots, expose } = context;

    console.log(props.num);
    const num = ref(-1);

    emit("myevent");

    console.log(attrs, slots);

    // 不执行 expose 则所有 return 的资源父组件都可以使用
    const a = ref(123);
    expose({ a });

    return { num, props, emit, a };
  },
});
</script>

<template>
  <!-- 注意，当父组件传入了多余的 props 和自定义事件时，子组件必须有且只有一个根元素来接收这些到 attrs 中 -->
  <!-- 
  <div>
    <p>1</p>
    <p>2</p>
  </div> 
  -->

  <!-- 若想要保持多跟绝点，则需要手动把 $attr 注入到某个元素中 -->
  <div>1</div>
  <div v-bind="$attrs">2</div>

  <!-- props 的属性不需要 return 也能使用，若和 return 的自定义数据冲突，优先使用 return 的 -->
  <div>{{ num }}</div>
</template>
```

```
<!-- 
<script setup lang="ts">
// 父组件

import { ref } from "vue";
import Cpn from "./Cpn.vue";

const cpnRef = ref<InstanceType<typeof Cpn> | null>(null);
</script> 
-->

<script lang="ts">
// 父组件，编译后的大概结构

import { defineComponent, ref } from "vue";
import Cpn from "./Cpn.vue";

export default defineComponent({
  components: { Cpn },

  setup() {
    const cpnRef = ref<InstanceType<typeof Cpn> | null>(null);
    return { cpnRef, Cpn };
  },
});
</script>

<template>
  <Cpn
    ref="cpnRef"
    @myevent="console.log('msg')"
    xxx="xxx"
    @yyy="console.log('yyy')"
  />

  <!-- 不当成组件使用时，需要 return -->
  {{ typeof Cpn }}
</template>
```

#### 3.1.2 组件 v\-model

父组件传入 props、emit 的语法糖。

Vue2 、Vue3 区别：

* Vue2 默认 props 为 value ，默认 event 为 input ；Vue3 默认 props 为 modelValue  ，默认 event 为 update\:modelValue

* Vue2 通过 model 配置项修改默认 props 和 emit ，只能有一个 v\-model 但可以通过 \.sync 修饰符使用多个数据（事件为 update\:xxx ）；Vue3 可以使用多个 v\-model 且任意命名，因此删除了 model 和 \.sync 修饰符；

* Vue3 新增组件 v|-model 自定义修饰符

* Vue3.4 新增宏 defineModel

Vue2 ：

```
<script>
// 子组件

export default {
  // 修改默认绑定
  // model: {
  //   prop: "val",
  //   event: "inp",
  // },
  // props: ["val", "num"],

  props: ["value", "num"],
};
</script>

<template>
  <div>
    <!-- 测试 model -->
    <!-- <button @click="$emit('inp', val + 1)">add {{ val }}</button> -->

    <button @click="$emit('input', value + 1)">add {{ value }}</button>
    <button @click="$emit('update:num', num + 1)">add {{ num }}</button>
  </div>
</template>
```

```
<script>
// 父组件

import Cpn from "./Cpn.vue";

export default {
  components: { Cpn },

  data() {
    return {
      cnt1: 0,
      cnt2: 0,
    };
  },
};
</script>

<template>
  <div>
    <Cpn v-model="cnt1" :num.sync="cnt2" />
  </div>
</template>
```

Vue3 ：

```
<script setup lang="ts">
// 方式一，显示声明 props /emits --------------------------------------------------------------
// const props = defineProps<{
//   modelValue: number;
//   num: number;

//   // 自定义修饰符
//   modelModifiers?: { xxx: boolean };
//   numModifiers?: { xxx: boolean };
// }>();

// const emit = defineEmits(["update:modelValue", "update:num"]);

// { xxx: true } ，若没有传入修饰符则整个为 undefined
// console.log(props.modelModifiers);
// console.log(props.numModifiers);

/**方式二，Vue3.4 的 defineModel ------------------------------------------------------------
 * defineModel 是一个宏，会编译为一个 customRef ，在 set 时自动 emit
 * 但这个 customRef 只会处理浅层，若是一个对象，内部属性的修改则不会 emit ，会打破单项数据流
 */
const modelValue = defineModel<number>({ required: true });
const num = defineModel<number>("num", {
  required: true,

  // 如果是可选，也可以设置默认值
  // default: 0,

  // 自定义 set ，必须 return ，然后会自动 emit 这个返回值
  set: (newValue) => {
    console.log(newValue);
    return newValue;
  },
});

console.log(modelValue.value, num.value);

// 自定义修饰符，需要解构（因为宏是编译时，所以才会出现不同的返回值）
// const [modelValue, modifiers] = defineModel();
// console.log(modifiers.xxx);
</script>

<template>
  <!--  props、emits
  <button @click="emit('update:modelValue', props.modelValue + 1)">
    add {{ props.modelValue }}
  </button>
  <button @click="emit('update:num', props.num + 1)">
    add {{ props.num }}
  </button> 
  -->

  <!-- defineModel -->
  <button @click="++modelValue">add {{ modelValue }}</button>
  <button @click="++num">add {{ num }}</button>
</template>
```

```
<script setup lang="ts">
// 父组件

import { ref } from "vue";
import Cpn from "./Cpn.vue";

const cnt1 = ref(0);
const cnt2 = ref(0);
</script>

<template>
  <!-- 等价于
  <Cpn
    :modelValue="cnt1"
    :modelModifiers="{ xxx: true }"
    :num="cnt2"
    :numModifiers="{ xxx: true }"
    @update:modelValue="cnt1 = $event"
    @update:num="cnt2 = $event"
  /> 
  -->

  <Cpn v-model.xxx="cnt1" v-model:num.xxx="cnt2" />
</template>
```

#### 3.1.3 非父子组件通信

（1）依赖注入

祖先 provide 数据，后代组件 inject 响应式注入数据。

Vue2 、Vue3 用法一样，区别：

* Vue2 必须 provide 引用类型才会有响应式，而 Vue3 都可以

Vue2 ：

```
<script>
// 子组件

export default {
  inject: ["msg", "updateMsg"],
};
</script>

<template>
  <div>
    <input
      type="text"
      :value="msg.value"
      @change="updateMsg($event.target.value)"
    />

    <p>{{ msg.value }}</p>
  </div>
</template>
```

```
<script>
// 父组件

import Cpn from "./Cpn.vue";

export default {
  components: { Cpn },

  data() {
    return {
      msg: { value: "msg" },
    };
  },

  methods: {
    updateMsg(newMsg) {
      this.msg.value = newMsg;
    },
  },

  provide() {
    return {
      msg: this.msg,
      updateMsg: this.updateMsg,
    };
  },
};
</script>

<template>
  <Cpn />
</template>
```

Vue3 ：

```
<script setup lang="ts">
// 子组件

import { inject } from "vue";

// 第二个参数为默认值
const msg = inject("msg", "");
const updateMsg = inject("updateMsg", (newMsg: string) => {});
</script>

<template>
  <input
    type="text"
    :value="msg"
    @change="updateMsg(($event.target! as HTMLInputElement).value)"
  />

  <span>{{ " " + msg }}</span>
</template>
```

```
<script setup lang="ts">
// 父组件

import { ref, provide } from "vue";
import Cpn from "./Cpn.vue";

const msg = ref("msg");
const updateMsg = (newMsg: string) => (msg.value = newMsg);

provide("msg", msg);
provide("updateMsg", updateMsg);
</script>

<template>
  <Cpn />
</template>
```

（2）事件总线

任意组件通信，仅 Vue2 可用：

```
// /src/eventbus/index.js

// 通过 $on 、$off 实现，为了更好的维护，可以抽离出来，也可以实现多个事件总线
import Vue from "vue";
export default new Vue();
```

```
<script>
// 子组件

import EventBus from "./eventbus";

export default {
  data() {
    return {
      msg: "",
    };
  },

  methods: {
    getMsg(msg) {
      this.msg = msg;
    },

    updateMsg(e) {
      EventBus.$emit("updateMsg", e.target.value);
    },
  },

  created() {
    EventBus.$on("getMsg", this.getMsg);
  },

  beforeDestroy() {
    EventBus.$off("getMsg", this.getMsg);
  },
};
</script>

<template>
  <div>
    <input type="text" :value="msg" @change="updateMsg" />

    <p>{{ msg }}</p>
  </div>
</template>
```

```
<script>
// 父组件

import EventBus from "./eventbus";
import Cpn from "./Cpn.vue";

export default {
  components: { Cpn },

  data() {
    return {
      msg: "msg",
    };
  },

  methods: {
    emitMsg() {
      EventBus.$emit("getMsg", this.msg);
    },

    updateMsg(newMsg) {
      this.msg = newMsg;
      this.emitMsg();
    },
  },

  created() {
    EventBus.$on("updateMsg", this.updateMsg);
  },

  mounted() {
    this.emitMsg();
  },

  beforeDestroy() {
    EventBus.$off("updateMsg", this.updateMsg);
  },
};
</script>

<template>
  <Cpn />
</template>
```

Vue3 删除了 \$on 、\$off 、\$emit ，可以使用第三方库 mitt 代替。

#### 3.1.4 单项数据流

规范中，组件通信的数据只能从提供者流向被提供者，修改数据只能由提供者修改，因此 props 是只读的。

这是为了保证单项数据流，在调试工具可以看到数据提供者的修改记录，便于代码维护，也保证了各个组件数据的一致性：

```
<script setup lang="ts">
// 子组件
defineProps<{ cnt: number }>();
</script>

<template>
  <p>
    <!-- warn ，props 是只读的，若强行修改：
       * Vue2：生效但 warn ，由于 props 是 Object.defineProperty 实现的，会修改原始数据，
         又要保证 props 的响应式，所以数据是共享的，因此 setter 无法区分是父组件还是子组件的修改，
         所以 Vue2 无法实现阻止 props 修改（可以抛出 warn 是用其他机制）
       * Vue3：不生效且 warn ，因为 props 是一个 shallow readonly Proxy ，不修改原始数据，
         代理对象是子组件专用的，所以可以直接在 get 中阻止 props 修改
    -->
    <!-- <button @click="++cnt">add</button> -->

    <!-- 正确做法，由数据提供者修改，这里是父组件进行修改 -->
    <button @click="$emit('add')">add</button>

    <span>{{ " " + cnt }}</span>
  </p>
</template>
```

```
<script setup lang="ts">
// 父组件
import { ref } from "vue";
import Cpn from "./Cpn.vue";
const cnt = ref(0);
</script>

<template>
  <Cpn :cnt="cnt" @add="++cnt" />
</template>
```

props 是一个 shallow readonly Proxy ，若修改 props 中的引用类型数据，即深度修改，就检测不到，常见的场景如传入表单数据，子组件 v\-model 绑定。

解决方法：

* 子组件内部的表单不使用 v\-model ，拆分为 value 和事件，事件触发时 emit ，这种方式不太方便，但常用

* 子组件表单 v\-model 深拷贝 props 得到本地副本 local，再 watch 这个 local 并 emit ；再用另一个 watch 传入的 props ，props 变化再深拷贝一次得到新的 loacl ；这种方式性能比较差

* 用 computed 或 customRef 拦截 v\-model 的 set ，并 emit

这里以 computed 方案为例，注意：

* defineModel 和 vueuse 的 useVModel 都只是拦截数据本身的 set ，内部属性的 set 没有拦截，也就是说表单 v\-model 对象内部的属性还是会打破单向数据流

* 这里实现的是可用于引用类型数据的 useVModel ，但也只实现了引用类型第一层的 emit ，更深层就不太建议了，可能有性能问题

* 组件 v\-model 的数据是引用类型时，必须用 ref 定义，因为 reactive 无法整个重新赋值为一个新引用

```
// /src/hooks/useVModel.ts

import { computed } from "vue";

const ModelMap = new WeakMap();

// 用 computed 拦截 v-model 的 get 、set ，get 返回一个 Proxy实现属性的 set
export function useVModel<
  P extends Record<string, any>,
  K extends keyof P,
  E extends (event: `update:${K & string}`, value: P[K]) => void
>(props: P, propsName: K, emit: E) {
  const eventName = `update:${propsName as string}` as `update:${P[K]}`;

  return computed({
    get: () => {
      // 防止重复创建 Proxy
      if (ModelMap.has(props[propsName])) return ModelMap.get(props[propsName]);

      const res = new Proxy(props[propsName], {
        get: (target, key, receiver) => Reflect.get(target, key, receiver),

        set: (target, key, value) => {
          emit(eventName, {
            ...target,
            [key]: value,
          });

          return true;
        },
      });

      ModelMap.set(props[propsName], res);

      return res;
    },

    set: (value) => emit(eventName, value),
  });
}
```

```
<script setup lang="ts">
// 子组件

import { useVModel } from "./hooks/useVModel";

const props = defineProps<{ modelValue: { text: string } }>();
const emit = defineEmits(["update:modelValue"]);

const model = useVModel(props, "modelValue", emit);
</script>

<template>
  <form>
    <!-- 错误写法，虽然功能可以实现，但是违背了单项数据流，变成了由子组件修改数据；props 是只读的但此处没有 warn ，因为是深度修改检测不到 -->
    <!-- <input type="text" v-model="modelValue.text" /> -->

    <!-- 方法一，不推荐，比较繁琐 -->
    <!-- 
    <input
      type="text"
      :value="modelValue.text"
      @input="
        $emit('update:modelValue', {
          ...modelValue,
          text: ($event.target as HTMLInputElement).value,
        })
      "
    /> 
    -->

    <!-- 方式二，推荐，使用 useVModel -->
    <input type="text" v-model="model.text" />

    <p>{{ " " + modelValue.text }}</p>
  </form>
</template>
```

```
<script setup lang="ts">
// 父组件

import { ref } from "vue";
import Cpn from "./Cpn.vue";

const formData = ref({
  text: "asdf",
});
</script>

<template>
  <Cpn v-model="formData" />
</template>
```

### 3.2 组件扩展

#### 3.2.1 mixin 、hook

用于逻辑扩展

（1）mixin

混入，用于扩展 Options API  ，若产生冲突：

* 非声明周期：冲突不覆盖，直接忽略，再补上没有的

* 生命周期：全部执行，使用的资源同上

```
// /src/mixins/index.js

export const mixinA = {
  data() {
    return { a: 0 };
  },

  computed: {
    sum() {
      return this.a * 0;
    },
  },

  methods: {
    func: () => console.log("mixinA"),
  },

  mounted() {
    // 2
    console.log("mounted mixinA", this.a);
  },
};

export const mixinB = {
  mounted() {
    // 2
    console.log("mounted mixinB", this.a);
  },
};
```

```
<script>
import { mixinA, mixinB } from "./mixins";

export default {
  mixins: [mixinA, mixinB],

  // 也可以继承，等价于单个的 mixins
  extends: mixinA,

  data() {
    return { a: 2 };
  },

  computed: {
    sum() {
      return this.a * 2;
    },
  },

  methods: {
    func: () => console.log("func"),
  },

  mounted() {
    console.log("mounted", this.a);
  },
};
</script>

<template>
  <div>
    <!-- 2 4 func -->
    <p>{{ a }}</p>
    <p>{{ sum }}</p>
    <p>{{ func() }}</p>
  </div>
</template>
```

（2）hook

Vue3 新特性，即 Composition API ，完全可以替代 mixin ，本质是一个函数，有独立的作用于，所以不会产生冲突，hook 命名规范为 useXxx ：

```
// /src/hooks/useHidden.ts ，v-if 、v-show 通用 hook

import { ref } from "vue";
import type { Ref } from "vue";

type UseHiddenReture = [Ref<boolean>, () => void];

export function useHidden(value: boolean = false): UseHiddenReture {
  const isShow = ref(value);
  const switchShow = () => (isShow.value = !isShow.value);

  return [isShow, switchShow];
}
```

```
<script setup lang="ts">
import { useHidden } from "./hooks/useHidden";
const [isShow, switchShow] = useHidden(true);
</script>

<template>
  <button @click="switchShow">switch</button>
  <p v-show="isShow">text</p>
</template>
```

内置 hook ：

```
<script setup lang="ts">
// 除 markRaw 外，都是纯函数

import {
  ref,
  reactive,

  // 响应式处理
  shallowRef,
  shallowReactive,
  readonly,
  shallowReadonly,
  markRaw,
  toRaw,

  // 判断响应式数据
  isRef,
  isReactive,
  isReadonly,
  isProxy,
} from "vue";

/**shallow -----------------------------------------------------------------------------------
 * shallowRef : 若传入引用类型，不在用 reactive 处理
 * shallowReactive : 只处理第一层
 */
// 0 [1, 2]
const sr1 = shallowRef(0);
const sr2 = shallowRef([1, 2]);
console.log(sr1.value, sr2.value);

// ROXY([1, 2, [3]]) [3]
const srt = shallowReactive([1, 2, [3]]);
console.log(srt, srt[2]);

/**readonly 只读 ，常用于 hook 中导出不允许外部修改的响应式数据 -----------------------------------
 * 接收非函数的引用类型原始数据、或任何响应式数据，变成只读的 Proxy
 * 与普通数据的本质区别是，这是 Vue 能够检测到的，只是不允许修改
 * 若修改了原始响应式数据，readonly 也会被修改，因为是浅拷贝
 * shallowReadonly 只处理第一层
 */
const refData = ref(0);
const ro = readonly(refData);

// Proxy({value: 0}) 0
console.log(ro, ro.value);

// err
// ro.value = 1;

// 1 1
refData.value = 1;
const sro = shallowReadonly(refData);
console.log(ro.value, sro.value);

/**markRaw ------------------------------------------------------------------------------------
 * markRaw : 非纯函数，标记一个引用类型，使得无法用他创建响应式数据
   - 原始对象增加一个 "__v_skip": true 属性
   - 常用于响应式对象添加某个成员，而这个成员不需要响应式（如第三方数据），就可以 mark 以下，提高性能
 * toRaw : 还原一个响应式数据，无法还原 markRaw 的原始数据，因为必须传入一个响应式数据
 */
const rawData = { a: 0 };
const rd = markRaw(rawData);

// true
console.log(rd === rawData);

// { a: 0 , __v_skip: true }
const r1 = ref(rawData);
console.log(r1.value);

// Proxy({ a: 1 }) { a: 1 }
const r2 = ref({ a: 1 });
const r3 = toRaw(r2);
console.log(r2.value, r3.value);

/**判断响应式数据 --------------------------------------------------------------
 * 特别的，readoly 的 Proxy 只能用 isProxy 判断，不能用 isReactive
 */

const d1 = ref(0);
const d2 = reactive({ a: 1 });
const d3 = ref({ a: 1 });
const d4 = readonly(d3);

// 都是 "[object Object]" ，没有做处理
console.log(
  Object.prototype.toString.call(d1),
  Object.prototype.toString.call(d2)
);

// true true ture
console.log(isRef(d1), isReactive(d2), isReactive(d3.value));

// true true
console.log(isProxy(d2), isProxy(d3.value));

// true true false
console.log(isReadonly(d4), isProxy(d4), isReactive(d4));
</script>

<template></template>
```

#### 3.2.2 插槽

分为默认插槽、具名插槽、作用域插槽。

Vue2 、Vue3 区别：

* Vue2 父组件中，可以用 slot 属性指定具名插槽；Vue3 已删除

* Vue2 template 用 v\-slot\: 指定具名插槽，且默认插槽可以省略；Vue3 使用 \# 指定，且默认插槽不能省略

插槽的本质就是一个对象，key 为插槽名（如默认插槽的 key 为 default），value 为返回虚拟 DOM 的函数，函数形参即作用域插槽。

Vue2 ：

```
<script>
export default {
  created() {
    console.log(this.$slots);
  },
};
</script>

<template>
  <div>
    <slot></slot>
    <slot name="a"></slot>
    <slot name="b" :msg="'msg'"></slot>
  </div>
</template>
```

```
<script>
import Cpn from "./Cpn.vue";

export default {
  components: { Cpn },

  data() {
    return { slotName: "default" };
  },
};
</script>

<template>
  <div>
    <Cpn>
      <p>默认</p>
      <p slot="a">具名</p>
    </Cpn>

    <Cpn>
      <template v-slot:default>
        <p>默认插槽，被覆盖</p>
      </template>

      <template v-slot:[slotName]>
        <p>默认插槽</p>
      </template>

      <template v-slot:a>
        <p>具名插槽</p>
      </template>

      <template v-slot:b="{ msg }">
        <p>作用域插槽 {{ msg }}</p>
      </template>
    </Cpn>
  </div>
</template>
```

Vue3 ：

```
<script setup lang="ts">
// 子组件

import { useSlots } from "vue";

// 保存了传入的插槽
const slots = useSlots();
console.log(slots);
</script>

<template>
  <!-- 默认插槽，多个插槽都会插入 -->
  <slot></slot>
  <!-- <slot></slot> -->

  <!-- 具名插槽 -->
  <slot name="a"></slot>
  <!-- <slot name="a"></slot> -->

  <!-- 作用于插槽，用于传参，默认插槽也可用 -->
  <slot name="b" :msg="'msg'"></slot>
  <!-- <slot name="b" :msg="'msg'"></slot> -->
</template>

<style scoped lang="less"></style>
```

```
<script setup lang="ts">
// 父组件

import { ref } from "vue";
import Cpn from "./Cpn.vue";

const slotName = ref("default");
</script>

<template>
  <Cpn>
    <p>默认插槽</p>
  </Cpn>

  <Cpn>
    <template #default>
      <p>默认插槽，被覆盖</p>
    </template>

    <!-- 父组件中，只能有一个同名 template 插槽，但若使用响应式数据，同名就会覆盖 -->
    <template #[slotName]>
      <p>默认插槽</p>
    </template>

    <template #a>
      <p>具名插槽</p>
    </template>

    <template #b="{ msg }">
      <p>作用域插槽 {{ msg }}</p>
    </template>
  </Cpn>
</template>
```

### 3.3 特殊组件

（1）transition

过度组件，使用 FLIP 方案实现，可以设置类样式实现结构变化的动画。

Vue2 、Vue3 区别：

* Vue2 的 v\-enter 、v\-leave 在 Vue3 改为 v\-enter\-from 、v\-leave\-from

* Vue3 新增 appear 相关的 4 个生命周期，仅在 appear="true" 时有效，且在 appear 阶段会覆盖 enter 相关的钩子，后续不是 appear 就不会覆盖了

```
<script setup lang="ts">
import { ref } from "vue";
import type { Ref } from "vue";

function useHidden(value: boolean = false): [Ref<boolean>, () => any] {
  const isShow = ref(true);
  const switchShow = () => (isShow.value = !isShow.value);
  return [isShow, switchShow];
}

const [isShow, switchShow] = useHidden(true);
const [isShowItem, switchShowItem] = useHidden(true);
const [isShowText, switchShowText] = useHidden(true);

// transition 生命周期，都有参数 el 为触发动画的元素 -----------------------------------------
const beforeEnter = (el: Element) => console.log("beforeEnter", el);
const enter = (el: Element) => console.log("enter", el);
const afterEnter = (el: Element) => console.log("afterEnter", el);
const enterCancelled = (el: Element) => console.log("enterCancel", el);

const beforeLeave = (el: Element) => console.log("beforeLeave", el);
const leave = (el: Element) => console.log("leave", el);
const afterLeave = (el: Element) => console.log("afterLeave", el);
const leaveCancelled = (el: Element) => console.log("leaveCancel", el);

const beforeAppear = (el: Element) => console.log("beforeAppear", el);
const appear = (el: Element) => console.log("appear", el);
const afterAppear = (el: Element) => console.log("afterAppear", el);
const appearCancel = (el: Element) => console.log("appearCancel", el);
</script>

<template>
  <button @click="switchShow">switch</button>
  <button @click="switchShowItem">switch item</button>
  <button @click="switchShowText">switch text</button>

  <!-- 属性
     * name : 类名，默认为 "v"
     * appear : 初始是否使用动画，默认 false
     * css : 是否使用 css 控制动画，默认值 true ，若为 false 则自己使用 JS 配合 transition 生命周期控制动画
     * type : 不常用，值为 "transition" | "animation" ，Vue 会自动检查 css ，只有极少数情况需要手动指定
     * duration : 不常用，Vue 会自动检查 css ，只有极少数情况需要手动指定，来确定删除 DOM 的时机
  -->

  <!-- 有且只有一个根元素，且只有根元素有动画 -->
  <transition
    appear
    @before-enter="beforeEnter"
    @enter="enter"
    @after-enter="afterEnter"
    @enter-cancelled="enterCancelled"
    @before-leave="beforeLeave"
    @leave="leave"
    @after-leave="afterLeave"
    @leave-cancelled="leaveCancelled"
    @beforeAppear="beforeAppear"
    @appear="appear"
    @after-appear="afterAppear"
    @appear-cancel="appearCancel"
  >
    <div class="box bog" v-show="isShow">
      <div class="box small" v-show="isShowItem"></div>
      <div class="box small" v-show="isShowItem"></div>
    </div>
  </transition>

  <!-- 不需要根元素，通过 tag 指定根元素（默认 "span"），所有次一级 item 都有动画 -->
  <transition-group tag="ul">
    <!-- 需要 key 保证 diff 准确 -->
    <div class="box small" v-show="isShowItem" key="1"></div>
    <div class="box small" v-show="isShowItem" key="2">
      <!-- 再往下级就没有动画 -->
      <span v-show="isShowText">text</span>
    </div>
  </transition-group>
</template>

<style scoped lang="less">
@w: 100px;
@h: 100px;

.box {
  overflow: hidden;
  margin-top: 10px;
  border: 1px solid #000;
}

.bog {
  width: @w;
  height: @h;
  background-color: #000;
}

.small {
  width: calc(@w / 3);
  height: calc(@h / 3);
  background-color: red;
  line-height: calc(@h / 3);
  text-align: center;
}

// transition 类样式 --------------------------------------------------------------------------
.v-enter-from,
.v-leave-to {
  width: 0;
  height: 0;
}

.v-enter-to,
.v-leave-from {
}

.v-enter-active,
.v-leave-active {
  transition: 1s;
}
</style>
```

（2）component

动态组件，可以用变量动态渲染组件：

* 由于动态组件是运行时，所以无法渲染编译时组件如 template 

* 动态渲染组件时，需要传入组件对象

Vue2 、Vue3 用法一样；

```
<script setup lang="ts">
// 子组件
</script>

<template>
  <div>
    <slot></slot>
  </div>
</template>
```

```
<script setup lang="ts">
// 父组件

import { ref } from "vue";

// 注意子组件 Cpn 除了注册外，Vue2 要放在 data 注入，Vue3 setup\(\) 需要 return 才能在 template 使用.
import Cpn from "./Cpn.vue";

const flag = ref(true);
const changeFlag = () => (flag.value = !flag.value);
</script>

<template>
  <button @click="changeFlag">switch</button>
  <component :is="flag ? Cpn : 'h1'">text</component>

  <!-- is 也可以传入 h 函数，render 函数、VNode -->
  <!-- <Component :is="h(Cpn, {/* props */}, {/* slots */})" /> -->
</template>
```

（3）keep\-alive

缓存组件，v\-if 和路由切换不销毁组件，被 keep\-alive 作用的普通组件也可以使用 activated 、deactivated ，但其他路由相关钩子普通组件还是无法使用。

Vue2 、Vue3 用法一样：

```
<script setup lang="ts">
// 子组件

import { onUnmounted, onActivated, onDeactivated } from "vue";

onUnmounted(() => console.log("unmounted"));
onActivated(() => console.log("activated"));
onDeactivated(() => console.log("deactivated"));
</script>

<template>
  <p>Cpn</p>
</template>
```

```
<script setup lang="ts">
// 父组件

import { ref } from "vue";
import Cpn from "./Cpn.vue";

const isShow1 = ref(true);
const isShow2 = ref(true);

const switchShow1 = () => (isShow1.value = !isShow1.value);
const switchShow2 = () => (isShow2.value = !isShow2.value);
</script>

<template>
  <button @click="switchShow1">switch 1</button>
  <button @click="switchShow2">switch 2</button>

  <!-- 无缓存，会执行 unmounted -->
  <Cpn v-if="isShow1" />

  <!-- 缓存，不销毁组件，不执行销毁的钩子 -->
  <keep-alive>
    <Cpn v-if="isShow2" />
  </keep-alive>

  <!-- 结合 transition ，transition 要放在外部 -->
  <transition>
    <keep-alive>
      <Cpn v-if="isShow2" />
    </keep-alive>
  </transition>
</template>

<style scoped lang="less">
.v-enter-from,
.v-leave-to {
  opacity: 0;
}

.v-enter-active,
.v-leave-active {
  transition: opacity 2s;
}
</style>
```

（4）递归组件

组件自己使用自己。

Vue2 、Vue3 用法一样：

```
<script setup lang="ts">
// 子组件

/**方式一
 * 懒加载引入自己并注册，否则会无线递归
 * script setup 可以同步导入是因为会特殊处理，但不是懒加载，也不是设置 name
 */
// import Myself from "./Cpn.vue";

// 方式二，设置·组件 name
defineOptions({
  name: "Myself",
});

interface Data {
  id: string;
  text: string;
  children?: Data[];
}

interface Props {
  data: Data[];
}

defineProps<Props>();
</script>

<template>
  <ul>
    <li v-for="i in data" :key="i.id">
      <span>{{ i.text }}</span>
      <Myself v-if="i.children?.length" :data="i.children" />
    </li>
  </ul>
</template>
```

```
<script setup lang="ts">
// 父组件

import { reactive } from "vue";
import Cpn from "./Cpn.vue";

const data = reactive([
  { id: "0", text: "0", children: [{ id: "0-0", text: "0-0" }] },
  { id: "1", text: "1", children: [{ id: "1-0-0", text: "1-0" }] },
]);
</script>

<template>
  <Cpn :data="data" />
</template>
```

（5）异步组件

懒加载组件：

* 只有用到时才会下载执行分包的 JS，提高初始性能，常用于路由组件。

* 打包后懒加载的组件会分包，生成独立的 JS 文件，而其他正常导入的组件全部打包为一个 JS 文件

* 默认情况下，分包只和是否懒加载有关，和组件结构、嵌套路由等无关，如：
  
  * 懒加载父路由，同步导入子路由，那么这个子路由会打包到主包，而不是父路由组件的分包
  
  * 父路由、子路由都是懒加载，则会打包为两个独立的分包

Vue2 、Vue3 区别：

* Vue2 懒加载的组件可以直接使用；Vue3 懒加载得到一个 Promise ，需要 defineAsyncComponent 才能使用，这是为了支持更丰富的功能和 ts 支持

* 同步加载和懒加载，在子组件没有加载完成时，父组件以及祖先组件都不会渲染，因为子组件 mounted 后父组件才会 mounted；但若是 defineAsyncComponent 的完整写法，会让父组件先 mounted ，就不会停止上级组件的渲染

```
<script>
// Vue2 ，父组件

const Cpn1 = () => import("./Cpn1.vue");

export default {
  components: {
    Cpn1,
    Cpn2: () => import("./Cpn2.vue"),
  },
};
</script>

<template>
  <div>
    <Cpn1 />
    <Cpn2 />
  </div>
</template>
```

```
<script setup lang="ts">
// Vue3 ，父组件

import { defineAsyncComponent } from "vue";
import Loading from "./components/Loading.vue";
import Error from "./components/Error.vue";

// 简写
// const Cpn = defineAsyncComponent(() => import("./Cpn.vue"));

// 完整写法，过度组件、动态组件、缓存组件等对 loading 和 Error 都有小
const Cpn = defineAsyncComponent({
  // 正常使用
  // loader: () => import("./Cpn.vue"),

  // 测试，模拟 3s 后加载完成
  loader: () =>
    new Promise<any>((resolve, reject) => {
      setTimeout(() => {
        resolve(import("./Cpn.vue"));
        // reject("err");
      }, 3000);
    }),

  // 1000ms 后若还未加载完成，就显示 loading 组件
  delay: 1000,
  loadingComponent: Loading,

  // 2000ms 后若还未加载完成，显示 error 组件 ，但不会停止加载
  timeout: 2000,
  errorComponent: Error,

  // 非超时错误触发，如网络断开、reject 等
  onError(error, retry, fail, attempts) {
    // 设置重试次数，retry() 会重新执行 loader 函数
    if (attempts <= 3) retry();
    else fail();
  },

  /**是否结合 Suspense 使用，默认 true
   * true，Suspense 的 loading 插槽覆盖这里的 loading ；false 则使用这里的 loading
   * Suspense 只有 loading 插槽，没有 error 插槽
   * 若不结合 Suspense ，则不管 true 、false 都是使用这里的 loading
   */
  // suspensible: false,
});
</script>

<template>
  <p>Parent</p>
  <Cpn />

  <!-- 
  <Suspense>
    <template #default>
      <Cpn />
    </template>

    <template #fallback>
      <p>Suspense loading ...</p>
    </template>
  </Suspense> 
  -->
</template>
```

Suspense ，Vue3 新特性，用于渲染异步组件：

* 和 defineAsyncComponent 完整写法一样不会停止上级组件的渲染：

* 当子组件为 async setup 时（script setup 顶层使用 await 就会编译为 async setup），或者在非 script setup 顶层使用 await ，都会变为异步组件，父组件就必须使用 Suspense 才能渲染子组件，defineAsyncComponent 完整写法无法渲染

* 由于也是异步加载，所以也会分包

* 只有 loading 插槽，若需要 error ，则需要结合 defineAsyncComponent 完整写法

```
<!-- 
 <script setup lang="ts">
// Vue3 ，子组件
import { ref } from "vue";

const a = ref(0);
const test = new Promise<void>((resolve) => setTimeout(resolve, 3000));

await test;
</script> 
-->

<script lang="ts">
// Vue3 ，子组件

import { ref } from "vue";

const test = new Promise<void>((resolve) => setTimeout(resolve, 3000));

// 也会变为异步组件
// await test;

export default {
  async setup() {
    const a = ref(0);
    await test;

    // 虽然 return 的是 Promise ，但 template 也能正常使用
    return { a };
  },
};
</script>

<template>
  <p>{{ a }}</p>
</template>
```

```
<script setup lang="ts">
// Vue3 ，父组件

import { defineAsyncComponent } from "vue";
const Cpn = defineAsyncComponent(() => import("./Cpn.vue"));
</script>

<template>
  <p>Parent</p>

  <Suspense>
    <template #default>
      <Cpn />
    </template>

    <template #fallback>
      <p>Suspense loading ...</p>
    </template>
  </Suspense>
</template>
```

逐帧渲染，用渲染帧 API 分片渲染，类似 React 的 Fiber ，也属于异步组件但不分包，只是自己实现的分片渲染：

```
// /src/hooks/useDeferFrame.ts

import { ref, onMounted } from "vue";

export function useDeferFrame(maxFrame: number) {
  const frame = ref(0);

  // 使用该 hook 后，就开始计数帧
  function frameCount() {
    if (frame.value >= maxFrame) return;

    requestAnimationFrame(() => {
      ++frame.value;
      frameCount();
    });
  }
  onMounted(() => frameCount());

  // 提供给外部的判断函数
  const defer = (deferCount: number) => deferCount <= frame.value;

  return defer;
}
```

```
<script setup lang="ts">
// 子组件

const now = Date.now();
while (Date.now() - now < 100);
</script>

<template>
  <p>Cpn</p>
</template>
```

```
<script setup lang="ts">
// 父组件

import { onMounted } from "vue";
import { useDeferFrame } from "./hooks/useDeferFrame";
import Cpn from "./Cpn.vue";

const defer = useDeferFrame(300);

onMounted(() => console.log("ok"));
</script>

<template>
  <p>App</p>

  <!-- 阻塞，3s 后渲染父组件 -->
  <!-- <Cpn v-for="i in 30" /> -->

  <!-- 延迟装载，不阻塞父组件，根据需要控制哪一帧渲染 -->
  <template v-for="i in 30">
    <Cpn v-if="defer((i - 1) * 10)" />
  </template>
</template>
```

（6）Teleport

传颂组件，Vue3 新特性，将插槽内容传颂到 to 指定的选择器的父元素内，是 DOM 结构层面的传颂，父元素会被更换，适合做 loading 、mask 等：

```
<script setup lang="ts">
import { ref } from "vue";
import type { Ref } from "vue";

function useHidden(value: boolean = false): [Ref<boolean>, () => any] {
  const isShow = ref(value);
  const switchShow = () => (isShow.value = !isShow.value);
  return [isShow, switchShow];
}

const [isShowBox1, switchShowBox1] = useHidden(true);
const [isShowBox2, switchShowBox2] = useHidden(true);

const [isShowTP1, switchShowTP1] = useHidden(true);
const [isShowTP2, switchShowTP2] = useHidden(true);

const [isShowSlot1, switchShowSlot1] = useHidden(true);
const [isShowSlot2, switchShowSlot2] = useHidden(true);
</script>

<template>
  <p>
    <button @click="switchShowBox1">v-show box</button>
    <button @click="switchShowBox2">v-if box</button>
  </p>

  <p>
    <button @click="switchShowTP1">v-show TP</button>
    <button @click="switchShowTP2">v-if TP</button>
  </p>

  <p>
    <button @click="switchShowSlot1">v-show Slot</button>
    <button @click="switchShowSlot2">v-if Slot</button>
  </p>

  <!-- 测试父元素
      * 父元素不是 .box 而是 .box 外 body 内的元素，所以 box 的 v-show 对 TP 无效
      * 但 box 的 v-if 对 TP 有效，因为只有创建了 box 才能传颂 TP
      * v-if 对 TP 有效，v-show 无效，因为传颂的是插槽内容，不是 TP 本身
      * v-if 、v-show 对 TP 插槽都有效
   -->
  <div class="box" v-show="isShowBox1" v-if="isShowBox2">
    <Teleport to="body" v-show="isShowTP1" v-if="isShowTP2">
      <div class="loading" v-show="isShowSlot1" v-if="isShowSlot2">loading</div>
    </Teleport>
  </div>
</template>

<style scoped lang="less">
.loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100px;
  height: 50px;
  border: 1px solid #000;
  line-height: 50px;
  text-align: center;
}

// 测试父元素 ---------------------------------------------------------------------
.box {
  width: 100px;
  height: 100px;
  border: 1px solid #000;

  // 无效
  .loading {
    font-size: 100px;
  }
}

body {
  // 有效
  .loading {
    background-color: red;
    color: #fff;
  }

  // 无效，因为不在次一级
  > box {
    font-size: 100px;
  }
}
</style>
```

### 3.4 插件

（1）基本

use 函数极简实现，用于使用插件：

```
const app = {
  use(plugin: { install: Function }) {
    plugin.install(this);
    return this;
  },
};

app.use({
  install(app: any) {
    console.log("hello");
  },
});
```

编写插件时，可能需要再全局注入资源：

```
// Vue2，添加到 Vue 原型上，使用时直接 this 在圆形上找
Vue.prototype.xxx = 123;

// Vue3
app.config.globalProperties.xxx = 123;
```

Vue3 的 setup  this 为 undefined ，使用插件或者获取组件信息需要使用一个 hook ：

```
<script setup lang="ts">
import { getCurrentInstance } from "vue";

// undefined
console.log(this);

const instance = getCurrentInstance();

// 获取全局资源
const global = instance?.appContext.config.globalProperties;
console.log(global);

// 获取组件信息
console.log(instance?.type.name);
</script>

<script lang="ts">
export default {
  name: "Cpn",
};
</script>

<template></template>
```

（2）指令插件

用于注册全局指令，核心：

```
// Vue2
Vue.directive("dirName", options);

// Vue3
app.directive("dirName", options);
```

封装：

```
// /src/plugins/directive/index.ts

import type { App, Directive, DirectiveBinding } from "vue";

interface Dir {
  name: string;
  options: Directive;
}

const dirs: Dir[] = [
  {
    name: "auth",
    options: {
      mounted(el: HTMLElement, dir: DirectiveBinding) {
        console.log("v-auth", dir.value);
      },
    },
  },
];

// main.ts 导入，执行 use 即可
export default {
  install(app: App) {
    for (const dir of dirs) app.directive(dir.name, dir.options);
  },
};
```

（3）组件插件

组件插件也叫命令式组件，用函数的形式使用全局组件。

将一个全局组件注册为插件，暴漏一些数据和函数给外部使用，如弹窗插件.，核心：

```
// VUE2
Vue.prototype.cpnName = obj;

// VUE3
app.config.globalProperties["cpnName"] = obj;
```

Vue2 ：

```
// /src/plugins/component/index.js

import Dialog from "./Dialog.vue";

const plugins = [Dialog];

// main.js 中 Vue.use() 即可；使用时 this.$dialog 即可
export default {
  install(Vue) {
    for (const cpn of plugins) {
      if (!cpn.name) continue;

      const cpnConstructor = Vue.extend(cpn);
      const VNode = new cpnConstructor();

      VNode.$mount(document.createElement("div"));
      document.body.appendChild(VNode.$el);

      Vue.prototype[cpn.name] = VNode;
    }
  },
};
```

Vue3 ：

```
<script setup lang="ts">
// /src/plugins/component/Dialog.vue

import { ref } from "vue";

defineOptions({
  name: "$dialog",
});

const isShow = ref(false);
const text = ref("");

const show = (msg: string = "") => {
  text.value = msg;
  isShow.value = true;
};

const hidden = () => {
  text.value = "";
  isShow.value = false;
};

defineExpose({ show, hidden });
</script>

<template>
  <Teleport to="body">
    <div class="my-dialog" v-show="isShow">
      <div class="my-dialog-main">
        <div class="my-dialog-text">{{ text }}</div>
      </div>

      <div class="my-dialog-footer">
        <button @click="hidden">确定</button>
      </div>
    </div>
  </Teleport>
</template>

<style scoped lang="less">
@my-dialog-border: 1px solid #000;

.flex-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.my-dialog {
  display: flex;
  flex-direction: column;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 400px;
  height: 100px;
  border: @my-dialog-border;
  border-radius: 10px;

  > .my-dialog-main {
    .flex-center();
    flex: 1;
    padding: 10px;

    > .my-dialog-text {
      overflow: hidden;
    }
  }

  > .my-dialog-footer {
    .flex-center();
    height: 30px;
    border-top: @my-dialog-border;

    > button {
      border-radius: 5px;
    }
  }
}
</style>
```

```
// /src/plugins/component/index.ts

import { createVNode, isVNode, render } from "vue";
import type { App } from "vue";

import Dialog from "./Dialog.vue";

// 所有插件一起注册
const plugins = [Dialog];

// main.ts 导入，执行 use 即可
export default {
  install: (app: App) => {
    for (const cpn of plugins) {
      if (!cpn.name) continue;

      // 创建虚拟 DOM，render 成真实 DOM
      const VNode = createVNode(cpn);
      render(VNode, document.createElement("div"));

      // render 后才会有 component 属性
      const exposed = VNode.component!.exposed;
      app.config.globalProperties[cpn.name] = exposed;
    }
  },
};
```

```
// /src/main.ts
import component from "./plugins/component";
app.use(component);
```

```
<script setup lang="ts">
import { getCurrentInstance } from "vue";

const instance = getCurrentInstance();
const global = instance?.appContext.config.globalProperties;
const $dialog = global?.$dialog;

$dialog.show();
// $dialog.hidden();
</script>

<template></template>
```

### 3.5 组件封装

#### 3.5.1 封装

（1）通用组件

通用组建的封装应该尽量简单易用：

* 提供默认的功能，若需要额外的功能再传入事件等

* 若想要更加通用，可以封装为命令式组件

封装一个命令式组件，可以用组件插件，但组件插件是全局组件，扩展功能也不太灵活，这里提供一个更灵活的实现方式：

```
// message.tsx ， 为了高内聚，将组建也写在这个文件，所以需要 JSX

import { defineComponent, createApp } from "vue";

const Message = defineComponent({
  props: { msg: String },
  emits: ["close"],

  setup(props, { emit }) {
    return () => <span onClick={() => emit("close")}>{props.msg}</span>;
  },
});

export function showMessage(
  msg: string = "messgae",
  onClose?: (close: () => void) => void
) {
  const container = document.createElement("div");
  document.body.appendChild(container);

  const close = () => document.body.removeChild(container);

  const vnode = createApp(Message, {
    msg,
    onClose: () => {
      if (onClose) return onClose(close);
      close();
    },
  });

  vnode.mount(container);
}
```

```
<script setup lang="ts">
// 使用

import { showMessage } from "./message";

showMessage();
showMessage("hello");
showMessage("hello", (close) => {
  console.log("close");
  close();
});
</script>
```

（2）业务组件

业务组建可以拆分为展示组件、容器组件：

* 展示组件：只作展示，使用 props 提供的数据，emit 抛出事件给外部处理，最多只做一些简单逻辑如表单验证
  
  * 在 Vue2 中，可以设置配置项 functional 为 true 并使用 render 函数，或者 template 使用 functional 属性，使这个组件成为无状态无实例的函数式组件，正好可以用来做展示组件；
    
    * 无状态指无法定义 data ，只能使用 props ，也没有生命周期
    
    * 无实例指由于没有状态就不需要创建组件实例，因此初始速度、内存消耗都会变小
  
  * Vue3 是否使用 functional 的性能差距已经很小了，所以没必要使用 functional

* 容器组件：提供数据，处理逻辑，并使用展示组件

例如表单组件，新增和修改最好都拆分为两个展示组件，再由外部的容器组件使用；虽然新增/修改的样式、展示的内容大部分类似，但随着业务不断扩充，组件内就会逐渐充斥新增/修改的判断以及数据逻辑，形成了高度耦合，难以维护。

展示组件、容器组件就是用来解耦的：

```
// /src/components/UserInfo/type.ts

// 用户信息
export interface UserData {
  id: string;
  name: string;
}

// 表单信息
export interface UserFormInfo {
  type: "text" | "radio" | "checkbox";
  prop: string;
  rules?: Array<{
    type: "required" | "xxx";
    message: string;
  }>;
  failedMessage?: string;
}

//// v-model ，key 为 info 的 prop
export type UserFormData = Record<string, any>;
```

```
<script setup lang="ts">
// /src/components/UserInfo/Add.vue ，展示组件，若还有 update 等也是另外单独写一个组件，因为在一些逻辑、样式会有不同

import type { UserFormInfo, UserFormData } from "./type";

const props = defineProps<{
  modelValue: UserFormData;
  formInfo: UserFormInfo[];
  isShow: boolean;
}>();

const emit = defineEmits(["update:modelValue", "submit", "reset", "cancel"]);

// 表单验证
function valid() {
  for (const i of props.formInfo) {
    if (!i.rules?.length) continue;

    for (const r of i.rules) {
      switch (r.type) {
        case "required":
          if (props.modelValue[i.prop] === "") {
            i.failedMessage = r.message;
            return false;
          }

          break;
        default:
          break;
      }
    }
  }

  return true;
}

function submit(e: Event) {
  e.preventDefault();
  if (valid()) emit("submit");
}
</script>

<template>
  <div>
    <Teleport to="body">
      <div class="form-area" v-show="isShow">
        <div>Add</div>

        <form @submit="submit" @reset="$emit('reset')">
          <div v-for="(i, iIndex) in formInfo">
            <input
              :type="i.type"
              :value="modelValue[i.prop]"
              @input="
                $emit('update:modelValue', {
                  ...modelValue,
                  [i.prop]: ($event.target as any).value,
                })
              "
            />

            <div v-show="i.failedMessage !== undefined">
              {{ i.failedMessage }}
            </div>
          </div>

          <div>
            <button>submit</button>
            <button type="reset">reset</button>
            <button type="button" @click="$emit('cancel')">cancel</button>
          </div>
        </form>
      </div>
    </Teleport>
  </div>
</template>

<style scoped lang="less">
.form-area {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  padding: 10px;
  border: 1px solid #000;
  border-radius: 10px;
}
</style>
```

```
<script setup lang="ts">
// /src/components/UserInfo/Show.vue ，展示组件

import type { UserData } from "./type";

defineProps<{
  list: UserData[];
  buttonDisabled?: boolean;
}>();

defineEmits(["add"]);
</script>

<template>
  <p>
    <button :disabled="buttonDisabled" @click="$emit('add')">add</button>
  </p>

  <ul>
    <li v-for="i in list" :key="i.id">
      <span>{{ i.name }}</span>
    </li>
  </ul>
</template>
```

```
<script setup lang="ts">
// /src/components/UserInfo/index.vue ，容器组件

import { ref, reactive } from "vue";
import { v4 as uuidv4 } from "uuid";

import Show from "./Show.vue";
import Add from "./Add.vue";
import type { UserData, UserFormInfo, UserFormData } from "./type";

const userList = reactive<UserData[]>([{ id: "0", name: "asdf" }]);

const formInfo = reactive<UserFormInfo[]>([
  {
    type: "text",
    prop: "username",
    rules: [{ type: "required", message: "用户名不能为空" }],
  },
]);

const initialFormData: UserFormData = {
  username: "",
};
const formData = ref(structuredClone(initialFormData));

const mode = ref<"add" | null>(null);

function clearUserFormData() {
  formData.value = structuredClone(initialFormData);
  for (const info of formInfo) info.failedMessage = undefined;
}

function addSubmit() {
  mode.value = null;

  userList.push({
    id: uuidv4(),
    name: formData.value["username"],
  });

  clearUserFormData();
}

function addCancel() {
  mode.value = null;
  clearUserFormData();
}
</script>

<template>
  <p>测试：{{ formData["username"] }}</p>

  <Show :list="userList" :button-disabled="mode !== null" @add="mode = 'add'" />

  <Add
    v-model="formData"
    :formInfo="formInfo"
    :isShow="mode === 'add'"
    @submit="addSubmit"
    @reset="clearUserFormData"
    @cancel="addCancel"
  />
</template>
```

```
<script setup lang="ts">
// /src/App.vue
import UserInfo from "./components/UserInfo/index.vue";
</script>

<template>
  <UserInfo />
</template>
```

#### 3.5.2 二次封装

（1）通用组建二次封装

若通用组件过于通用了，为了增加额外的功能，就需要二次封装。

首先要解决的就是 props 、emits 、slots 、ref 的透传问题（React 中直接透传 props 即可）：

* 即使在 Vue3 ，被二次封装的组件也必须是有且只有一个根元素，用于接受透传的数据

* props 、emits 、slots ：使用 attrs 、slots 即可，Vue3 中 listeners 被放入了 attrs

* ref ：放入 expose 即可，React 中也类似

* TS 类型：将 defineExpose 传入的对象断言为被二次封装组件的实例类型即可，在使用时就能获得 props 、emits 、slots 的类型

示例：

```
<script setup lang="ts">
// Test.vue ，被二次封装的组件

defineModel("modelValue", { required: true });

withDefaults(
  defineProps<{
    a: number;
    b?: number;
  }>(),

  {
    b: 2,
  }
);

defineEmits<{
  (e: "showMessage", msg: string): void;
}>();

defineExpose({
  testRun: () => console.log("test func run"),
});
</script>

<template>
  <div>
    <div>Text</div>
    <ul>
      <li>
        <button @click="$emit('showMessage', 'test msg')">show message</button>
      </li>

      <li>
        <span>modelValue：{{ modelValue + " " }}</span>
        <button @click="$emit('update:modelValue', modelValue + 1)">add</button>
      </li>

      <li>a：{{ a }}</li>
      <li>b：{{ b }}</li>

      <li>
        <slot></slot>
      </li>
      <li>
        <slot name="testSlot" msg="test slot"></slot>
      </li>
    </ul>
  </div>
</template>
```

```
<script setup lang="ts">
// Cpn.vue ，对 Test 组建进行二次封装

import { getCurrentInstance, h } from "vue";
import Test from "./Test.vue";
import type { ComponentInstance } from "vue";

// 额外扩充的 props 、emit 、exposed ----------------------------------------------------
interface CpnProps {
  c: number;
}

interface CpnExposed {
  cpnRun: () => void;
}

defineProps<CpnProps>();
defineEmits(["addC"]);
defineExpose({} as CpnExposed & ComponentInstance<typeof Test>);

// 将 Test 组件的 exposed 挂载到 Cpn 组件的 exposed 中 ---------------------------------------
const vm = getCurrentInstance();
function getRef(exposed: any) {
  vm!.exposed = {
    cpnRun: () => console.log("cpn func run"),
    ...exposed,
  };
}
</script>

<template>
  <div>
    <!-- 方式一 -->
    <Component :is="h(Test as any, { ...$attrs, ref: getRef }, $slots)" />

    <!-- 方式二 -->
    <!-- 
    <Test :ref="getRef" v-bind="$attrs as any">
      <template v-for="(_, name) in $slots" #[name]="data">
        <slot :name="name" v-bind="data"></slot>
      </template>
    </Test> 
    -->

    <div>Cpn</div>
    <ul>
      <li>
        <span>c：{{ c + " " }}</span>
        <button @click="$emit('addC', $props.c + 1)">addC</button>
      </li>

      <li>
        <slot name="cpnSlot" msg="cpn slot"></slot>
      </li>
    </ul>
  </div>
</template>
```

```
<script setup lang="ts">
// 使用

import { ref, useTemplateRef, onMounted } from "vue";
import Cpn from "./Cpn.vue";

const value = ref(0);
const c = ref(3);

const cpn = useTemplateRef("cpnRef");
onMounted(() => {
  cpn.value!.cpnRun();
  cpn.value!.testRun();
});
</script>

<template>
  <Cpn
    ref="cpnRef"
    v-model="value"
    :a="1"
    :b="2"
    @show-message="console.log($event)"
    :c="c"
    @addC="c = $event"
  >
    <template #cpnSlot="{ msg }">
      <p>{{ msg }}</p>
    </template>

    <template #default>
      <p>test default slot</p>
    </template>

    <template #testSlot="{ msg }">
      <p>{{ msg }}</p>
    </template>
  </Cpn>
</template>
```

（2）业务组建二次封装）

组组件库的表单组件：

* 需要解决 props 、emit 、slot 、ref 的透传：
  
  * el\-form 的透传参考通用组件的二次封装，透传即可
  
  * 各个表单的 props 、emits 、slots 透传无法解决，这里选择将他们放入 formInfo 中

* 表单 formInfo 的数据结构设计为类似二维数组的结构：
  
  * 因为考虑到有些场景需要一行多个表单，这种情况可以用 el\-col 或 el\-space 控制布局
  
  * 表单根据 type 的不同，用 Component 动态生成

* 表单 v\-model 的数据 formData 、和表单验证的配置 formRule 单独存在，根据 formInfo 自动生成：
  
  * formInfo 通过 prop 映射 formDaata 、formRule 的 key
  
  * 为了实现新增、删除表单的功能，用 reactive 定义 formInfo 、formRule
  
  * 其中 formData 用于表单 v\-model 时需要保证单向数据流，需要修改数据时 emit 给父组件，让父组件修改 formData；父组件为了方便组件 v\-model ，只能用 ref 定义 formData ，因为 reactive 无法直接赋值整个对象

* el\-form 的 model 属性和 el\-form\-item 的 prop 属性，在需要表单验证、或 reset 的场景时必须传入，prop 对应 formData 的 key

* 与原生 form 不同的是，elementplus 是在 el\-button 监听 click 事件再自行处理 submit 、reset ，且 reset 可以通过调用 ElForm 实例的方法把 v\-model 的数据、表单验证信息一并重置，为了方便，提供 reset 、clear 、submit 的表单 type

* 其他为实现：
  
  * el\-upload 建议二次封装上传组件后再植入
  
  * 动态表单，即表单的 info 是根据其他表单 value 生成，若业务较简单，可以用链表实现，next 为生成 info 的函数；若较复杂，建议直接用阿里的 Formily

示例：

```
# 至少需要 2.11.4 版本
pnpm add element-plus@latest
```

```
// /src/component/CommonForm/feature.ts ，增加新类型的表单时，大部分情况下修改这个文件即可

import type { _ElType, CustomEventArgs, ElType } from "./type";

import {
  ElButton,
  ElText,
  ElInput,
  ElAutocomplete,
  ElInputNumber,
  ElInputTag,
  ElRadioGroup,
  ElRadio,
  ElRadioButton,
  ElCheckboxGroup,
  ElCheckbox,
  ElCheckboxButton,
  ElSelect,
  ElOptionGroup,
  ElOption,
  ElSelectV2,
  ElCascader,
  ElCascaderPanel,
  ElMention,
  ElTreeSelect,
  ElTransfer,
  ElColorPicker,
  ElColorPickerPanel,
  ElTimePicker,
  ElTimeSelect,
  ElDatePicker,
  ElDatePickerPanel,
  ElSlider,
  ElRate,
  ElSwitch,
} from "element-plus";

import {
  buttonEmits,
  inputEmits,
  autocompleteEmits,
  inputNumberEmits,
  inputTagEmits,
  radioGroupEmits,
  radioEmits,
  checkboxGroupEmits,
  checkboxEmits,
  selectEmits,
  cascaderEmits,
  cascaderPanelEmits,
  mentionEmits,
  transferEmits,
  colorPickerEmits,
  colorPickerPanelEmits,
  sliderEmits,
  rateEmits,
  switchEmits,
} from "element-plus";

// 部分组件没有提供 Emits 类型也没有提供 Emits 变量
export type AnyEmits = Record<string, (...args: any[]) => void>;

// 各个表单，传入组件实例类型和 emits 类型 ----------------------------------------------
export interface _El {
  button: _ElType<typeof ElButton, typeof buttonEmits>;
  reset: _ElType<typeof ElButton, typeof buttonEmits>;
  clear: _ElType<typeof ElButton, typeof buttonEmits>;
  submit: _ElType<typeof ElButton, typeof buttonEmits>;

  text: _ElType<typeof ElText, never>;

  input: _ElType<typeof ElInput, typeof inputEmits>;
  autocomplete: _ElType<typeof ElAutocomplete, typeof autocompleteEmits>;
  "input-number": _ElType<typeof ElInputNumber, typeof inputNumberEmits>;
  "input-tag": _ElType<typeof ElInputTag, typeof inputTagEmits>;

  radio: _ElType<typeof ElRadioGroup, typeof radioGroupEmits>;
  checkbox: _ElType<typeof ElCheckboxGroup, typeof checkboxGroupEmits>;
  check: _ElType<typeof ElCheckbox, typeof checkboxEmits>;
  "radio-button": _ElType<typeof ElRadioGroup, typeof radioGroupEmits>;
  "checkbox-button": _ElType<typeof ElCheckboxGroup, typeof checkboxGroupEmits>;
  "check-button": _ElType<typeof ElCheckbox, typeof checkboxEmits>;

  select: _ElType<typeof ElSelect, typeof selectEmits>;
  "select-v2": _ElType<typeof ElSelectV2, typeof selectEmits>;

  cascader: _ElType<typeof ElCascader, typeof cascaderEmits>;
  "cascader-panel": _ElType<typeof ElCascaderPanel, typeof cascaderPanelEmits>;

  mention: _ElType<typeof ElMention, typeof mentionEmits>;

  "tree-select": _ElType<typeof ElTreeSelect, AnyEmits>;
  transfer: _ElType<typeof ElTransfer, typeof transferEmits>;

  "color-picker": _ElType<typeof ElColorPicker, typeof colorPickerEmits>;
  "color-picker-panel": _ElType<
    typeof ElColorPickerPanel,
    typeof colorPickerPanelEmits
  >;

  "date-picker": _ElType<typeof ElDatePicker, AnyEmits>;
  "time-picker": _ElType<typeof ElTimePicker, AnyEmits>;
  "time-select": _ElType<typeof ElTimeSelect, typeof selectEmits>;
  "date-picker-panel": _ElType<typeof ElDatePickerPanel, AnyEmits>;

  slide: _ElType<typeof ElSlider, typeof sliderEmits>;
  rate: _ElType<typeof ElRate, typeof rateEmits>;
  switch: _ElType<typeof ElSwitch, typeof switchEmits>;
}

// 自定义 button
export type CustomButtonCallback = {
  // 清除验证信息，并重置为初始值；可以传入 prop 来只处理某个表单，不传则处理全部表单
  reset: (prop?: string) => void;
  // 清除验证信息，并把 value 置为空指
  clear: () => void;
  // 表单验证
  submit: () => Promise<null>;
};

/**部分表单如 radio 、checkbox 、select 需要 options 组件 ---------------------------------------
 * element-plus 对于这类组件有两种风格，这里都有，未来肯呢逐步优化为第二种方式：
   - 第一种如 el-select 通过组件 el-optionb 处理 item ，二次封装比较繁琐
   - 第二种如 el-select-v2 通过 options 属性传入数据，使用和二次封装都比较方便
*/
export interface _ElOpt {
  radio: _ElType<typeof ElRadio, typeof radioEmits>;
  checkbox: _ElType<typeof ElCheckbox, typeof checkboxEmits>;
  "radio-button": _ElType<typeof ElRadio, typeof radioEmits>;
  "checkbox-button": _ElType<typeof ElCheckbox, typeof checkboxEmits>;
  select: _ElType<typeof ElOption, never>;
}

// 部分 option 可能还会有分组的场景
export interface _ElOptGroup {
  select: _ElType<typeof ElOptionGroup, never>;
}

// 有 options 属性淡不需要 option 组件
export type ElNotOpt = Record<
  "select-v2" | "cascader" | "cascader-panel" | "mention",
  boolean
>;

// 有 data 属性（类似 options 属性）淡不需要 option 组件
export type ElNotOptByData = Record<"tree-select" | "transfer", boolean>;

/**进一步处理 element-plus 类型 --------------------------------------------------------
 * props：
   - 之所以不用官方提供的 Props 类型，是因为有些组件没有导出 Props 类型，有些是类似 Vue 的 props 配置项的变量，
     所以统一从组件实例获取 Props 类型；缺点就是这样得到的类型会多出一些如 ref 、class 等标签属性，需要去掉
   - 去掉 readonly 并加上响应式数据类型；且全部变为可选属性；再去掉与 formInfo 配置冲突的属性如 modelValue
 * emits：
   - 之所以不使用官方提供的 Emits 类型，是因为有些组件的 Emits 是函数重载类型，不好处理
   - 增加一些自定义形参，方便使用
 * slots：
   - 官方没有提供插槽类型，就不手写了，slot name 只能限制为 string
   - 插槽内容支持传入 vnode（包括 string 、number 等）、组件（必须使用 markRaw ，$attrs 接收插槽参数） 、函数
*/
export type El = {
  [Type in keyof _El]: ElType<
    Type,
    _El[Type]["props"],
    _El[Type]["emits"],
    CustomEventArgs<Type>,
    _El[Type]["slots"]
  >;
};

export type ElOpt = {
  [Type in keyof _ElOpt]: ElType<
    Type,
    _ElOpt[Type]["props"],
    _ElOpt[Type]["emits"],
    CustomEventArgs<Type, true>,
    _ElOpt[Type]["slots"]
  >;
};

export type ElOptGroup = {
  [Type in keyof _ElOptGroup]: ElType<
    Type,
    _ElOptGroup[Type]["props"],
    never,
    never,
    never
  >;
};

// 表单 type 联合类型
export type FormItemType = keyof El;
export type CustomButtonType = keyof CustomButtonCallback;
export type FormItemOptionType = keyof ElOpt;
export type FormItemOptionGroupType = keyof ElOptGroup;
export type FormItemNotOptionType = keyof ElNotOpt;
export type FormItemNotOptionByDataType = keyof ElNotOptByData;

// Component -------------------------------------------------------------------------
export type FormItemComponent = Record<FormItemType, Component>;
export type FormItemOptionComponent = Record<FormItemOptionType, Component>;
export type FormItemOptionGroupComponent = Record<
  FormItemOptionGroupType,
  Component
>;

// 根据 type 获取表单对应的 Component
export const elComponent: FormItemComponent = {
  button: ElButton,
  reset: ElButton,
  clear: ElButton,
  submit: ElButton,
  text: ElText,
  input: ElInput,
  autocomplete: ElAutocomplete,
  "input-number": ElInputNumber,
  "input-tag": ElInputTag,
  mention: ElMention,
  radio: ElRadioGroup,
  "radio-button": ElRadioGroup,
  checkbox: ElCheckboxGroup,
  "checkbox-button": ElCheckboxGroup,
  check: ElCheckbox,
  "check-button": ElCheckboxButton,
  select: ElSelect,
  "select-v2": ElSelectV2,
  cascader: ElCascader,
  "cascader-panel": ElCascaderPanel,
  "tree-select": ElTreeSelect,
  transfer: ElTransfer,
  "color-picker": ElColorPicker,
  "color-picker-panel": ElColorPickerPanel,
  "date-picker": ElDatePicker,
  "time-picker": ElTimePicker,
  "time-select": ElTimeSelect,
  "date-picker-panel": ElDatePickerPanel,
  slide: ElSlider,
  rate: ElRate,
  switch: ElSwitch,
};

// 根据 type 获取表单对应的 Option Component
export const elOptionComponent: FormItemOptionComponent = {
  radio: ElRadio,
  "radio-button": ElRadioButton,
  checkbox: ElCheckbox,
  "checkbox-button": ElCheckboxButton,
  select: ElOption,
};

// 根据 type 获取表单对应的 Option group Component
export const elOptionGroupComponent: FormItemOptionGroupComponent = {
  select: ElOptionGroup,
};

// 不需要 option 组件
export const notElOption: ElNotOpt = {
  "select-v2": true,
  cascader: true,
  "cascader-panel": true,
  mention: true,
};
export const notElOptionByData: ElNotOptByData = {
  "tree-select": true,
  transfer: true,
};

// v-model ----------------------------------------------------------------------------
// 表单类型与 v-model 初始值的映射类型
export type FormItemValue = {
  [K in FormItemType as El[K]["modelValue"] extends never
    ? never
    : K]: El[K]["modelValue"];
};

// 根据 type 获取表单对应的默认值
export const initValue: FormItemValue = {
  input: "",
  autocomplete: "",
  "input-number": 0,
  "input-tag": [],
  mention: "@",
  radio: "",
  "radio-button": "",
  checkbox: [],
  "checkbox-button": [],
  check: false,
  "check-button": false,
  select: "",
  "select-v2": "",
  cascader: [],
  "cascader-panel": [],
  "tree-select": "",
  transfer: [],
  "color-picker": "",
  "color-picker-panel": "",
  "time-picker": "",
  "time-select": "",
  "date-picker": "",
  "date-picker-panel": "",
  slide: 0,
  rate: 0,
  switch: false,
};
```

```
// /src/components/CommonForm/type.ts ，定义 ts 类型

import type { CSSProperties, VNodeChild, DefineComponent, Ref, Raw } from "vue";

import type {
  FormItemRule,
  FormItemProps,
  SpaceProps,
  ColProps,
  FormInstance,
} from "element-plus";

import type {
  _El,
  El,
  CustomButtonCallback,
  ElOpt,
  ElOptGroup,
  FormItemType,
  CustomButtonType,
  FormItemOptionType,
  FormItemOptionGroupType,
  FormItemNotOptionType,
  FormItemNotOptionByDataType,
} from "./feature";

// 处理 props 、emits 、slots 、modelValue ----------------------------------------------------
// 自定义 event 参数
export type CustomEventArgs<
  T extends FormItemType,
  IsOpt extends boolean = false
> = {
  rowIndex: number;
  colIndex: number;
  item: CommonFormItem<T>;
} & (IsOpt extends true
  ? { optIndex: number; itemOpt: FormItemOptionsInfo<T> }
  : {}) &
  (T extends CustomButtonType
    ? {
        callback: CustomButtonCallback[T];
      }
    : {});

// 自定义插槽内容类型
export type GetSlotValue =
  | VNodeChild
  | Ref<VNodeChild>
  | Raw<DefineComponent<any, any, any, any, any>>
  | ((scope?: Record<string, any>) => VNodeChild);

// 原始 props 、emits 、slots
export type _ElType<
  Cpn extends abstract new (...args: any) => any,
  E extends Record<string, (...args: any[]) => any>,
  Slots = Record<string, GetSlotValue>
> = {
  props: InstanceType<Cpn>["$props"];
  emits: E;
  slots: Slots;
};

// 处理 props 、emits 、slots
export type ElType<
  T extends FormItemType,
  P extends Record<string, any>,
  E extends Record<string, (...args: any[]) => any>,
  A extends CustomEventArgs<T>,
  Slots
> = {
  props: Omit<
    {
      -readonly [K in keyof P]?: P[K] | Ref<P[K] | undefined>;
    },
    | "modelValue"
    | "value"
    | "label"
    | "prop"
    | "props"
    | "options"
    | "class"
    | "style"
    | "key"
    | "ref"
    | "ref_for"
    | "ref_key"
    | "onUpdate:modelValue"
    | "onVnodeBeforeMount"
    | "onVnodeMounted"
    | "onVnodeBeforeUpdate"
    | "onVnodeUpdated"
    | "onVnodeBeforeUnmount"
    | "onVnodeUnmounted"
  >;

  modelValue: P extends {
    modelValue?: infer V;
  }
    ? V
    : never;

  emits: E extends never
    ? never
    : Omit<
        {
          [K in keyof E]?: E[K] extends
            | ((...args: infer Args) => any)
            | undefined
            ? (info: A, ...args: Args) => void
            : never;
        },
        "update:modelValue"
      >;

  slots: Slots extends never ? never : Slots;
};

// 表单信息 ------------------------------------------------------------------------------------
// 通用属性
export type ClassType = string | string[] | Record<string, boolean>;
export type StyleType = string | CSSProperties | (string | CSSProperties)[];
export type FormItemCommonInfo<T extends FormItemType> = {
  // 表单
  readonly type: T;
  readonly label?: string;
  span?: number | Ref<number | undefined>;
  class?: ClassType;
  style?: StyleType;
  bind?: Partial<El[T]["props"]>;
  event?: El[T]["emits"];
  slots?: El[T]["slots"];

  // el-col
  elColClass?: ClassType;
  elColStyle?: StyleType;
  elColBind?: Omit<Partial<ColProps>, "span">;

  // 列 el-form-item
  colElFormItemBind?: Omit<
    Partial<FormItemProps>,
    "label" | "prop" | "rules" | "required" | "error"
  >;
  colElFormItemSlots?: Partial<Record<"label" | "error", GetSlotValue>>;
};

// 是否需要 v-model（prop 会作为 v-for 的 key ，若没有则使用 id）
export type FormItemModelInfo<T extends FormItemType> =
  El[T]["modelValue"] extends never
    ? { readonly id: string }
    : {
        readonly prop: string;
        readonly defaultValue?: El[T]["modelValue"];
        readonly rules?: FormItemRule[];
      };

// 是否需要 options 组件
export type FormItemOpt<T extends FormItemOptionType> = {
  value: string;
  label?: string;
  bind?: ElOpt[T]["props"];
  event?: ElOpt[T]["emits"];
  slots?: ElOpt[T]["slots"];
};
export type FormItemOptionsInfo<T extends FormItemType> =
  T extends FormItemOptionGroupType
    ? {
        options:
          | Array<
              ({ label: string } | { id: string }) & {
                options: FormItemOpt<T>[];
                bind?: ElOptGroup[T]["props"];
              }
            >
          | FormItemOpt<T>[];
      }
    : T extends FormItemOptionType
    ? {
        options: FormItemOpt<T>[];
      }
    : T extends FormItemNotOptionType
    ? {
        // 官方的 props 可以修改 options 的 key name ，所以 options key 的类型限制基本没有，string 就行，也不手写了
        props?: _El[T]["props"]["props"];
        options: Exclude<_El[T]["props"]["options"], undefined>;
      }
    : T extends FormItemNotOptionByDataType
    ? {
        // props 同上
        props?: _El[T]["props"]["props"];
        data: Exclude<_El[T]["props"]["data"], undefined>;
      }
    : {};

// 表单数据结构 -------------------------------------------------------------------------------
// 一个表单，利用 extends  展开表单 type 的联合类型，生成每个表单 type 对应的 item 类型
export type CommonFormItem<T extends FormItemType = FormItemType> =
  T extends any
    ? FormItemCommonInfo<T> & FormItemModelInfo<T> & FormItemOptionsInfo<T>
    : never;

// 一行表单，label 会作为 v-for 的 key ，若不传入，则使用 id
export type CommonFormRow = (
  | {
      readonly label: string;
    }
  | {
      readonly id: string;
    }
) & {
  // required 星号
  ruleRequiredTag?: boolean;

  // el-space
  isSpace?: boolean;
  elSpaceBind?: Partial<SpaceProps>;

  // 行 el-form-item
  rowElFormItemBind?: Omit<
    Partial<FormItemProps>,
    "label" | "prop" | "rules" | "required" | "error"
  >;
  rowElFormItemSlots?: Partial<Record<"label", GetSlotValue>>;

  // 列
  items: CommonFormItem[];
};

// 整个表单
export type CommonFormInfo = CommonFormRow[];

// formData 、formRule ，key 为 formInfo 各个 item 的 prop --------------------------------
// 获得 formInfo 各个表单的 prop 字段形成的联合类型
type FilterNeverProp<T> = T extends { prop: infer P } ? P : never;
export type GetPropUnion<T extends CommonFormInfo> = T extends []
  ? never
  : T[number]["items"] extends []
  ? never
  : FilterNeverProp<T[number]["items"][number]>;

// formData
export type CommonFormData<T extends CommonFormInfo = CommonFormInfo> = {
  [Prop in GetPropUnion<T>]: El[Extract<
    T[number]["items"][number],
    { prop: Prop }
  >["type"]]["modelValue"];
} & Record<string, any>;

// formRule
export type CommonFormRule<T extends CommonFormInfo = CommonFormInfo> = {
  [Prop in GetPropUnion<T>]?: FormItemRule[];
} & Record<string, FormItemRule[]>;

// Props 、Exposed ----------------------------------------------------------------------------------
// Props
export interface CommonFormProps {
  modelValue: CommonFormData;
  formInfo: CommonFormInfo;
}

// Exposed
export interface CommonFormExposed extends FormInstance {
  reset: CustomButtonCallback["reset"];
  clear: CustomButtonCallback["clear"];
  submit: CustomButtonCallback["submit"];
}
```

```
// /src/components/CommonForm/utils.ts ，提供工具

import { ref, reactive, h } from "vue";
import type { Ref, Reactive } from "vue";

import { initValue } from "./feature";
import type {
  CommonFormInfo,
  CommonFormData,
  CommonFormRule,
  CommonFormItem,
  CommonFormRow,
  GetSlotValue,
} from "./type";

// 根据 formInfo 生成 formData 、formRule ---------------------------------------------------
export function useCommonForm<const T extends CommonFormInfo>(
  initialFormInfo: T
) {
  const formInfo = reactive<CommonFormInfo>([]);
  const formData = ref({}) as Ref<CommonFormData<T>>;
  const formRule = reactive({}) as CommonFormRule<T>;

  addRowItem(initialFormInfo, formInfo, {
    formData,
    formRule,
  });

  return [formInfo, formData, formRule] as const;
}

export function addColItem(
  info: CommonFormItem | CommonFormItem[],
  rowInfo: Reactive<CommonFormRow>,
  data?: {
    insertBeforeIndex?: number;
    formData?: Ref<CommonFormData>;
    formRule?: Reactive<CommonFormRule>;
  }
) {
  const items = Array.isArray(info) ? info : [info];
  const { insertBeforeIndex, formData, formRule } = data ?? {};

  let needRowRuleRequiredTag = false;
  for (const item of items) {
    // formData
    if (!("prop" in item) || !formData) continue;
    formData.value[item.prop] = item.defaultValue ?? initValue[item.type];

    // formRue
    if (!!formRule && item.rules?.length) {
      if (item.rules.find((r) => r.required)) needRowRuleRequiredTag = true;
      formRule[item.prop] = item.rules;
    }
  }

  // 修改 formInfo
  const before = insertBeforeIndex ?? rowInfo.items.length;
  (rowInfo as CommonFormRow).items.splice(before, 0, ...items);
  // 只要有一个 colItem 是 required 的，rowItem 默认情况下就需要 requiredTag
  if (rowInfo.ruleRequiredTag === undefined && needRowRuleRequiredTag) {
    rowInfo.ruleRequiredTag = true;
  }
}

export function addRowItem(
  info: CommonFormRow | CommonFormRow[],
  formInfo: Reactive<CommonFormInfo>,
  data?: {
    insertBeforeIndex?: number;
    formData?: Ref<CommonFormData>;
    formRule?: Reactive<CommonFormRule>;
  }
) {
  const items = Array.isArray(info) ? info : [info];
  const { insertBeforeIndex, formData, formRule } = data ?? {};

  let before = insertBeforeIndex ?? formInfo.length;
  for (const row of items) {
    const colItems = row.items;
    const rowItem = {
      ...row,
      items: [],
    } as Reactive<CommonFormRow>;

    formInfo.splice(before++, 0, rowItem);

    addColItem(colItems, rowItem, {
      formData,
      formRule,
    });
  }
}

export function deleteColItem(
  rowIndex: number,
  colIndex: number,
  formInfo: Reactive<CommonFormInfo>,
  data?: {
    formData?: Ref<CommonFormData>;
    formRule?: Reactive<CommonFormRule>;
  }
) {
  const row = formInfo[rowIndex];
  const item = row?.items?.[colIndex];
  if (!item) return null;

  row.items.splice(colIndex, 1);

  if (!("prop" in item) || !data) return item;
  const prop = item.prop;
  const { formData, formRule } = data;

  delete formData?.value[prop];
  delete formRule?.[prop];

  return item;
}

export function deleteRowItem(
  rowIndex: number,
  formInfo: Reactive<CommonFormInfo>,
  data?: {
    formData?: Ref<CommonFormData>;
    formRule?: Reactive<CommonFormRule>;
  }
) {
  const row = formInfo[rowIndex];
  if (!row) return null;

  const len = row.items.length;
  for (let i = 0; i < len; i++) {
    deleteColItem(rowIndex, 0, formInfo, data);
  }

  formInfo.splice(rowIndex, 1);

  return row;
}

// 辅助组件 ------------------------------------------------------------------------------
// 空组件
export const template = (_: unknown, { slots }: { slots: any }) =>
  slots.default?.();

// 插槽
export const FormSlot = (props: {
  slot: GetSlotValue;
  scope?: Record<string, any>;
}) => {
  const { slot, scope } = props;

  if (
    (slot !== null && typeof slot === "object") ||
    typeof slot === "function"
  ) {
    return h(slot as Component, scope);
  }

  return slot;
};
```

```
<script setup lang="ts">
// /src/components/CommonForm/index.vue

import { getCurrentInstance } from "vue";
import { ElCol, ElSpace, ElFormItem } from "element-plus";

import { template, FormSlot } from "./utils";
import {
  elComponent,
  elOptionComponent,
  elOptionGroupComponent,
  notElOption,
  notElOptionByData,
} from "./feature";

import type {
  FormItemOptionType,
  FormItemOptionGroupType,
  FormItemNotOptionType,
  FormItemNotOptionByDataType,
  CustomButtonCallback,
  CustomButtonType,
} from "./feature";
import type { CommonFormProps, CommonFormExposed } from "./type";

const props = defineProps<CommonFormProps>();
const emit = defineEmits(["update:modelValue"]);

// exposed --------------------------------------------------------------------------------
const vm = getCurrentInstance();

defineExpose({} as CommonFormExposed);

function getElFormInstance(exposed: any) {
  vm!.exposed = {
    ...exposed,
    ...customButtonCallback,
  };
}

// reset 、clear 、submit --------------------------------------------------------------------------------
const customButtonCallback: CustomButtonCallback = {
  reset: (prop) => {
    vm?.exposed!.resetFields?.(prop);
  },

  clear: () => {
    const emptyFormData: Record<string, any> = {};
    for (const k in props.modelValue) {
      const valueType =
        Object.prototype.toString
          .call(props.modelValue[k])
          .match(/\[object (\w+)\]/)?.[1] ?? "";

      emptyFormData[k] =
        valueType === "String"
          ? ""
          : valueType === "Number"
          ? 0
          : valueType === "Boolean"
          ? false
          : valueType === "Array"
          ? []
          : 123;

      // 这里只清除验证信息
      vm!.exposed!.clearValidate?.(k);
    }

    // 清空
    emit("update:modelValue", emptyFormData);
  },

  submit: async () => {
    try {
      await vm!.exposed!.validate?.();
      return null;
    } catch (msg) {
      throw msg;
    }
  },
};

const customButtonEvent: Record<CustomButtonType, Function> = {
  reset: () => customButtonCallback["reset"](),
  clear: () => customButtonCallback["clear"](),
  submit: async () => {
    try {
      await customButtonCallback["submit"]();
    } catch (failedObj) {
      // console.log(failedObj);
    }
  },
};

// 透传 emit，使用缓存，防止重复执行 ---------------------------------------------------------
const formEventMemo = new WeakMap<
  any,
  {
    rowIndex: number;
    colIndex: number;
    event: Record<string, Function>;
  }
>();

function getEvent(
  rowIndex: number,
  colIndex: number,
  item: any,
  optIndex?: number,
  itemOpt?: any
) {
  // 如果没有事件，就不处理
  const isOption = optIndex !== undefined && itemOpt ? true : false;
  const event = isOption ? itemOpt.event : item.event;
  if (!event) return {};

  // 如果有缓存，且行列 index 无变化，就使用缓存
  if (formEventMemo.has(event)) {
    const { rowIndex: r, colIndex: c, event: e } = formEventMemo.get(event)!;
    if (rowIndex === r && colIndex === c) return e;
    else formEventMemo.delete(event);
  }

  // 处理
  const res: Record<string, Function> = {};
  for (const k in event) {
    const _fn = event[k];
    const info = Object.assign(
      // 通用参数
      {
        rowIndex,
        colIndex,
        item,
      },

      // 有 options 时需要的参数
      isOption
        ? {
            optIndex,
            itemOpt,
          }
        : {},

      // 自定义 button 需要 callback 函数
      customButtonCallback[item.type as CustomButtonType]
        ? { callback: customButtonCallback[item.type as CustomButtonType] }
        : {}
    );

    const fn = (e: Event) => {
      _fn(info, e);
    };

    res[k] = (e: Event) => fn(e);
  }

  // 保存到缓存
  formEventMemo.set(event, { rowIndex, colIndex, event: res });

  return res;
}
</script>

<template>
  <el-form :ref="getElFormInstance" :model="modelValue" v-bind="$attrs">
    <!-- 行 ------------------------------------------------------------------------------------ -->
    <el-form-item
      v-for="(row, rowIndex) in formInfo"
      :key="'label' in row ? row.label : row.id"
      v-bind="row.rowElFormItemBind ?? {}"
      :label="'label' in row ? row.label : ''"
      :required="row.ruleRequiredTag"
    >
      <Component
        :is="row.isSpace ? ElSpace : template"
        v-bind="row.isSpace && row.elSpaceBind ? row.elSpaceBind : {}"
      >
        <Component
          :is="row.isSpace ? template : ElCol"
          v-for="(col, colIndex) in row.items"
          :key="'prop' in col ? col.prop : col.id"
          v-bind="col.elColBind ?? {}"
          :span="col.span ?? 24 / row.items.length"
          :class="col.elColClass"
          :style="col.elColStyle"
        >
          <!-- 列 ------------------------------------------------------------------------------------- -->
          <component
            :is="'prop' in col ? ElFormItem : template"
            v-bind="col.colElFormItemBind ?? {}"
            :prop="'prop' in col ? col.prop : undefined"
            :label="col.label"
          >
            <Component
              :is="elComponent[col.type]"
              v-bind="col.bind"
              v-on="
                Object.assign(
                  { click: customButtonEvent[col.type as CustomButtonType] },
                  col.event ? getEvent(rowIndex, colIndex, col) : {}
                )
              "
              :modelValue="'prop' in col ? modelValue[col.prop] : undefined"
              @update:modelValue="
                'prop' in col &&
                  emit('update:modelValue', {
                    ...modelValue,
                    [col.prop]: $event,
                  })
              "
              :props="'props' in col && notElOption[col.type as FormItemNotOptionType] ? col.props : undefined"
              :options="'options' in col && notElOption[col.type as FormItemNotOptionType] ? col.options : undefined"
              :data="'data' in col && notElOptionByData[col.type as FormItemNotOptionByDataType] ? col.data : undefined"
              :class="col.class"
              :style="col.style"
            >
              <!-- 带有 options 的表单 --------------------------------------------------- -->
              <template
                v-if="'options' in col && !notElOption[col.type as FormItemNotOptionType]"
              >
                <Component
                  :is="
                    'options' in col.options[0]
                      ? elOptionGroupComponent[col.type as FormItemOptionGroupType]
                      : template
                  "
                  v-for="group in 'options' in col.options[0]
                    ? col.options
                    : [{ id: 0, options: col.options }]"
                  :key="'id' in group ? group.id : group.label"
                  v-bind="(group as any).bind ?? {}"
                  :label="'label' in group ? group.label : undefined"
                >
                  <Component
                    :is="elOptionComponent[col.type as FormItemOptionType]"
                    v-for="(opt, optIndex) in (group as any).options"
                    :key="opt.value"
                    v-bind="opt.bind ?? {}"
                    v-on="
                      opt.event
                        ? getEvent(rowIndex, colIndex, col, optIndex, opt)
                        : {}
                    "
                    :value="opt.value"
                    :label="opt.label"
                  >
                    <!-- option 插槽 ------------------------------------------------------- -->
                    <template
                      v-for="(slot, name) in opt.slots"
                      :key="name"
                      #[name]="scope"
                    >
                      <FormSlot :slot="slot" :scope="scope" />
                    </template>
                  </Component>
                </Component>
              </template>

              <!-- 表单插槽 ------------------------------------------------------------- -->
              <template
                v-for="(slot, name) in col.slots"
                :key="name"
                #[name]="scope"
              >
                <FormSlot :slot="slot" :scope="scope" />
              </template>
            </Component>

            <!-- 列 el-form-item 插槽 -------------------------------------------------------- -->
            <template
              v-for="(slot, name) in col.colElFormItemSlots"
              :key="name"
              #[name]="scope"
            >
              <FormSlot :slot="slot" :scope="scope" />
            </template>
          </component>
        </Component>
      </Component>

      <!-- 行 el-form-item 插槽 ------------------------------------------------------------- -->
      <template
        v-for="(slot, name) in row.rowElFormItemSlots"
        :key="name"
        #[name]="scope"
      >
        <FormSlot :slot="slot" :scope="scope" />
      </template>
    </el-form-item>
  </el-form>
</template>
```

```
<script setup lang="ts">
// 使用

import { useTemplateRef, ref, reactive, toRef, toRefs, markRaw, h } from "vue";
import CommonForm, {
  useCommonForm,
  addRowItem,
  deleteRowItem,
} from "./components/CommonForm";
import type {
  El,
  CommonFormInfo,
  CommonFormData,
  CommonFormRule,
} from "./components/CommonForm";

// 测试响应式数据
const codeBtnText = ref("获取验证码");
const codeBtnDisabled = ref(false);
const codeBtn = reactive<El["button"]["props"]>({
  type: "primary",
  loading: false,
});

// 测试事件，限制只能是整数
const testInput: El["input"]["emits"]["input"] = (
  { item: { prop } },
  value
) => {
  // 由于设置 input type 为 number 后 maxLength 无效，所以不如直接正则替换，只允许输入数字
  // 如果是 number input ，正则写成限制最大字符数即可
  formData.value[prop] = value.replace(/\D/g, "");
};

// 测试 checkbox 全选
const isIndeterminate = ref(true);

// 测试新增、删除表单，注意当 formRule 修改时默认会触发一次验证，可以设置 validate-on-rule-change="false"
const eduPropId = ref(-1);
const eduCnt = ref(0);

// 根据 formInfo 自动生成 formData 、formRule --------------------------------------------------
const [formInfo, formData, formRule] = useCommonForm([
  // 基本用法
  {
    label: "手机号",
    items: [
      {
        prop: "phone",
        type: "input",
        defaultValue: "123",
        bind: {
          placeholder: "请输入手机号",
          maxlength: 11,
        },
        event: { input: testInput },
        rules: [
          {
            required: true,
            message: "手机号不能为空",
            trigger: "blur",
          },
          {
            pattern: /^(\d{11})$/,
            message: "手机号必须是 11 位数字",
            trigger: "blur",
          },
        ],
      },
    ],
  },

  /**列默认使用 el-col 布局，宽度自适应
   * 通过 span 设置所占空间（）每一列 24 份）
   * 可以用 el-text 作为占位元素
   * 结构：
     <el-form>
       <!-- 行 -->
       <el-form-item label="密码">
         <!-- 列 -->
         <el-col :span="11">
           <el-form-item>
             <el-input />
           </el-form-item>
         </el-col>
         <el-col :span="2">
           <!-- 非 v-model 组件不会有 el-form-item 包裹 -->
           <el-text>-</el-text>
         </el-col>
         <el-col :span="11">
           <el-form-item>
             <el-input />
           </el-form-item>
         </el-col>
       </el-form-item>
     </el-form>
   *
   */
  {
    label: "密码：",
    items: [
      {
        prop: "password",
        type: "input",
        span: 11,
        bind: { type: "password", placeholder: "请输入密码" },
        rules: [
          {
            required: true,
            pattern: /^(?=.*[A-Za-z]).{8,}$/,
            message: "密码必须至少 8 个字符，且必须包含一个字母",
            trigger: "blur",
          },
        ],
      },
      {
        id: "-123dasdas--d",
        type: "text",
        span: 2,
        slots: { default: "-" },
        elColStyle: "text-align:center",
        // elColClass: "text-center",
      },
      {
        prop: "confirmPassword",
        type: "input",
        span: 11,
        bind: { type: "password", placeholder: "确认密码" },
        rules: [
          {
            required: true,
            pattern: /^(?=.*[A-Za-z]).{8,}$/,
            message: "密码必须至少 8 个字符，且必须包含一个字母",
            trigger: "blur",
          },
          {
            validator: (_, value, callback) => {
              if (value !== formData.value["password"]) {
                callback(new Error("两次输入的密码不一致"));
              }

              callback();
            },
            trigger: "blur",
          },
        ],
      },
    ],
  },

  /**该列用 el-space 布局，可以控制左右边距，宽度不会自适应
   * 结构：
    <el-form>
      <!-- 行 -->
      <el-form-item label="验证码">
        <!-- 列 -->
        <el-space>
          <el-form-item>
            <el-input placeholder="设置表单宽度可以撑开 el-form-item" />
          </el-form-item>
          <el-button>非 v-model 组件不会有 el-form-item 包裹</el-button>
        </el-space>
      </el-form-item>
    </el-form>
   */
  // 测试响应式数据、插槽
  {
    label: "验证码",
    isSpace: true,
    items: [
      {
        prop: "code",
        type: "input",
        style: "width: 300px",
        bind: {
          placeholder: "请输入验证码",
        },
        rules: [
          {
            required: true,
            message: "验证码不能为空",
            trigger: "blur",
          },
        ],
      },

      {
        id: "564657896",
        type: "text",
      },

      {
        id: "btn0",
        type: "button",
        style: "width: 100px",

        // 插槽可以传入 string 、VNode（如 h 函数返回值、组件对象） 、render 函数
        // slots: { default: "获取验证码" },
        // slots: { default: h("span", null, "获取验证码") },
        // slots: { default: () => "获取验证码" },
        slots: { default: codeBtnText },

        // 测试传入响应式数据
        // bind: codeBtn,
        bind: {
          ...toRefs(codeBtn),
          type: toRef(codeBtn, "type"),
          disabled: codeBtnDisabled,
        },

        event: {
          click: (data, e) => {
            // console.log(e);

            const { rowIndex, colIndex, item } = data;

            // 方式一
            // item.slots!.default = "已发送";

            // 方式二
            // const info = formInfo[rowIndex].items[colIndex] as typeof item;
            // info.slots!.default = "已发送";

            // 方式三
            codeBtnText.value = "已发送";
            codeBtn.type = "";
            codeBtn.loading = true;
            codeBtnDisabled.value = true;
          },
        },
      },
    ],
  },

  /**新增/删除表单，以及测试行布局
   * 行 el-form-item 的 label 会作为 v-for 的 key ，若不需要 label 则必须传入 id
   * label 区若未传入 label ，内容就不会渲染，造成整体左移；若不想这样，则需要传入一个空的 label ，
     但不要直接传入，否则 key 会重复，应该传入剧名插槽 label
  */
  {
    label: "教育背景",
    items: [
      {
        id: "add-edu",
        type: "button",
        span: 24,
        bind: { type: "primary" },
        slots: { default: "添加" },
        event: {
          click: ({ rowIndex }) => {
            addRowItem(
              {
                id: `edu-${++eduPropId.value}`,
                rowElFormItemSlots: { label: "" },
                items: [
                  {
                    prop: `edu-${eduPropId.value}`,
                    type: "input",
                    span: 12,
                    bind: { placeholder: "请输入" },
                    rules: [
                      { required: true, message: "不能为空", trigger: "blur" },
                    ],
                  },
                  {
                    id: `edu-btn-${eduPropId.value}`,
                    type: "button",
                    span: 12,
                    bind: { type: "danger" },
                    slots: { default: "删除" },
                    event: {
                      click: ({ rowIndex }) => {
                        if (
                          deleteRowItem(rowIndex, formInfo, {
                            formData,
                            formRule,
                          })
                        ) {
                          --eduCnt.value;
                        }
                      },
                    },
                  },
                ],
              },

              formInfo,

              {
                insertBeforeIndex: rowIndex + 1 + eduCnt.value++,
                formData,
                formRule,
              }
            );
          },
        },
      },
    ],
  },

  // 数据筛选
  {
    label: "搜索",
    items: [
      {
        prop: "search",
        type: "autocomplete",
        bind: {
          placeholder: "请输入",
          fetchSuggestions: (str, cb) => {
            const list = [{ value: "data1" }, { value: "data2" }];

            const res = str
              ? list.filter(
                  (item) =>
                    item.value.toLowerCase().indexOf(str.toLowerCase()) >= 0
                )
              : list;

            cb(res);
          },
        },
      },
    ],
  },

  // radio 、checkbox ，子项通过 options 传入
  {
    label: "单选",
    items: [
      {
        prop: "sex",
        type: "radio",
        defaultValue: "0",
        options: [
          { value: "0", label: "男" },
          { value: "1", label: "女" },
        ],
      },
    ],
  },
  {
    label: "多选",
    items: [
      {
        prop: "checkbox",
        type: "checkbox",
        options: [
          { value: "0", label: "A" },
          { value: "1", label: "B" },
          { value: "2", label: "C" },
        ],
        event: {
          change: ({ item }, value) => {
            const len = value.length;
            const maxLen = item.options.length;

            formData.value["checkall"] = len === maxLen;
            isIndeterminate.value = len > 0 && len < maxLen;
          },
        },
        rules: [
          {
            type: "array",
            required: true,
            min: 2,
            message: "请至少选择 2 个选项",
            trigger: "change",
          },
        ],
      },
      {
        prop: "checkall",
        type: "check",
        slots: { default: "全选" },
        bind: { indeterminate: isIndeterminate },
        event: {
          change: ({ rowIndex }, value) => {
            const checkbox = formInfo[rowIndex].items[0];
            if (checkbox.type !== "checkbox") return;

            isIndeterminate.value = false;
            formData.value["checkbox"] = value
              ? checkbox.options.map((i) => i.value)
              : [];
          },
        },
      },
    ],
  },

  // select ，子项通过 options 传入
  {
    label: "select",
    items: [
      {
        prop: "prop-select",
        type: "select",
        bind: { placeholder: "请选择" },
        options: [
          { value: "0", label: "A" },
          { value: "1", label: "B" },
        ],
      },

      {
        prop: "prop-sg",
        type: "select",
        bind: { placeholder: "请按分组选择", multiple: true },
        options: [
          {
            label: "分组1",
            options: [
              { value: "0-0", label: "0-A" },
              { value: "0-1", label: "0-B" },
            ],
            // bind: { disabled: true },
          },
          {
            label: "分组2",
            options: [
              { value: "1-0", label: "1-A" },
              { value: "1-1", label: "1-B" },
            ],
          },
        ],
      },
    ],
  },
  {
    label: "select-v2",
    items: [
      {
        prop: "select-v2",
        type: "select-v2",
        bind: { placeholder: "请选择" },
        props: { disabled: "d" },

        options: [
          { value: "0", label: "A", d: true },
          { value: "1", label: "B" },
        ],
        slots: { default: (scope) => "option: " + scope?.item?.label },
      },

      {
        prop: "prop-sgv2",
        type: "select-v2",
        bind: { placeholder: "请多选", multiple: true },
        options: [
          {
            label: "分组1",
            options: [
              { value: "0-0", label: "0-A" },
              { value: "0-1", label: "0-B" },
            ],
          },
          {
            label: "分组2",
            options: [
              { value: "1-0", label: "1-A" },
              { value: "1-1", label: "1-B" },
            ],
          },
        ],
      },
    ],
  },
  {
    label: "艾特",
    items: [
      {
        prop: "@",
        type: "mention",
        bind: { type: "textarea", placeholder: "请输入" },
        options: [
          { value: "张三", label: "张三" },
          { value: "李四", label: "李四" },
        ],
      },
    ],
  },

  // 级联选择，子项通过 options 传入
  {
    label: "级联",
    items: [
      {
        prop: "prop-cascader",
        type: "cascader",
        bind: { placeholder: "请选择" },
        props: { expandTrigger: "hover", multiple: true },
        options: [
          {
            value: "0",
            label: "A",
            children: [{ value: "0-0", label: "A-a" }],
          },
          {
            value: "1",
            label: "B",
            children: [
              {
                value: "1-0",
                label: "B-a",
                children: [{ value: "1-0-0", label: "B-a-a" }],
              },
              { value: "1-1", label: "B-b" },
            ],
          },
        ],
      },
    ],
  },
  {
    label: "级联面板",
    items: [
      {
        prop: "prop-cascader-panel",
        type: "cascader-panel",
        options: [
          {
            value: "0",
            label: "A",
            children: [{ value: "0-0", label: "A-a" }],
          },
          {
            value: "1",
            label: "B",
            children: [
              { value: "1-0", label: "B-a" },
              { value: "1-1", label: "B-b" },
            ],
          },
        ],
      },
    ],
  },

  // 子项通过 data 传入（类似 options）
  {
    label: "树形 select",
    items: [
      {
        prop: "prop-treeselect",
        type: "tree-select",
        data: [
          {
            value: "0",
            label: "A",

            children: [
              { value: "0-0", label: "A-a" },
              { value: "0-1", label: "A-b" },
            ],
          },
          {
            value: "1",
            label: "B",

            children: [
              { value: "1-0", label: "B-a" },
              { value: "1-1", label: "B-b" },
            ],
          },
        ],
      },
    ],
  },
  {
    label: "穿梭框",
    items: [
      {
        prop: "prop-transfer",
        type: "transfer",
        data: [
          { key: "0", label: "A" },
          { key: "1", label: "B" },
          { key: "2", label: "C" },
          { key: "3", label: "D" },
          { key: "4", label: "E" },
        ],
      },
    ],
  },

  // 颜色、时间
  {
    label: "颜色",
    items: [
      {
        prop: "prop-color",
        type: "color-picker",
      },
    ],
  },
  {
    label: "时间",
    items: [
      {
        prop: "date1",
        type: "date-picker",
        bind: { placeholder: "请选择日期" },
      },
      {
        prop: "date2",
        type: "time-picker",
        bind: { placeholder: "请选择时间" },
      },
      {
        prop: "date3",
        type: "time-select",
        bind: { placeholder: "请选择时间" },
      },
    ],
  },
  {
    label: "panel",
    items: [
      {
        prop: "prop-color-p",
        type: "color-picker-panel",
      },

      {
        prop: "prop-date-p",
        type: "date-picker-panel",
      },
    ],
  },

  // 其他
  {
    label: "其他",
    items: [
      {
        prop: "prop-rate",
        type: "rate",
      },
      {
        prop: "prop-slide",
        type: "slide",
        bind: { showInput: true },
      },
      {
        prop: "prop-switch",
        type: "switch",
      },
    ],
  },
  {
    label: "其他 input",
    items: [
      {
        label: "input-tag",
        prop: "prop-inp-tag",
        type: "input-tag",
        bind: { placeholder: "请输入" },
      },
      {
        label: "input-number",
        prop: "prop-inp-num",
        type: "input-number",
      },
    ],
  },

  // 单个 checkbox，boolean 类型的表单只能用自定义校验规则
  {
    label: "协议",
    ruleRequiredTag: true,
    items: [
      {
        prop: "agree",
        type: "check",
        slots: {
          default: h("span", null, [
            "我同意 ",
            h("a", { href: "#" }, "《用户协议》"),
          ]),
        },
        rules: [
          {
            validator: (_, value, callback) => {
              if (!formData.value["agree"]) callback(new Error("请勾选协议"));
              callback();
            },
            trigger: "change",
          },
        ],
      },
    ],
  },

  // reset 、clear 、submit 默认就有完整功能，也可以绑定 click 事件扩展功能，记得调用 callback 就行（submit 是异步的）
  {
    id: "footer",
    isSpace: true,
    elSpaceBind: { size: 20 },
    rowElFormItemSlots: { label: "" },
    items: [
      {
        id: "reset",
        type: "reset",
        slots: { default: "重置" },
        // event: {
        //   click: ({ callback }, e) => {
        //     callback();
        //     console.log("reset");
        //   },
        // },
      },

      {
        id: "clear",
        type: "clear",
        slots: { default: "清空" },
        // event: {
        //   click: ({ callback }, e) => {
        //     callback();
        //     console.log("clear");
        //   },
        // },
      },

      {
        id: "submit",
        type: "submit",
        bind: { type: "primary" },
        slots: { default: "提交" },
        // event: {
        //   click: ({ callback }, e) => {
        //     console.log("开始验证...");
        //     callback()
        //       .then(() => console.log("验证成功"))
        //       .catch((failedObj) => console.log("验证失败，信息：", failedObj));
        //   },
        // },
      },
    ],
  },
]);

// 也可以手写，就不用便利 formInfo 了，提高一些性能 ---------------------------------------------
// 表单验证中，行的 label required 星号需要自己配置，若是自定义规则，则列的 label required 星号也要配置
// const info = [
//   {
//     label: "账号",
//     ruleRequiredTag: true,
//     items: [
//       {
//         label: "item1",
//         prop: "username",
//         type: "input",
//         // ruleRequiredTag: true,
//         bind: { placeholder: "请输入" },
//       },
//     ],
//   },
// ] as const satisfies CommonFormInfo;
// const formInfo = reactive(info);
// const formData = ref<CommonFormData<typeof info>>({
//   username: "",
// });
// const formRule = reactive<CommonFormRule<typeof info>>({
//   username: [{ required: true, message: "不能为空", trigger: "blur" }],
//   // username: [
//   //   {
//   //     validator: (_, value, callback) => {
//   //       if (!value) callback(new Error("不能为空"));
//   //       callback();
//   //     },
//   //     trigger: "blur",
//   //   },
//   // ],
// });

// 放入 dialog 测试 -----------------------------------------------------------------
const isShow = ref(false);
const form = useTemplateRef("formRef");

const dialogCancel = () => {
  isShow.value = false;
  form.value!.reset();
};

const dialogClose = (done: () => void) => {
  done();
  dialogCancel();
};

const dialogSubmit = async () => {
  try {
    await form.value!.submit();
    isShow.value = false;
    form.value!.reset();
  } catch (failedObj) {
    // console.log(failedObj);
  }
};
</script>

<template>
  <el-button type="primary" @click="isShow = true">+ 新增</el-button>

  <el-dialog
    v-model="isShow"
    title="个人信息"
    width="800"
    :before-close="dialogClose"
  >
    <CommonForm
      class="common-form"
      ref="formRef"
      v-model="formData"
      :form-info="formInfo"
      :rules="formRule"
      :validate-on-rule-change="false"
      scroll-to-error
      status-icon
      label-width="auto"
      label-suffix=":"
    />

    <template #footer>
      <el-button @click="dialogCancel">cancel</el-button>
      <el-button type="primary" @click="dialogSubmit">submit</el-button>
    </template>
  </el-dialog>
</template>

<style scoped lang="less">
// 测试 class
.common-form {
  :deep(.text-center) {
    text-align: center;
  }
}
</style>
```

## 4 生态

### 4.1 Vue Router

（1）基本

传统的多页面应用，有多个 html 文件，浏览器通过对应的 url 访问服务器中各个 html 资源；但 SPA 只有一个页面，就要解决 4 个问题：

- SPA 展示多个页面组件，把 url 变成响应式数据，通过监听 hashchange 事件（hash 模式）或 popstate 事件（history 模式）处理响应式的 url ，router-view 再通过 url 展示对应的组件

- SPA 在修改 url 时不应该刷新页面，因为都是同一个 html ，同时服务器中对应的 url 也没有对应的资源：
  
  - 可以使用 hash 模式，"#hash" 修改不会刷新页面，url 也不会带上 hash 区访问服务器
  
  - 若不想使用 hash 的 '\#' ，让 url 更美观，可以用 history 模式，但是这样修改 url 就会刷新页面，vue-router 底层已经用 historyAPI 解决（history\.pushState 、history\.replaceState）；
    
    整个 url 会访问服务器，但没有对应的资源，所以服务器也需要处理一下
  
  - router 也提供编程式导航、声明式导航，使得跳转不刷新页面（原生 a 标签跳转默认行为会刷新页面），提供两种跳转方式：
    
    * push ：保留历史记录，可以返回
    
    * replace ：不保留历史记录，无法返回

- SPA 初始化会加载所有要展示的组件，这时候可以用路由懒加载，实现和传统多页面类似的效果，访问对应资源时才加载

- SPA 用 JS 生成内容，不利于 SEO ，可以用 SSR 解决

（2）模式

* hash ：url 带有 "\#" ，后面为哈希值，哈希值变化页面不会刷新，也不会携带给服务器，兼容性最好，因此不需要额外处理

* history ：url 没有 “\#” ，更美观，但也因此 url 变化会刷新页面，Vue Router 底层通过 HTML5 的 history API 解决，实现不刷新，因此兼容性差一些；
  
  也因此整个 url 都会携带给服务器，初始访问 index\.html 以及后续跳转用 JS 处理都没问题，但是一旦刷新页面，服务器 url' 找不到对应的资源，就会 404 ，解决方案是 nginx 中配置始终访问 index\.html

* memory ：用于非浏览器环境（没有 BOM），如小程序、app 、桌面应用，这种模式会把 url 存入到内存中的一个不可见对象中，再处理这个对象；
  
  若用于浏览器环境，是不会修改地址栏的 url 的，只处理内存中的 url ，所以浏览器刷新会回到首页，因此不要再浏览器环境使用 memory 模式

（3）使用

Vue2 、Vue3 区别：

* Vue2 使用 VueRouter3 ，Vue3 使用 VueRouter4

* 创建路由的方式不同：Vue2 使用 VueRouter 构造函数，需要 use 且挂载到 Vue 实例，Vue3 使用 createRouter 工厂函数，直接 use 就行

* 模式配置不同：Vue2 用 mode 配置 string 且可以省略，默认为 hash ，Vue3 必须配置 history 选项：
  
  ```
  {
    // Vue2
    mode: "hash",
    // Vue3，需要导入
    history: createWebHashHistory()
  }
  ```

* router\-view 使用 transition 、keep\-alive 时 ，Vue2 和普通组件使用方式一样，Vue3 则需要放在 router\-view 的默认插槽中

* router\-link 删除属性 tag ，完全可以用插槽替代，Vue2 也支持；删除属性 event ，改为 custom ，更好的配合插槽控制跳转行为

* 组件内获取路由实例的方式不同：Vue2 用 this 获取，Vue3 用 hook 获取

* 导航守卫：
  
  * Vue3 守卫都支持 return 代替 next ，此时不允许回调函数传入 next 参数
  
  * Vue3 的组件内守卫只支持 Options API 。但新增 2 个组件内守卫钩子 onBeforeRouteUpdate 、onBeforeRouteLeave

* Vue3 修复了 Vue2 路由跳转的 2 个 bug ：
  
  - 当跳转的路由就是当前路由时，不再有 warn
  
  - next 不再有 warn

Vue2 ：

```
// /src/router/index.js

import VueRouter from "vue-router";

import Home from "../views/Home/index.vue";
const About = () => import("../views/About/index.vue");

const routes = [
  {
    path: "/",
    component: Home,
  },

  {
    path: "/about",
    component: About,
  },
];

const router = new VueRouter({
  routes,
  base: "/",
});

export default router;
```

```
// /src/main.js

import Vue from "vue";
import App from "./App.vue";
import VueRouter from "vue-router";
import router from "./router";

Vue.config.productionTip = false;

Vue.use(VueRouter);

new Vue({
  router,
  render: (h) => h(App),
}).$mount("#app");
```

```
<script>
// /src/App.vue
export default {};
</script>

<template>
  <keep-alive>
    <router-view></router-view>
  </keep-alive>
</template>
```

Vue3 ：

```
// /src/router/index.ts

import { createRouter, createWebHistory } from "vue-router";
import type { RouteRecordRaw, RouterScrollBehavior } from "vue-router";

// 同步导入
import Home from "@/views/Home/index.vue";

// 路由懒加载，分包
const About = () => import("@/views/About/index.vue");
const AboutA = () => import("@/views/About/children/AboutA/index.vue");
const AboutB = () => import("@/views/About/children/AboutB/index.vue");
const Profile = () => import("@/views/Profile/index.vue");
const NotFound = () => import("@/views/NotFound/index.vue");

/**路由配置 -------------------------------------------------------------------------------
 * path 、component / components / redirect 是必选参数，其他都是可选参数
 * alias：path 的别名数组，注意不是 name 的别名
 * name：路由 name
 * meta：路由原信息，保存在路由对象中
 */
const routes: RouteRecordRaw[] = [
  {
    // 默认路由，"" 或 "/" ，也可以直接配置一条 { path: "/", component: Home }
    path: "/",
    redirect: "/home",
  },

  {
    path: "/home",
    component: Home,
    meta: { msg: "meta" },

    // 命名试图，<router-view> 默认渲染 default 组件，也可以 <router-view name="xxx"> 渲染对应组件
    // components: {
    //   default: Home,
    //   xxx: Home,
    // },
  },

  {
    path: "/about",
    alias: ["/aboutalias"],
    component: About,
    meta: { msg: "hello" },

    // 若需要用父路由 name 跳转，且显示默认路由，则需要这里也设置 redirect
    // name: "about",
    // redirect: "/about/abouta",

    /**嵌套路由
     * About/index.vue 内也需要使用 <router-view>
     * 配置 path 不需要加 "/" 和父路由前缀
     * 路由跳转的 url 如 "/about/" 、 "/about/aboutb"
     */
    children: [
      { path: "", redirect: "about/abouta" },
      { path: "abouta", name: "abouta", component: AboutA },
      { path: "aboutb", name: "aboutb", component: AboutB },
    ],

    // 独享守卫
    beforeEnter(to, from) {
      return;
    },
  },

  {
    // 动态路由，跳转 url 如 "/profile123"
    path: "/profile:id",
    // 可选参数
    // path: "/profile:id?",

    // 可以用 props 传递参数，组件中用 props 配置项接收
    props: { num: 1 },

    name: "profile",
    component: Profile,
  },

  // 匹配路由
  {
    // 正则匹配，正则不需要加 / /
    // path: "/:pathMatch(正则)",

    // 404 路由
    path: "/:catchAll(.*)",

    component: NotFound,
  },
];

//*自定义滚动行为，即路由跳转后滚动到的位置，默认是顶部
const scrollBehavior: RouterScrollBehavior = (to, from, savedPosition) => {
  if (to.hash) {
    return {
      selector: to.hash,
      behavior: "smooth",
      offset: { x: 0, y: 100 },
    };
  } else return { x: 0, y: 0 };
};

// 创建路由，Vue Router 底层监听 propstate 事件实现路由功能
const router = createRouter({
  routes: routes,
  history: createWebHistory(import.meta.env.BASE_URL),
  scrollBehavior,

  // baseURL ，默认为 "/" ，若有打包后项目是在某个子目录的场景，则可以配置 base
  base: "/",
});

/**导航守卫、也叫路由守卫，在路由进入之前、之后回调 -----------------------------------------
 * 全局前置守卫，进入路由之前回调，通常用于权限验证
 * 全局后置守卫：进入路由后回调，常用语修改 title ，延迟跳回原页面等
 * 独享守卫：路由中配置，该路由独享，属于前置手误诶
 * 组件内守卫：组件内部配置
 * 前置守卫内部必须使用 next 才能继续跳转（Vue3 还可以用 return）
 * 执行顺序：全局前置 - 独享 - 组件内 - 全局后置
 */
// 全局前置守卫
router.beforeEach((to, from /*next*/) => {
  // to 、from 都是路由对象
  console.log(`即将从当前 ${from.path} 进入 ${to.path}`);

  // 跳转到 to
  // next();
  // return;
  return true;

  // 不跳转到 to ，而是主动指定
  // next('/login')
  // next({ path: "/login", query: {} });
  // return "/login";
  // return { path: "/login", query: {} };

  // 取消导航
  // return false;

  // 取消导航，并回调 router.onError
  // throw new Error("err");
});
router.onError((err) => {
  console.log(err);
});

// 全局后置守卫
router.afterEach((to, from, next) => {
  // 后置守卫不必须要 next ，但也可以用 next 再次跳转路由
  console.log(`进入路由: ${to.path}`);
});

export default router;
```

```
// /src/main.ts ，use 注入一些全局组件和全局资源
import router from "./router";
app.use(router);
```

```
<script setup lang="ts">
// /src/App.vue，泪痣路由后，进入对应的 url 就会执行对应组件的 script ，但模板需要使用 router-view 才会渲染
</script>

<template>
  <!-- 用于展示路由页面，类似 template 只作包裹作用，所以无法使用 v-show -->
  <!-- <router-view></router-view> -->

  <!-- Vue3 的 router-view 使用 keep-alive、transition
     * 必须用默认插槽 
     * route: 当前路由  Component: 当前路由组件
     * 和缓存组件一样，keep-alive 切换路由不会删除路由组件
     * include、exclude 声明缓存起作用的组件 name ，注意不是路由 name ；默认全部路由组件适用
     * 若父路由缓存了，离开父路由不想缓存某个子组件，可以在父组件中，用响应式数据 v-if 子组件，在 actived、deactived 修改这个数据
  -->
  <router-view #default="{ route, Component }">
    <keep-alive>
      <component :is="Component"></component>
    </keep-alive>
  </router-view>
</template>
```

```
<script setup lang="ts">
// /src/views/Home/index.vue ，获取当前路由、路由跳转、组件内守卫

import {
  useRoute,
  useRouter,
  onBeforeRouteUpdate,
  onBeforeRouteLeave,
} from "vue-router";

// route 是当前路由。router 是整个路由实例
const route = useRoute();
const router = useRouter();

// "/home" "/home" "meta" ，route 和 router.currentRoute 不是同一个对象，但信息相同
console.log(route.path, router.currentRoute.value.path, route.meta.msg);

/**编程式导航，路由跳转是异步任务，所以若有多条跳转语句，则只执行最后一个 --------------------------
 * push：跳转后可以返回
 * replace：跳转后不可以返回
 */
const toProfile = () => {
  // 简写，只能用 path
  // router.push("/profile123?a=msg");

  // 完整写法，可以更方便传参；推荐用 name ，后期更好维护，如改动 path 就不需要改其他代码了
  router.push({
    // path: "/profile123",
    // query: { a: "msg" },

    name: "profile",
    params: { id: 123 },
    query: { a: "msg" },
  });
};

// 组件内守卫，都是前置守卫 ----------------------------------------------------------------
defineOptions({
  beforeRouteEnter(to, from) {
    return;
  },
});

/**params 或 query 改变时回调，用于页面自己跳转自己的场景
 * 注意，仅在参数变化时回调，若 path 都改变了就不会回调
 * 若只有 params 、query 的变化：
   - 不会重新渲染组件，也不会触发独享守卫和其他 2 个组件内守卫，但会触发全局前置、全局后置
   - 因此 VueRouter4 就有了这个钩子，在内部自行处理；在以前只能在全局前置守卫处理
 */
onBeforeRouteUpdate((to, from) => {
  // 方式一，推荐，重新获取数据，不重新渲染组件
  // getData();

  // 方式二，router-view 用响应式数据绑定 key ，key 变化就会重新渲染了
  // <router-view :key="xxx"></router-view>

  // 方式三，不推荐，强制刷新或先跳转中间页面再跳转回来，不符合 SP 不刷新页面的设计

  return;
});

// 离开当前路由之前回调
onBeforeRouteLeave((to, from) => {
  console.log("leave");
  return;
});
</script>

<template>
  <p>home</p>
  <p>{{ typeof $route }}</p>
  <p>{{ typeof $router }}</p>

  <!-- 声明式导航 
     * to ：跳转目标
     * replace ：boolean ，默认为 push 跳转
     * append ：boolean ，若为 true ，则 to 变为在当前 path 后追加，常用语简化跳转嵌套路由
     * active-class 、exact-active-class ：样式 class
     * tag 、event：VueRouter4 已删除，设置渲染的标签和行为，默认为 a 和默认跳转
     * custom ：VueRouter4 新增，boolean ，若为 true ，则自行控制跳转行为
  -->
  <p>
    <router-link to="/about">
      <button>to AboutA</button>
    </router-link>
  </p>
  <p>
    <router-link :to="{ name: 'aboutb' }"> to AboutB </router-link>
  </p>

  <!-- 编程式导航 -->
  <p>
    <button @click="toProfile">to Profile</button>
  </p>

  <!-- 测试 onBeforeRouteUpdate -->
  <p>
    <router-link to="/home?a=1">test</router-link>
  </p>
</template>
```

```
<script setup lang="ts">
// /src/views/About/index.vue
</script>

<template>
  <p>about</p>
  <router-view></router-view>
</template>
```

```
<script setup lang="ts">
// /src/views/Profile/index.vue ，获取路由参数、路由钩子

import { onActivated, onDeactivated } from "vue";
import { useRoute } from "vue-router";

const route = useRoute();

// path + param ，path + param + query
console.log(route.path, route.fullPath);

// 获取参数
console.log(route.params.id, route.query);

// 获取路由配置的 props ，实际上就是组件通信
const props = defineProps<{ num: number }>();
console.log(props.num);

// 路由钩子，仅在 keep-alive 内有效
onActivated(() => {});
onDeactivated(() => {});
</script>

<template>
  <p>profile</p>
</template>
```

（4）动态 CURD 路由

如权限系统中动态添加、删除路由配置，Vue2 、Vue3 用法一样，区别：

* VueRouter4 删除了 addRoutes ，批量 add 需要自己遍历

* VueRouter4 新增 removeRoute ，hasRoute ，在以前，删除或修改路由只能重新 new 一个路由实例，再把新路由实例的 mather 赋值给正在使用的路由实例：
  
  ```
  export function resetRouter(newRoutes = []) {
    const newRouter = new VueRouter({ mode: "history", routes: newRoutes });
    router.matcher = newRouter.matcher;
  }
  ```

VUE3 :

```
// /src/test/ts

import router from "@/router";

const Manager = () => import("@/views/Manager/index.vue");
const ManagerA = () => import("@/views/Manager/children/ManagerA/index.vue");
const Goods = () => import("@/views/Goods/index.vue");

// add
router.addRoute({
  path: "/manager",
  name: "manager",
  component: Manager,
});

// add 嵌套路由
router.addRoute("manager", {
  path: "managera",
  name: "managera",
  component: ManagerA,
});

// 批量 add
const extraRoutes = [
  {
    path: "/goods",
    name: "goods",
    component: Goods,
  },
];
extraRoutes.forEach((route) => router.addRoute(route));

// remove ，嵌套路由会一并删除
// router.removeRoute("manager");

// update ，路由信息是 readonly 的，只能先 remove 再 add
const routeToUpdate = router.getRoutes().find((r) => r.name === "goods");
if (routeToUpdate) {
  router.removeRoute("profile");
  router.addRoute({
    ...routeToUpdate,
    path: "/goods",
  });
}

// 判断路由是否存在
console.log(router.hasRoute("manager"));

// 获取所有路由
console.log(router.getRoutes());
```

### 4.2 Vuex/Pinia

基本；

* 都是响应式的全局状态管理工具，状态即响应式数据，状态挂载到全局，可实现任意组件通信。

* 单一状态树：只允许有一个 store 对象，方便维护。

Vuex 、Pinia 曲边：

* Vue2 、Vue3 都可以使用（Vue3 需要 Vuex4 版本），Vue3 推荐使用 Pinia ，ts 支持更好

* Vuex 需要通过 mutations 修改状态 ，这样 VueDevTool 才能监测到；Pinia 可以直接修改状态，VueDevTool 也能监测到，因此没有 mutations 配置

* Vuex 的模块需要配置 modules ，较复杂；Pinia 直接通过函数创建模块，更清晰，因此没有 modules 配置

* 在组件使用时，Pinia 比 Vuex 更简便，也不需要 map 语法

（1）Vuex

使用：

```
// /src/store/index.js

import Vue from "vue";
import Vuex from "vuex";

// 必须在 new Vuex.Store 之前 use ，使得 vue 可以使用 $store
Vue.use(Vuex);

// 为了方便维护，也会把 state 等抽离成 js 文件，modules 抽离成文件夹
const store = new Vuex.Store({
  state: {
    count: 0,
  },

  getters: {
    doubleCount(state, getters, rootState, rootGetters) {
      return state.count * 2;
    },
  },

  /**mutations
   * 为了让 VueDevTools 能够监控到修改，任何地方对 state 的修改都必须使用 mutations
   * mutations 只能处理同步任务，异步监听不到；且逻辑应该尽量简单
   * 通过数组下标修改、对象增加、删除属性，也需要使用 Vue.$set() Vue.$delete
   * mutations 中使用别的 js 文件 export const xxx 的类型常量，需要如此使用 [xxx]
   */
  mutations: {
    setCount(state, payload = { value: 0 }) {
      console.log(payload.type);
      state.count = payload.value;
    },
  },

  /**actions
   * 同步、异步任务均可，适合对 state 做较为复杂修改
   * 内部也需要通过 mutations 修改 state
   */
  actions: {
    asyncSetCount(context, payload) {
      console.log(payload.type);

      return new Promise((resolve) => {
        // mutations 修改
        setTimeout(() => {
          context.commit({
            type: "setCount",
            value: payload.value,
          });

          resolve();
        }, 1000);
      });
    },
  },

  /**子modules
   * state 可以和 root 重复，会独立保存到 roor.moduleA 中；getters 不行，因为会挂到 root 中
   * mutations 、actions 可以重复，也会挂到 root ，这种情况会全部执行，所以最好避免重名
   * 形参中的state 、context、getters 都是本模块的
   */
  modules: {
    moduleA: {
      /**命名空间，默认 false
       * true 后子模块的getters 、mmutations 、actions 都加上了 "moduleA/" 前缀
       * true 后才能正常使用 map 语法
       */
      // namespaced: true,

      // 子模块需要函数返回独立的 state ，防止冲突；root 的 state 不用
      state() {
        return { count: 10 };
      },

      getters: {
        moduleADoubleCount: (state) => state.count * 2,
      },

      mutations: {
        moduleASetCount: (state) => (state.count = Math.random() * 100),
      },

      actions: {
        moduleAAsyncSetCount(context) {
          return new Promise((resolve) => {
            context.commit("moduleASetCount");
            setTimeout(() => {
              resolve();
            }, 100);
          });
        },
      },
    },
  },
});

// mutations 执行完后回调
store.subscribe((mutation, state) => {
  console.log(`emit ${mutation.type}`);
});

export default store;
```

```
// /src/main.js

import store from "./store";

new Vue({
  store,
})
```

```
<script>
// mapXxx 返回一个队 store 的映射对象，使用更方便
import { mapState, mapGetters, mapMutations, mapActions } from "vuex";

export default {
  computed: {
    // 起别名
    ...mapState({
      cnt: "count",
    }),

    // 不起别名
    ...mapGetters(["doubleCount"]),
    ...mapState("moduleA", ["count"]),
    ...mapGetters("moduleA", ["moduleADoubleCount"]),
  },

  methods: {
    ...mapMutations("moduleA", ["moduleASetCount"]),
    ...mapActions("moduleA", ["moduleAAsyncSetCount"]),

    // 测试未设置 namespaced
    testNoNamespaced() {
      // state
      console.log(
        this.$store.state.count,
        this.$store.state.moduleA.count,
        this.$store.getters.doubleCount,
        this.$store.getters.moduleADoubleCount
      );

      // mutations 修改状态
      this.$store.commit({
        type: "setCount",
        value: this.$store.state.count + 1,
      });

      this.$store.commit("moduleASetCount");
      console.log(this.$store.state.moduleA.count);

      // 异步修改状态
      this.$store
        .dispatch({
          type: "asyncSetCount",
          value: this.$store.state.count + 1,
        })
        .then(() => {});

      this.$store.dispatch("moduleAAsyncSetCount").then(() => {
        console.log(this.$store.state.moduleA.count);
      });
    },

    // 测试命名空间，子模块的getters 、mmutations 、actions 都加上了 "moduleA/" 前缀
    testNamaspaced() {
      console.log(
        this.cnt,
        this.count,
        this.doubleCount,
        this.moduleADoubleCount,
        this.$store.getters["moduleA/moduleADoubleCount"]
      );

      this.$store.commit("moduleA/moduleASetCount");
      this.$store.dispatch("moduleA/moduleAAsyncSetCount");
    },
  },

  created() {
    this.testNoNamespaced();
    // this.testNamaspaced();
  },
};
</script>

<template>
  <div>
    <p>{{ $store.state.count }}</p>
    <p>{{ $store.state.moduleA.count }}</p>
  </div>
</template>
```

持久化存储：

```
pnpm add vuex-persistedstate
```

```
// /src/store/index.js

import Vue from "vue";
import Vuex from "vuex";
import createPersistedstate from "vuex-persistedstate";

Vue.use(Vuex);

const store = new Vuex.Store({
  // state: { count: 0 },
  state() {
    return { count: 0 };
  },
  mutations: {
    add: (state) => (state.count = state.count + 1),
  },

  plugins: [
    // 默认 key 为 "vuex",使用 localStorage ，持久化所有 state 的状态
    // createPersistedstate(),

    // 自定义
    createPersistedstate({
      key: "vuexx",
      storage: window.localStorage,
    }),
  ],
});

export default store;
```

（2）Pinia

使用：

```
// /src/stores/counter.ts

import { ref, computed } from "vue";
import { defineStore } from "pinia";

// Composition API
export const useCounterStoreA = defineStore("counterA", () => {
  const count = ref(0);
  const doubleCount = computed(() => count.value * 2);
  const add = () => ++count.value;

  return { count, doubleCount, add };
});

// Options API
export const useCounterStoreB = defineStore("counterB", {
  // 为了防止冲突，每次都用函数返回一个独立的 state
  state() {
    return { count: 0 };
  },

  getters: {
    // store 为当前仓库
    doubleCount(store): number {
      // 无法从 this 中类型推断 count ，所以需要手动标注返回类型
      return this.count * 2;
    },
  },

  actions: {
    add() {
      ++this.count;
    },
  },
});
```

```
// /src/main.ts
import { createPinia } from "pinia";
app.use(createPinia());
```

```
<script setup lang="ts">
import { storeToRefs } from "pinia";
import { useCounterStoreA, useCounterStoreB } from "@/stores/counter";

const s1 = useCounterStoreA();
const s2 = useCounterStoreB();

// 修改任何 state 后回调
s1.$subscribe((arg, state) => {});

// 每次触发 actions 回调
s1.$onAction((arg) => {});

//

// 使用，已经和 store 的数据关联起来了，所以 ref 、computed 才不需要 .value -----------------------
// 0 0 ，
console.log(s1.count, s2.count);

// 修改状态
++s1.count;
s1.add();

// 多状态的修改推荐使用 patch ，性能高一点
s1.$patch({ count: s1.count + 1 });

// 多数据的复杂修改
s1.$patch((state) => {
  ++state.count;
});

// 解决解构丢失响应式问题，类似 toRefs ，所以使用需要 .value
const { count } = storeToRefs(s1);
++count.value;

// 10
console.log(s1.doubleCount);
</script>

<template>
  <p>{{ s1.count }}</p>
</template>
```

持久化存储，将 state 保存到 Web Storage 中，自己操作比较繁琐，可以使用 Pinia 插件：

```
pnpm add pinia-plugin-persistedstate
```

```
// /src/main.ts
import piniaPluginPersistedstate from "pinia-plugin-persistedstate";
app.use(createPinia().use(piniaPluginPersistedstate));
```

```
// /src/stores/counter.ts

import { defineStore } from "pinia";

// Composition API
export const useCounterStoreA = defineStore(
  "counterA",
  () => {},

  {
    // 默认 key 为 storeName 即 counterA ，使用 localStorage ，持久化所有 state
    // persist: true,

    // 自定义
    persist: {
      key: "counterAA",
      storage: window.localStorage,
    },
  }
);

// Options API
export const useCounterStoreB = defineStore("counterB", {
  // persist: true,

  persist: {
    key: "counterBB",
    storage: window.localStorage,
  },
});
```

自定义 Pinia 插件：

```
import { toRaw } from "vue";
import type { PiniaPluginContext } from "pinia";

interface MyPluginOptions {
  key?: string;
}

// 不需要参数的写法
// const myPluginTest = (context: PiniaPluginContext) => {};

// 需要参数
export const myPlugin = (options: MyPluginOptions) => {
  return (context: PiniaPluginContext) => {
    const { store } = context;

    // 每次 state 修改都会回调
    store.$subscribe(() => {
      localStorage.setItem(
        options?.key ?? store.$id,
        JSON.stringify(toRaw(store.$state)),
      );
    });

    const data = JSON.parse(
      localStorage.getItem(options?.key ?? store.$id) ?? "{}",
    );

    return { ...data };
  };
};

// pinia.use(myPlugin);

// pinia.use(
//   myPlugin({
//     key: "xxx",
//   }),
// );
```

## 5 Vue 原理

Angular 使用 MVC 模式，而 Vue、React 使用 MVVM 模式：

- Model：模型、即 data、methods、生命周期等

- View：视图，即 render 出的页面

- View Model：视图模型，即 Vue 实例，包含 data binding 和 DOM listeners ，通过 Model 数据驱动 View 的显示和更新

### 5.1 响应式

响应式，即数据修改，依赖该数据的 effect 函数（Vue2 叫 watcher）重新执行：

* effect 只有 4 种：render 、computed 、watch 以及 Vue3 的 watchEffect

核心：

* 建立数据和函数之间的联系，即需要拦截 getter 、setter ，JS 中只有 Object\.defineProperty 和 Proxy 可以实现，且都只能用于对象

* 需要考虑 effect 嵌套，所以需要栈保存响应式数据 get 期间运行的 effect，Vue 中只有两种情况：
  
  * render 嵌套 render ：即组件嵌套，响应式数据只 track 最近的 effect 即栈顶的 effect ，所以这种情况是否使用栈并无影响
  
  * computed 被任意 effect 嵌套：computed 依赖的响应式数据 track 栈顶 effect ，然后 pop ，由于 computed 本身也是响应式数据，也需要 track ，即 prop 后的栈顶 effect

#### 5.1.1 Vue2 响应式

Vue2，使用 Object\.defineProperty监听 data 对象实现：

* 先用 Object\.defineProperty 把 data 第一层代理到 this ，方便以后直接用 this 访问数据，不需要递归

* 再用 Object\.defineProperty 递归对每一个属性设置 get、set ，每个属性维护一个 Dep 对象、Dep 对象用发布\-订阅模式进行依赖收集、派发更新，每隔一依赖是一个 Watcher 对象，每一个 Watcher 对象封装有响应式的函数
  
  * 依赖收集：响应式的函数不直接执行，而是交给 Watcher 处理，Watcher 先把函数挂到全局可获取的位置（如 Dep 静态属性），再执行函数，执行函数触发函数内响应式数据的 get ，get 中即可获取挂到全局位置中的依赖
  
  * 派发更新：
    
    * 会用调度器处理，调度器会把多次重复的更新过滤掉，只保留一个更新，类似防抖，同时会把更新放到异步队列中。所以在 Vue 开发中才需要 nextTick 、updated 拿到最新 DOM
    
    * 只有数据变化，才会派发更新，引用类型则判断引用是否变化；在实际开发中若需要提高性能，则需要保证数据引用稳定，如：
      
      ```
      <script setup lang="ts">
      // 子组件
      
      import { onUpdated } from "vue";
      
      defineProps<{ info: { num: number } }>();
      
      onUpdated(() => console.log("updated"));
      </script>
      
      <template>
        <p>{{ info.num }}</p>
      </template>
      ```
      
      ```
      <script setup lang="ts">
      // 父组件，模拟评论区
      
      import { ref } from "vue";
      import Cpn from "./Cpn.vue";
      
      const list = ref([{ num: 1 }, { num: 2 }]);
      
      function addItem() {
        const item = { num: Math.ceil(Math.random() * 100) };
      
        // 常用做法，优点是性能高，缺点是无法获得实时数据
        list.value.push(item);
      
        // 模拟 ajax，每个 item 改为新引用，即使数据没变，子组件也会重新渲染，但可以保证每次都是最新的数据
        // const newList = list.value.map((i) => ({ num: i.num }));
        // newList.push(item);
        // list.value = newList;
      }
      </script>
      
      <template>
        <button @click="addItem">add</button>
        <Cpn v-for="(i, iIndex) in list" :info="i" :key="iIndex" />
      </template>
      ```

* Object\.defineProperty 只能拦截 value 的访问和修改，无法拦截属性的增加、删除；Set、Map 等操作也无法拦截；数组下标虽然也可以拦截，但是一旦数组长度发生变化，下标和响应式的对应关系就会d打乱，push 等方法也无法拦截。
  
  * 每个引用类型的 value 增加一个 "\_\_ob\_\_" 的 key ，value 为 Observer 对象，里面维护一个 Dep 对象，这样只需要自己实现 \$set、\$delete 函数派发更新即可
  
  * 数组的 push 等函数，在 Array 原型链中插入一个自定义原型，里面重写这些函数，并派发更新

* 不同 watcher 的处理
  
  * watch 只需要 get 以下 watch 的数据即可，所以默认 watch 第一次不会执行；而 render、computed、watchEffect 里有多个响应式数据，所以必须在第一次执行一次才能收集到依赖
  
  * computed 是惰性（lazy）的，只有在用到时才进行依赖收集；只有 computed 依赖的数据修改了，computed 变为脏数据（dirty），computed 才会重新执行，数据没修改则使用缓存 value

实现：

```
// type ------------------------------------------------------------------------------------
interface Options {
  [key: string]: any;
}

interface VueOptions {
  el: string;
  data?: Options;
  watch?: { [key: string]: Function };
  computed?: { [key: string]: Function };
  render?: Function;
}

interface WatcherOptions {
  lazy?: boolean;
}
// --------------------------------------------------------------------------------------------

// tool ----------------------------------------------------------------------------------------
// 判断是否为引用类型，为了简单目前只处理 Object 和 Array
const isPointer = (data: any): boolean => {
  return ["[object Object]", "[object Array]"].includes(
    Object.prototype.toString.call(data)
  );
};

// 响应式处理
const defineReactive = (target: Options, key: string) => {
  // 闭包数据
  let value = target[key];
  const dep = new Dep();

  // 递归
  let childOb = observe(value);

  Object.defineProperty(target, key, {
    get: () => {
      dep.depend();
      (childOb as Observer)?.dep?.depend();
      return value;
    },

    set: (newValue) => {
      value = newValue;
      // 如果 newValue 时引用类型，则需要 observe
      childOb = observe(value);

      // 派发更新
      dep.noticy();
      (childOb as Observer)?.dep?.noticy();
    },
  });
};

// Vue 源码会根据环境是否支持，选择使用微任务、宏任务，这里为了方便直接用微任务
const nextTick = (callback: Function): void => {
  Promise.resolve().then(() => callback());
};

// 响应式处理的入口
const observe = (data: unknown): Observer | void => {
  if (!isPointer(data)) return;
  return data!["__ob__"] ?? new Observer(data as Options);
};

/*数组响应式*
 * Object.defineProperty 可以定义数组下标的 get、set ，但是一旦数组长度改变，下标和响应式的关系就会改变
 * 所以数组下标响应式用 Vue.$set() 实现，同 "__ob__" 的 dep 派发更新
 * push 等方法用自定义原型实现，在里面重写方法，同 "__ob__" 的 dep 派发更新
 */
const observeArray = (arr: Array<any>): void => {
  for (const value of arr) observe(value);
};

// 自定义要插入 Array 原型链中间的原型
const ArrayMethods = (() => {
  const result = Object.create(Array.prototype);

  const methods = [
    "push",
    "pop",
    "shift",
    "unshift",
    "splice",
    "sort",
    "reverse",
  ];

  for (const methodName of methods) {
    result[methodName] = function () {
      console.log(methodName);

      let inserted = Array.from(arguments);
      switch (methodName) {
        case "push":
        case "unshift":
          observeArray(inserted);
          break;
        case "splice":
          for (let i = 2; i < inserted.length; i++) observe(inserted[i]);
          break;
        default:
          break;
      }

      const arrRes = Array.prototype[methodName].apply(this, inserted);
      this["__ob__"].dep.noticy();

      return arrRes;
    };
  }

  return result;
})();
// --------------------------------------------------------------------------------------------

// class -----------------------------------------------------------------------------------------
/**
 * 每一个 watcher 就是一个依赖，有 watch、computed、render、watchEffect
 * computed 是惰性的，只有调用时才会计算；computed 会缓存
 * computed 会用在其他 computed、或 render、watch、watchEffect，所以需要创建 Dep、Watcher 多对多
   的关系，Dep 收集到 computed 的各个 Watcher 后，这些 Watcher 再让这些 Dep 区收集其他 Watcher
 */
let watcherId = 0;
class Watcher {
  public static asyncWatcherIds = new Set();

  // 有这个 watcher 的 Dep
  public deps: Set<Dep> | null = null;

  public value: any;
  public lazy: boolean;
  public dirty: boolean;

  private id: number;
  private vm: Vue;
  private exp: string | Function;
  private callback: Function;
  private getter: Function;

  constructor(
    vm: Vue,
    exp: string | Function,
    callback?: Function,
    options: WatcherOptions = {}
  ) {
    this.deps = new Set();

    this.id = watcherId++;
    this.vm = vm;
    this.exp = exp;

    this.getter = typeof exp === "string" ? this.parseExp(vm, exp) : exp;
    this.callback = typeof exp === "string" ? callback : exp;

    this.dirty = this.lazy = !!options.lazy;

    // computed 是 lazy 的
    if (!this.lazy) this.get();
  }

  // 收集 Dep，在 Dep 类中调用
  public addDep(dep: Dep) {
    this.deps.add(dep);
    dep.addSub(this);
  }

  // 如 watch "person.name"
  private parseExp(obj: Vue, exp: string) {
    const childs = exp.split(".");

    return () => {
      let value: any = obj;

      for (const key of childs) {
        try {
          value = value[key];
        } catch {
          throw new Error(`不能从 undefined 访问 ${key}`);
        }
      }
      return value;
    };
  }

  public get() {
    Dep.target = this;
    Dep.targetStack.push(this);

    this.value = this.getter.call(this.vm);

    Dep.targetStack.pop();
    Dep.target =
      Dep.targetStack.length > 0
        ? Dep.targetStack[Dep.targetStack.length - 1]
        : null;
  }

  /**异步更新
   * 用 nextTick 变成异步任务
   * 若有多次更新，则只执行一次即可
   */
  private run() {
    if (!Watcher.asyncWatcherIds.has(this.id)) {
      Watcher.asyncWatcherIds.add(this.id);
      nextTick(() => {
        this.get();
        this.callback.call(this.vm);
        Watcher.asyncWatcherIds.delete(this.id);
      });
    }
  }

  public update() {
    // computed 在 update 时只设置 dirty 为 true ，computed 的 update 由代理实现
    if (this.lazy) this.dirty = true;
    else this.run();
  }
}

// 发布-订阅模式，用于依赖收集、派发更新
class Dep {
  // 当前触发的依赖，全局可用
  public static target: Watcher | null = null;
  // 处理同时收集多个 watcher 的场景
  public static targetStack: Array<Watcher> = [];

  // 依赖
  private subs: Set<Watcher> | null = null;

  constructor() {
    this.subs = new Set<Watcher>();
  }

  // 在 Watcher 类中调用
  public addSub(watcher: Watcher) {
    this.subs?.add(watcher);
  }

  // 依赖收集
  public depend() {
    if (Dep.target) Dep.target.addDep(this);
  }

  // 派发更新
  public noticy() {
    if (!this.subs) return;

    for (const watcher of this.subs) watcher.update();
  }
}

// 响应式
class Observer {
  public dep: Dep | null = null;

  constructor(data: Options) {
    // "__ob__" 不可枚举
    Object.defineProperty(data, "__ob__", {
      value: this,
      enumerable: false,
    });

    // 给 "__ob__" 添加 dep ，处理增加、删除属性的响应式
    this.dep = new Dep();

    if (Array.isArray(data)) {
      Object.setPrototypeOf(data, ArrayMethods);
      observeArray(data);
    } else this.walk(data);
  }

  private walk(data: Options) {
    const keys = Object.keys(data);
    for (const key of keys) defineReactive(data, key);
  }
}

class Vue {
  private _data: Options | null = null;
  [key: string]: any;

  constructor(options: VueOptions) {
    this.initData(options.data);
    this.initComputed(options.computed);
    this.initWatch(options.watch);

    if (options.render) new Watcher(this, options.render);
  }

  private initData(data?: Options) {
    if (!data) return;

    // 数据代理，使得可以直接用 this 调用数据
    this._data = data;
    const keys = Object.keys(this._data);
    for (const key of keys) {
      Object.defineProperty(this, key, {
        get: () => this._data![key],
        set: (newValue) => (this._data![key] = newValue),
      });
    }

    // 开始响应式处理
    observe(this._data);
  }

  private initComputed(computed: { [key: string]: Function }) {
    if (!computed) return;

    const keys = Object.keys(computed);
    for (const key of keys) {
      const watcher = new Watcher(this, computed[key], undefined, {
        lazy: true,
      });

      // computed 也做数据代理，方便 this 调用，也不用加括号了
      Object.defineProperty(this, key, {
        get: () => {
          // 只有 computed 依赖的数据修改了，才更新 computed，否则使用缓存
          if (watcher.dirty) {
            watcher.get();
            watcher.dirty = false;
          }

          if (Dep.target) {
            for (const dep of watcher.deps) dep.depend();
          }

          return watcher.value;
        },

        // computed 的 set 不允许修改自己，只能做其他事
        set: () => {},
      });
    }
  }

  private initWatch(watch: { [key: string]: Function }) {
    if (!watch) return;

    const keys = Object.keys(watch);
    for (const key of keys) new Watcher(this, key, watch[key]);
  }

  public static $set(target: Observer, key: string, value: any) {
    if (!target["__ob__"]) return;

    target[key] = value;
    defineReactive(target, key);
    target["__ob__"].dep.noticy();
  }

  public static $delete(target: Observer, key: string) {
    if (!target["__ob__"]) return;

    delete target[key];
    target["__ob__"].dep.noticy();
  }
}
// --------------------------------------------------------------------------------------------

const vm = new Vue({
  el: "#app",
  data: {
    a: 123,
    person: { name: "asdf" },
    item: [
      { id: 0, name: "a" },
      { id: 0, name: "b" },
    ],
  },

  computed: {
    xxx() {
      console.log("computed 1");
      return `${this.a} ${this.person.name}`;
    },
  },

  watch: {
    xxx() {
      console.log("watch");
    },
  },

  render() {
    // this.a = 1;
  },
});
```

#### 5.1.2 Vue3 响应式

实现方式：

* ref ：Object\.defineProperty ，返回一个对象，value 保存数据，只能用于基本类型，若用于引用类型则底层会使用 reactive

* reactive ：Proxy  ，只能用于引用类型

* 重复使用 ref 、reactive 无效，因为 Vue 底层有 WeakMap 缓存；若用 reactive 处理 ref ，会生成 ref 对象的 Proxy 代理对象：
  
  ```
  <script setup lang="ts">
  import { ref, reactive } from "vue";
  
  const obj1 = reactive({ a: 1 });
  const obj2 = reactive(obj1);
  // true
  console.log(obj1 === obj2);
  
  const cnt1 = ref(0);
  const cnt2 = ref(cnt1);
  // true
  console.log(cnt1 === cnt2);
  
  const cnt3 = reactive(cnt1);
  // false
  console.log(cnt1 === cnt3);
  cnt3.value++;
  // 1 1
  console.log(cnt1.value, cnt3.value);
  </script>
  
  <template></template>
  ```

Proxy 的优点：

* Proxy 可以拦截对象基本操作，如 obj\.key ，arr\.push\(\) 最终都会转换成基本操作 get\(\) 、set\(\)

* Proxy 的性能更高：
  
  * Vue2 在初始化就递归便利每一个 key 并使用  Object\.defineProperty ；Vue3 的 Proxy 只需要处理引用类型，且响应式是 lazy 的，只有 get 到 key 才会做响应式
  
  * Vue2 所有数据都在 datat 中，都做响应式，不过可以用冻结解决；而 Vue3 可以根据需要定义响应式数据

实现：

Vue3 的响应式模块是一个单独的包。

```
// utils.js

export function isObject(value) {
  return typeof value === "object" && value !== null;
}

export function isProxy(value) {
  return Object.prototype.toString.call(value) === "[object Proxy]";
}

// 判断两个 value 是否相
// 等，is() 相等时为 true 可以得到更具有实际意义的结果
// true false false true
// console.log(+0 === -0, Object.is(+0, -0), NaN === NaN, Object.is(NaN, NaN));
export function isChange(oldValue, newValue) {
  return !Object.is(oldValue, newValue);
}
```

```
// operate.js

export const TrackOpType = {
  GET: "get",
  HAS: "has",
  ITERATE: "iterate",
};

export const TriggerOpType = {
  SET: "set",
  ADD: "add",
  DELETE: "delete",
};
```

```
// effect.js

import { TrackOpType, TriggerOpType } from "./operate.js";

// effect 执行 fn ，fn 执行触发数据的 get ，get 中 track 收集 activeEffect
/**之所以不直接把 fn 作为依赖而是加一层，是因为在 trigger 时，可能会改变依赖关系
 * const obj = { a: 1, b: 2, c: 3 };
   const p1 = reactive(obj);
   function run() {
     if (p1.a === 1) console.log(p1.b);
     else console.log(p1.c);
   }
   effect(run);
   p1.a = 123;
 */
let activeEffect = null;
const activeEffectStack = [];

// 默认的调度器，实现异步更新和防止多次 trigger 相同的 fn
const defaultScheduler = function () {
  Promise.resolve().then(() => {
    this();
  });
};

export function effect(fn, options = {}) {
  options.lazy = options.lazy || false;
  options.scheduler = options.scheduler || defaultScheduler;

  const effectFn = function () {
    try {
      activeEffect = effectFn;
      activeEffectStack.push(effectFn);

      activeEffect.options = options;

      // 多对多关系，deps -> fn ,fn -> deps
      activeEffect.deps = [];

      return fn();
    } finally {
      activeEffectStack.pop();
      const len = activeEffectStack.length;
      activeEffect = len ? activeEffectStack[len - 1] : null;
    }
  };

  if (!options.lazy) effectFn();
  else return effectFn;
}

function cleanFnDeps(effectFn) {
  if (!effectFn || !effectFn.deps) return;

  for (const dep of effectFn.deps) dep.delete(effectFn);
  effectFn.deps.length = 0;
}

// track --------------------------------------------------------------------
// 数据结构，Vue 中没有 TypeMap ，多了这一层在 trigger 时会比 Vue 更精确，避免不必要的 trigger ，但会多一些内存消耗
// type Deps = Set(Function);
// type TypeMap = Map<Operater, Deps>;
// type PrpsMap = Map<string | Symbol, TypeMap>;
// type TargetMap = WeakMap<Object, PropsMap>;
const targetMap = new WeakMap();

let shouldTrack = true;

export function pauseTrack() {
  shouldTrack = false;
}

export function resumeTrack() {
  shouldTrack = true;
}

const INTERATE_KEY = Symbol('iterate_key"');
export function track(target, type, key) {
  if (!shouldTrack || !activeEffect) return;

  // console.log("track " + type, key);

  let propsMap = targetMap.get(target);
  if (!propsMap) {
    propsMap = new Map();
    targetMap.set(target, propsMap);
  }

  if (!key) key = INTERATE_KEY;
  let typeMap = propsMap.get(key);
  if (!typeMap) {
    typeMap = new Map();
    propsMap.set(key, typeMap);
  }

  let deps = typeMap.get(type);
  if (!deps) {
    deps = new Set();
    typeMap.set(type, deps);
  }

  deps.add(activeEffect);
  activeEffect.deps.push(deps);
}

// trigger -------------------------------------------------------------------------
// trigger 类型对应需要的 track 类型
const triggerTypeMap = {
  [TriggerOpType.SET]: [TrackOpType.GET],
  [TriggerOpType.ADD]: [TrackOpType.GET, TrackOpType.HAS, TrackOpType.ITERATE],
  [TriggerOpType.DELETE]: [
    TrackOpType.GET,
    TrackOpType.HAS,
    TrackOpType.ITERATE,
  ],
};

function getEffectFns(target, type, key) {
  const result = new Set();
  if (!target || !type || !key) return result;

  const propsMap = targetMap.get(target);
  if (!propsMap) return result;

  /**add、delete 会影响长度，所以 iterate 也需要 trigger
   * const p1 = reactive({ a: 1 });
     function run() {
       for (const i in p1) console.log("for");
     }
     effect(run);
     console.log("\n");
     p1.newProps = 123;
   */
  const keys = [key];
  if ([TriggerOpType.ADD, TrackOpType.DELETE].includes(type))
    keys.push(INTERATE_KEY);

  for (const k of keys) {
    const typeMap = propsMap.get(k);
    if (!typeMap) continue;

    const trackTypes = triggerTypeMap[type];
    for (const t of trackTypes) {
      const deps = typeMap.get(t);
      if (!deps) continue;

      for (const dep of deps) result.add(dep);
    }
  }

  return result;
}

export function trigger(target, type, key) {
  // console.log("trigget " + type, key);

  const effectFns = getEffectFns(target, type, key);
  for (const fn of effectFns) {
    // 防止在 trigger 时 track 相同的依赖，导致栈溢出，如 state.a = state.a + 1
    if (fn === activeEffect) continue;

    // 先在所有 deps 中 clean 这个依赖，避免多余的依赖关系，执行 fn 后会再次建立依赖关系
    // cleanFnDeps 配合 defaultScheduler 异步更新，能实现多个数据同时 trigger 同一个依赖时，只执行最后一次
    cleanFnDeps(fn);

    // 使用调度器执行 fn
    fn.options.scheduler.call(fn);
  }
}
```

```
// handlers.js

import { track, pauseTrack, resumeTrack, trigger } from "./effect.js";
import { reactive } from "./core.js";
import { isObject, isChange } from "./utils.js";
import { TrackOpType, TriggerOpType } from "./operate.js";

const RAW = Symbol('raw"');
const arrayInstcumentation = {};

/**数组使用查找方法时若查找的是引用，如：
 * const obj = { a: 1 };
   const arr = reactive([ 1, 2, obj] );
   console.log(arr.includes(obj));
 * 输出 false ，正确应该输出 true
 * 原因是 obj 是原始对象，而 arr 中的 obj 变成了 Proxy 对象，引用不同
 */
["includes", "其他查找方法"].forEach((method) => {
  arrayInstcumentation[method] = function (...args) {
    // 方法一：查找时把原始对象转化成 Proxy
    // ...

    // 方法二：Vue 采用的方式，先再代理中找一遍，找不到再去原始对象找，优点是适用性强=，缺点是需要多余的便利
    const result = Array.prototype[method].apply(this, args);
    if (result < 0 || result === false) {
      // this[RAW] 得到原始对象
      return Array.prototype[method].apply(this[RAW], args);
    }
    return result;
  };
});

// 数组使用这些方法时，会 get length 并 track，但框架应该避免这种意外的 track
["push", "pop", "unshfit", "shift", "split"].forEach((method) => {
  arrayInstcumentation[method] = function (...args) {
    pauseTrack();
    Array.prototype[method].apply(this, args);
    resumeTrack();
  };
});

// 拦截基本操作 .get
function get(target, key, receiver) {
  if (key === Symbol.toStringTag) return "Proxy";
  if (key === RAW) return target;

  track(target, TrackOpType.GET, key);

  // 数组方法处理
  if (Array.isArray(target) && arrayInstcumentation.hasOwnProperty(key)) {
    return arrayInstcumentation[key];
  }

  const result = Reflect.get(target, key, receiver);
  if (isObject(result)) return reactive(result);
  return result;
}

// 拦截基本操作 .hasProperty ，如使用 in
function has(target, key) {
  track(target, TrackOpType.HAS, key);

  return Reflect.has(target, key);
}

// 拦截基本操作 .ownKeys，如使用 for...in
function ownKeys(target) {
  track(target, TrackOpType.ITERATE);

  return Reflect.ownKeys(target);
}

// 拦截基本操作 .set ，如修改、添加
function set(target, key, value, receiver) {
  const oldValue = target[key];
  const oldLenth = Array.isArray(target) ? target.length : undefined;
  const type = target.hasOwnProperty(key)
    ? TriggerOpType.SET
    : TriggerOpType.ADD;

  const result = Reflect.set(target, key, value, receiver);
  if (!result) return result;

  // 只有 add 或新旧数据不同的 set 才需要 trigger
  if (type === "add" || isChange(oldValue, value)) {
    trigger(target, type, key);

    /**数组特殊情况一：当设置数组元素超过原本的 length 时，或者类似这种隐式修改 length 的情况
     * const arr = reactive([ 1, 2 ]);
       arr[10] = 123;
     * 只 track add 10 ，length 变长但并没有 track set length
       原因是 JS 源码中对数组的这种操作会调用：
       Object.defineProperty(arr, "10", { value: 123 });
       但这种方式本身就不会触发 Proxy 的 set
     */
    const newLenth = Array.isArray(target) ? target.length : undefined;
    if (Array.isArray(target) && newLenth !== oldLenth) {
      if (key !== "length") trigger(target, TriggerOpType.SET, "length");
      else {
        /**数组特殊情况二：当主动变小 length 事，删除的元素不会触发 delete
         * const arr = reactive([ 1, 2, 3 ]);
         arr.length = 1;
         */
        for (let i = newLenth; i < oldLenth; i++)
          trigger(target, TriggerOpType.DELETE, i.toString());
      }
    }
  }

  return result;
}

// 拦截基本操作 delete
function deleteProperty(target, key) {
  const hasKey = target.hasOwnProperty(key);
  if (!hasKey) return true;

  const result = Reflect.deleteProperty(target, key);
  if (result) trigger(target, TriggerOpType.DELETE, key);

  return result;
}

export const handlers = {
  get,
  has,
  ownKeys,
  set,
  deleteProperty,
};
```

```
// core.js

import { isObject, isProxy, isChange } from "./utils.js";
import { handlers } from "./handlers.js";
import { TrackOpType, TriggerOpType } from "./operate.js";
import { track, trigger, effect } from "./effect.js";

// ref 、reactive -----------------------------------------------------------------------------
// 防止同一个原始对象重复使用 Proxy，提高效率
export const targetMap = new WeakMap();

export function reactive(target) {
  // 如果不是引用类型，或者已经是 Proxy 了，就直接 return
  if (!isObject(target) || isProxy(target)) return target;
  // 如果源引用 target 已经被 Proxy 代理过了，就直接 return
  if (targetMap.has(target)) return targetMap.get(target);

  const proxy = new Proxy(target, handlers);
  targetMap.set(target, proxy);

  return proxy;
}

export function ref(value) {
  return {
    get value() {
      track(this, TrackOpType.GET, "value");

      if (isObject(value)) value = reactive(value);
      return value;
    },

    set value(newValue) {
      if (!isChange(value, newValue)) return;
      if (isObject(newValue)) newValue = reactive(newValue);

      value = newValue;
      trigger(this, TriggerOpType.SET, "value");
    },
  };
}

// computed --------------------------------------------------------------------------------------
function normalizeParamece(options) {
  let getter, setter;

  if (typeof options === "function") {
    getter = options;
    setter = () => {};
  } else {
    getter = options.get;
    setter = options.set;
  }

  return { getter, setter };
}

export function computed(options) {
  const { getter, setter } = normalizeParamece(options);

  /**机制
   * lazy：只有 get computed ，且为 dirty 才会执行（初始 dirty 为 true）
   * computed 依赖的数据变化时，只会设置 dirty 为 true ，并不会马上重新执行，只有再次 get computed 才会执行
   * 设置 dirty 为 true 后，马上 trigger 执行外部的 effect ，若外部还是 computed ，trigger 后同上
   */
  const effectFn = effect(getter, {
    lazy: true,
    scheduler: () => {
      dirty = true;
      trigger(result, TriggerOpType.SET, "value");
    },
  });

  // 闭包数据
  let oldValue,
    dirty = true;

  const result = {
    get value() {
      // computed 自身也是数据，也需要 track
      track(result, TrackOpType.GET, "value");

      // 缓存，只有 computed 依赖的数据变化，才重新执行 computed
      if (dirty) {
        oldValue = effectFn();
        dirty = false;
      }

      return oldValue;
    },

    set value(newValue) {
      setter(newValue);
    },
  };

  return result;
}
```

```
// 测试

import { ref, computed } from "./core.js";
import { effect } from "./effect.js";

const cont = ref();
const doubleCnt = computed(() => {
  console.log("computed");
  return cont.value * 2;
});

effect(() => {
  console.log("watchEffect");
  doubleCnt.value;
});

setTimeout(() => ++cont.value, 1000);
```

### 5.2 虚拟 DOM、diff 算法

template 的本质是 render 函数的语法糖，template 最终会编译为 render 函数。render 是一个 Watcher ，每次数据更新都再次 render 。

如果 render 函数直接生成真实 DOM ，性能会很低，所以 render 函数只生成虚拟 DOM （Virtual DOM，VDOM），和上次更新的 VDOM 比较，找到变化的部分，进行最小量更新：

- 框架的性能永远比不上原生 JS ，VDOM 只是因为 render 直接渲染真实 DOM 性能低才出现的

- VDOM 还可以实现跨平台，根据平台生成对应的真实 DOM

过程：

* Vue 编译，模板编译得到 render （若写了 render 则直接用 render）

* 把 reder 放到 Watch 中，每次数据更新就会重新执行 render 

* 比较新旧 VNode ，为了提高性能以及结合实际应用场景，只会比较同一层级，若 tag 和 key 相同则是同一个节点

* 相同节点根据 child 的类型进行更新，若新旧 child 都是子节点数组，则用 diff 算法比较，找到 tag 和 key 相同的节点，相同就只移动和 patch，新增新节点，删除旧节点
  
  * key 应该保证唯一且稳定，如 index 虽然唯一，但会受到增删的影响导致不稳定，因此 v\-for 中的 key 最好使用数据中的唯一 id 而不是 index

代码，Vue 的 VDOM 和 diff 基于第三方库 snabbdom ：

```
class VNode {
  public diffFlag = false;

  constructor(
    public tag: string,
    public attr: { [key: string]: any },
    public child: string | Array<VNode>,
    public elm?: Element,
  ) {}
}

// ----------------------------------------------------------------------------------------------
// to VDOM
const h = (
  tag: string,
  attr: { [key: string]: any },
  child: string | Array<VNode>,
) => new VNode(tag, attr, child);

// VODM to DOM
const createElement = (vnode: VNode): Element => {
  const elm = document.createElement(vnode.tag);
  vnode.elm = elm;

  if (typeof vnode.child === "string") elm.innerText = vnode.child;
  else for (const child of vnode.child) elm.append(createElement(child));

  return elm;
};
// ----------------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------------
const isSameNode = (oldNode: VNode, newNode: VNode): boolean => {
  return oldNode.tag === newNode.tag && oldNode.attr.key === newNode.attr.key;
};

/**Vue2 diff
 * 使用双端指针，按照 os-ns，oe-ne，os-ne，oe-ns 4 中策略依次找到相同节点，patch，其中后 2 个策略需要 move
 * 若 4 种策略都找不到，则遍历 oldChild 寻找（可用 map 缓存）：
   - 若找到，则 move，patch，并标记为已处理
   - 若找不到，则新增
 * 最后根据双端指针的位置，新增、删除节点
 */
const diff_Vue2 = (oldChild: Array<VNode>, newChild: Array<VNode>): void => {
  let oldStart = 0;
  let newStart = 0;
  let oldEnd = oldChild.length - 1;
  let newEnd = newChild.length - 1;

  const parent = oldChild[0].elm!.parentNode as Element;

  const keyToOldIndexMap: Map<string, number> = new Map();

  // 4 种策略依次对比对比
  while (oldStart <= oldEnd && newStart <= newEnd) {
    // 跳过
    if (oldChild[oldStart].diffFlag) {
      ++oldStart;
      continue;
    } else if (oldChild[oldEnd].diffFlag) {
      --oldEnd;
      continue;
    }

    // 4 种策略
    if (isSameNode(oldChild[oldStart], newChild[newStart])) {
      patchVNode(oldChild[oldStart++], newChild[newStart++]);
      continue;
    } else if (isSameNode(oldChild[oldEnd], newChild[newEnd])) {
      patchVNode(oldChild[oldEnd--], newChild[newEnd--]);
      continue;
    } else if (isSameNode(oldChild[oldStart], newChild[newEnd])) {
      // 移动
      parent.insertBefore(
        oldChild[oldStart].elm!,
        oldChild[oldEnd].elm!.nextSibling,
      );

      patchVNode(oldChild[oldStart++], newChild[newEnd--]);
      continue;
    } else if (isSameNode(oldChild[oldEnd], newChild[newStart])) {
      // 移动
      parent.insertBefore(oldChild[oldEnd].elm!, oldChild[oldStart].elm!);

      patchVNode(oldChild[oldEnd--], newChild[newStart++]);
      continue;
    }
    // 若 4 种策略都没有找到相同节点，则需再次遍历一次 oldChild 未处理节点
    else {
      // 用 map 缓存起来，以后就能快速查询
      if (keyToOldIndexMap.size === 0) {
        for (let oldIndex = oldStart; oldIndex <= oldEnd; oldIndex++) {
          keyToOldIndexMap.set(oldChild[oldIndex].attr.key || "", oldIndex);
        }
      }

      const oldIndex = keyToOldIndexMap.get(newChild[newStart].attr.key);

      if (
        oldIndex !== undefined &&
        isSameNode(oldChild[oldIndex], newChild[newStart])
      ) {
        oldChild[oldIndex].diffFlag = true;
        parent.insertBefore(oldChild[oldIndex].elm!, oldChild[oldStart].elm!);
        patchVNode(oldChild[oldIndex], newChild[newStart]);
      }
      // 如果没找到，说明是新的节点
      else {
        parent.insertBefore(
          createElement(newChild[newStart]),
          oldChild[oldStart].elm!,
        );
      }

      ++newStart;
    }
  }

  /**收尾
   * 如果 oldNode 先遍历完，说明 newNode 有需要新增的节点
   * 如果 newNode 先遍历完，说明 oldNode 有需要删除的节点
   * 如果同时遍历完，就不需要处理
   */
  if (oldStart > oldEnd && newStart <= newEnd) {
    const before = oldChild[oldEnd].elm!.nextSibling
      ? oldChild[oldStart].elm!
      : null;

    for (let i = newStart; i <= newEnd; i++) {
      parent.insertBefore(createElement(newChild[i]), before);
    }
  } else if (oldStart <= oldEnd && newStart > newEnd) {
    for (let i = oldStart; i <= oldEnd; i++) {
      if (!oldChild[i].diffFlag) parent.removeChild(oldChild[i].elm!);
    }
  }
};

// 最长递增子序列
function longestIncreasingSubsequence(nums: number[]): number[] {
  if (nums.length === 0) return [];

  // res 存储 index ，pre 存储前驱 index
  const res: number[] = [];
  const pre: number[] = new Array(nums.length).fill(-1);

  // 这里只处理 >= 0 的数字
  let start = 0;
  for (start = 0; start < nums.length; start++) {
    if (nums[start] >= 0) {
      res[0] = start;
      break;
    }
  }

  // 开始
  for (let i = start + 1; i < nums.length; i++) {
    if (nums[i] < 0) continue;

    const resLastIndex = res[res.length - 1];

    if (nums[i] > nums[res[resLastIndex]]) {
      res.push(i);
      pre[i] = res[resLastIndex];
    }
    // 否则就用二分，找到第一个大于 nums[i] 的数字，用谈心思想，替换得到当前最优解
    else {
      let left: number = 0;
      let right = resLastIndex;
      let mid = Math.floor((left + right) / 2);

      for (; left < right; mid = Math.floor((left + right) / 2)) {
        if (nums[res[mid]] < nums[i]) left = mid + 1;
        else right = mid;
      }

      res[left] = i;
      if (left > 0) pre[i] = res[left - 1];
    }
  }

  // 反向检查
  for (let i = res.length - 1; i > 0; i--) res[i - 1] = pre[res[i]];

  return res;
}

/**Vue3 diff
 * 先用双端指针找到两边相同节点，patch
 * 若上一步结束后，仅有新增、删除节点，直接新增、删除，结束 diff
 * 若 old、new 都还有节点：
   - 删除 new 没有的节点
   - 找出最长递增子序列 sub ，sub 中的节点相对位置在 new 中是不变的，不需要移动，只需要 patch ；
     move，patch 不再 sub 的节点，新增 old 没有的节点
 */
const quickDiff_Vue3 = (
  oldChild: Array<VNode>,
  newChild: Array<VNode>,
): void => {
  let i = 0;
  let oldEnd = oldChild.length - 1;
  let newEnd = newChild.length - 1;

  // 双端指针先找到前后不需要移动的节点
  while (i <= oldEnd && i <= newEnd) {
    if (isSameNode(oldChild[i], newChild[i])) {
      patchVNode(oldChild[i], newChild[i]);
      ++i;
    } else break;
  }
  while (i <= oldEnd && i <= newEnd) {
    if (isSameNode(oldChild[oldEnd], newChild[newEnd])) {
      patchVNode(oldChild[oldEnd--], newChild[newEnd--]);
    } else break;
  }

  // 如果还有未处理的节点
  if (i <= oldEnd || i <= newEnd) {
    const parent = oldChild[0].elm!.parentNode as Element;

    // 全部是要删除的节点i
    if (i <= oldEnd && i > newEnd) {
      for (; i <= oldEnd; i++) parent.removeChild(oldChild[i].elm!);
    }
    // 全部是要新增的节点
    else if (i > oldEnd && i <= newEnd) {
      for (; i <= newEnd; i++) {
        const before = oldChild[oldEnd + 1]?.elm || null;
        parent.insertBefore(createElement(newChild[i]), before);
      }
    }
    // 复杂情况
    else {
      let oldStart = i;
      let newStart = i;

      // map 缓存 newChild
      const keyToNewIndexMap: Map<string, number> = new Map();
      for (; newStart <= newEnd; newStart++) {
        keyToNewIndexMap.set(newChild[newStart].attr.key, newStart);
      }

      // newNode 在 oldChild 中的 index
      const toBePatch = newEnd - i + 1;
      const newNodeInOldIndexMap = Array(toBePatch).fill(-1);

      // 遍历 oldChild
      let needMove = false;
      let newIndexSoFar = -1;
      for (; oldStart <= oldEnd; oldStart++) {
        const newIndex: number | undefined = keyToNewIndexMap.get(
          oldChild[oldStart].attr.key,
        );

        // 如果在 newChild 中找不到，说明要删除
        if (
          newIndex === undefined ||
          !isSameNode(oldChild[oldStart], newChild[newIndex])
        ) {
          parent.removeChild(oldChild[oldStart].elm!);
        }
        // 找到了就记录下来
        else {
          newNodeInOldIndexMap[newIndex - i] = oldStart;

          // 确定后续是否需要移动，一旦不是连续递增就需要移动
          if (!needMove) {
            if (newIndex > newIndexSoFar) newIndexSoFar = newIndex;
            else needMove = true;
          }
        }
      }

      // 处理 newNodeInOldIndexMap ，新增、踢动节点
      const subsequence = needMove
        ? longestIncreasingSubsequence(newNodeInOldIndexMap)
        : [];

      let last = subsequence.length - 1;
      for (let j = newNodeInOldIndexMap.length - 1; j >= 0; j--) {
        const oldIndex = newNodeInOldIndexMap[j];
        const before = newChild[j + i + 1]?.elm || null;

        // 新增
        if (oldIndex === -1) {
          parent.insertBefore(createElement(newChild[j + i]), before);
        }
        // 移动或跳过
        else {
          // 只有不再最长递增子序列中，才需要移动
          if (
            needMove &&
            (last < 0 || oldIndex !== newNodeInOldIndexMap[subsequence[last]])
          ) {
            parent.insertBefore(oldChild[oldIndex].elm!, before);
          } else --last;

          patchVNode(oldChild[oldIndex], newChild[j + i]);
        }
      }
    }
  }
};
// ----------------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------------
const patchVNode = (oldNode: VNode, newNode: VNode): void => {
  const oldNodeElm = oldNode.elm as Element;
  newNode.elm = oldNodeElm;

  // 若 newNode 是文本，直接覆盖
  if (typeof newNode.child === "string") {
    oldNodeElm.innerHTML = newNode.child;
  }
  // 若 newNode 有子节点，oldNode 是文本或空数组
  else if (typeof oldNode.child === "string" || oldNode.child.length === 0) {
    oldNodeElm.innerHTML = "";
    for (const child of newNode.child) {
      oldNodeElm.appendChild(createElement(child));
    }
  }
  // 若 newNode、oldNode 都有子节点，则适应 diff
  // else diff_Vue2(oldNode.child, newNode.child);
  else quickDiff_Vue3(oldNode.child, newNode.child);
};

const patch = (oldNode: Element | VNode, newNode: VNode): void => {
  if (oldNode === newNode) return;

  // 如果是第一次 render ，传入的 oldNode 是 Element ，就直接渲染 newNode
  if ((oldNode as Element).nodeType) {
    const elm = oldNode as Element;
    elm.appendChild(createElement(newNode));
  }
  // 否则，就比较新旧 vnode
  else {
    oldNode = oldNode as VNode;

    // 只比较同一层级，若 tag 和 key 相同，就认为 2 个 vnode 是相同的
    if (isSameNode(oldNode, newNode)) patchVNode(oldNode, newNode);
    else {
      const oldNodeElm = oldNode.elm as Element;

      const parent = oldNodeElm.parentNode;
      parent!.insertBefore(createElement(newNode), oldNodeElm);
      parent?.removeChild(oldNodeElm);
    }
  }
};
// ----------------------------------------------------------------------------------------------

class Vue {
  public _vnode: Element | VNode | null = null;
  public _data: any;
  public _render: (h: Function) => VNode;

  constructor(options: { [key: string]: any }) {
    this._data = options.data();
    this._render = options.render;

    if (options.el) this.$mount(options.el as string);
  }

  public _update() {
    const newNode = this._render.call(this, h);
    patch(this._vnode!, newNode);
    this._vnode = newNode;
  }

  public $mount(sel: string) {
    const app = document.querySelector(sel);
    if (!app) return;

    this._vnode = app;
    this._update();

    // new Watch(this, () => this._update());
  }
}

const vm = new Vue({
  data: function () {
    return {
      arr: [
        { id: "1", value: "item 1" },
        { id: "2", value: "item 2" },
        { id: "3", value: "item 3" },
        { id: "4", value: "item 4" },
        { id: "5", value: "item 5" },
      ],
    };
  },

  render(h: Function): VNode {
    return h(
      "ul",
      {},
      this._data.arr.map((item: any) => {
        if (typeof item.value === "string")
          return h("li", { key: item.id }, item.value);
        else {
          return h(
            "p",
            { key: item.id },
            item.value.map((i: any) => h("li", { key: i.id }, i.value)),
          );
        }
      }),
    );
  },
});

vm.$mount("#app");

vm._data?.arr?.splice(2, 1, {
  id: "3",
  value: [
    { id: "3-1", value: "item 31" },
    { id: "3-2", value: "item 32" },
  ],
});
vm._update();
```

从 diff 中可以看出，v-for 加了唯一 key 就可以找出新旧 VNode 相同节点，提高性能：

```
<script>
export default {
  data: function () {
    return {
      list: [
        { id: "1", value: "1" },
        { id: "2", value: "2" },
        { id: "3", value: "3" },
      ],

      formChangeTag: true,
    };
  },

  methods: {
    insertListItem() {
      this.list.unshift({ id: "0", value: "0" });
    },
  },
};
</script>

<template>
  <div>
    <button @click="insertListItem">insert list</button>

    <!-- 
      key 默认会传入 index ，但是这样修改数据后会打乱 key 和节点的对应关系，
      把原本不同的节点判断为相同节点，使得进行了很多不必要的 patch ，浪费性能
    -->
    <ul>
      <li v-for="i in list">{{ i.value }}</li>
    </ul>
    <br />

    <!-- 使用唯一的 key 后，数据修改后能快速找到相同节点并 patch ，性能提高，因为相同节点内部的变化通常是很小的 -->
    <ul>
      <li v-for="i in list" :key="i.id">{{ i.value }}</li>
    </ul>
    <br />

    <!-- input 测试可以更明显，加唯一 key 就能解决 -->
    <ul>
      <li v-for="i in list"><input type="text" /></li>
      <!-- <li v-for="i in list" :key="i.id"><input type="text" /></li> -->
    </ul>
  </div>
</template>
```

### 5.3 模板编译

template 本质就是 string ，是 render 的语法糖，template 最终会编译为 render 。

render 函数需要一个根节点，所以 template 才需要根节点，Vue3 会默认加上 Fragment 作为根节点。

# 二、React

基本：

* React 使用 JSX 、TSX ，可以用变量保存 html 标签并使用

* React16.8 是变化比较大的版本，新增了函数式组件、hook 等核心特性。

入口：

* StrictMode 可以在开发环境检查潜在问题，不会被渲染，也不会被打包，仅在开发环境生效

* React18 之后，StrictNode 在开发环境中，每次组件都会 render 两次，第一次 render 是为了检查潜在问题，并不会真正渲染，第二次才是真正的 render

```
// /src/main.tsx

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
```

## 1 语法

### 1.1 状态、差值语法、数据绑定

与 Vue 区别：

* React 的响应式系统：
  
  * 非侵入式，需要手动派发更新，响应式数据也叫状态
  
  * React 由于 setXxx 是一个函数，而异步更新会把这个函数放到异步队列，所以修改后无法同步得到最新 value ；而 Vue 是直接修改数据，可以同步得到最新 value ，只是异步更新 DOM
  
  * useRef 返回的不是状态，只是普通对象，所以修改不会重新 render ；其他状态修改导致重新 render 时。useRef 也不会重新初始化，引用还是原来的内存地址
  
  * React 提供 useReducer ，用于集中式管理状态，适合用于复杂的数据
  
  * 为了更方便使用，可以用第三方库 immer 代替 useState 、useReducer

* React 的差值语法：
  
  * 使用单个大括号；数据绑定、事件绑定也是使用差值语法
  
  * 引用类型除了数组、Set 外无法直接像 Vue 一样差值语法渲染为文本，需要自己转为 string

* React 的少部分标签属性为了和原生 html 区分，防止冲突，会有所不同，如：
  
  * 事件绑定如 onClick
  
  * 类名 className
  
  * \<label\> 的 htmlFor

* react 采用强制命名，如组件用大驼峰（包括组件标签）、hook 以 use 为前缀

* react 的执行逻辑与 Vue 不同，Vue 的逻辑写在 setup 中，相当于初始化的生命周期，只执行一次；而 react 的逻辑写在 render 函数内，每次重新 render 都会重新执行，因此需要考虑很多问题：
  
  * hook 只能在函数顶层调用，不能在条件、循环等内部调用，因为：
    
    * react 会用单链表按顺序保存 hook 的状态对象，重新 render 时，按顺序取出并复用状态
    
    * 为了保证复用的状态顺序、数量相同，hook 就必须在顶层调用，条件循环等则无法预知顺序以及复用数量，react 在运行时也是通过检查 hook 的复用顺序以及数量判断 hook 是否在顶层调用；但大部分情况下即使 hook 不在顶层调用，顺序、数量可能也是一样的如 if\(true\) ，因此在编译时会通过 ts\-lint 检查
  
  * 非状态，如普通变量、函数就会重新初始化，像引用类型数据以及函数，就会是新引用，因此在类似缓存的场景就会判断为新状态，若不想初始化，可以：
    
    * 用 useRef 保存任意类型数据
    
    * 非函数引用类型也可以用空依赖项 useMemo 
    
    * 函数可以用空依赖项的 useCallback

示例：

```
pnpm add immer
```

```
// /src/App.tsx

import { useState, useReducer, useRef } from "react";
import { useImmer, useImmerReducer } from "use-immer";

// 函数式组件，即 render 函数
function App() {
  // undefined
  // console.log(this);

  console.log("render");

  // 可以把 html 保存到变量
  const title1 = <span>title</span>;
  const title2 = "<span>title</span>";

  // 特别的，箭头函数定义泛型时需要加逗号，防止解析为 html ；其他情况则不用，可以正常解析，如普通函数、函数调用等
  const func = <T,>(text: T) => text;

  /**状态，即响应式数据， -------------------------------------------------------------------
   * 通过更新函数修改状态才会重新执行 render 函数
   * useState 可以传入 value ；也可以传入函数，用于处理初始化逻辑，函数只初始执行一次，返回值用作状态
   * 创建、修改状态都不会修改原始数据，因为创建状态会生成新的引用
   * setCount 修改状态必须传入一个 newValue ，如引用类型需要传入新的引用
   */
  // 两种方式创建
  const [count, setCount] = useState(0);
  // const [count, setCount] = useState(() => 0);

  // 两种方式修改 state
  const add = () => {
    // 异步更新，只保留最后一次修改
    setCount(count + 1);
    setCount(count + 1);

    // 如果需要多次修改，就使用函数形式，pre 为前一次的值；这种方式也只会重新 render 一次
    // setCount((pre) => {
    //   console.log("set1");
    //   return pre + 1;
    // });
    // setCount((pre) => {
    //   console.log("set2");
    //   return pre + 1;
    // });

    // oldValue ，因为是异步更新
    console.log(count);
  };

  /**useRef ，禁止在组件顶层修改状态，否则会无线递归 render ，可以用 useRef 解决
   * 返回的不是状态，只是普通对象
   * useRef 返回的对象在每次重新 render 时不会被重新初始化
   */
  // 禁止，类似情况可以用 useRef 解决，防止无限 render
  // setCount(count + 1);
  const cntRef = useRef(0);
  console.log(++cntRef.current);

  // useRef 解决普通变量重新 render 后被重新初始化的问题
  // let timer: ReturnType<typeof setInterval> | null = null;
  const timer = useRef<ReturnType<typeof setInterval> | null>(null);
  const start = () => {
    // 需要函数形式，若是 setCount(count) 由于函数作用域只和定义位置有关，所以当前 render 的定时器用的始终是当前 render 函数的变量
    timer.current = setInterval(() => setCount((pre) => pre + 1), 100);
  };
  const end = () => clearInterval(timer.current!);

  // reducer ，集中式管理状态 -------------------------------------------------------------------
  interface ActionType {
    type: "INC" | "DEC" | "INC_N";
    payload?: number;
  }

  function countReducer(state: number, action: ActionType): number {
    switch (action.type) {
      case "INC":
        return state + 1;
      case "DEC":
        return state - 1;
      case "INC_N":
        return state + action.payload!;
      default:
        return state;
    }
  }

  // 参数：处理函数、默认值、初始化函数（可选，若传入，则返回值会覆盖默认值）
  const [cnt, cntDispatch] = useReducer(countReducer, 0);

  // immer --------------------------------------------------------------------
  const obj = {
    o1: {
      o2: {
        a: 0,
      },
    },
  };

  // 原始写法，非常繁琐，也容易写错
  // const [obj2, setObj2] = useState(obj);
  // function updateObj() {
  //   setObj2({
  //     ...obj2,
  //     o1: {
  //       ...obj2.o1,
  //       o2: {
  //         ...obj2.o1.o2,
  //         a: obj2.o1.o2.a + 1,
  //       },
  //     },
  //   });
  // }

  // useImmer 的实现原理和 useState 一样，只是使用上的区别
  const [obj1, setObj1] = useImmer(obj);
  function updateObj() {
    // 修改引用类型直接和 Vue 一样就行，修改基本类型和 useState 一样
    setObj1((draft) => {
      ++draft.o1.o2.a;
    });
  }

  // useImmerReducer
  function immerCntReducer(state: number, action: { type: "add" }) {
    // 修改基本类型和 useReducer 一样 return ；修改引用类型直接和 Vue 一样就行，不用 return ，改为 break
    switch (action.type) {
      case "add":
        return state + 1;
      default:
        break;
    }
  }

  const [immerCnt, immerCntDispatch] = useImmerReducer(immerCntReducer, 0);

  /**render 函数 ------------------------------------------------------------------------------
   * 必须有且只有一个根节点给 VDOM 插入；可以使用空标签 <> 或 <Fragment> ，这两个都不会被渲染，只作包裹作用
   * 空标签 <></> 不能有任何属性
   * Fragment 需要从 react 导入，可以且只能用 key 属性
   * 复杂的结构可以用小括号 () 包裹，更亲吸
   */
  return (
    <>
      {/* 差值语法 ------------------------------------------------------------------------ */}
      {/* 直接插入 html 变量 */}
      <p>{title1}</p>
      {/* 等价于 v-html ，不推荐 */}
      <p dangerouslySetInnerHTML={{ __html: title2 }}></p>

      {func("func")}

      <p>
        <button onClick={add}>add</button>
        <span>{count}</span>
      </p>

      {/* useRef -------------------------------------------------------------------*/}
      <p>
        <button onClick={start}>start</button>
        <button onClick={end}>end</button>
      </p>

      {/* reducer ---------------------------------------------------------------------------- */}
      <p>
        <button onClick={() => cntDispatch({ type: "DEC" })}>+</button>
        <button onClick={() => cntDispatch({ type: "INC" })}>+</button>
        <button onClick={() => cntDispatch({ type: "INC_N", payload: 2 })}>
          +2
        </button>

        <span>{cnt}</span>
      </p>

      {/* immer ------------------------------------------------------------------------- */}
      <p>
        <button onClick={updateObj}>update</button>
        <span>{obj1.o1.o2.a}</span>
      </p>

      <p>
        <button onClick={() => immerCntDispatch({ type: "add" })}>
          immer add
        </button>
        <span>{immerCnt}</span>
      </p>
    </>
  );
}

export default App;
```

### 1.2 样式、事件

与 Vue 区别：

- React 的 CSS ：
  
  - 使用第三方库 classnames 可以更方便绑定 class
  
  - CSS 是单独的文件，且没有 scoped；CSS Module 也是单独的 CSS 文件，且需要用 .module.css 命名

- React 的事件绑定：
  
  - 必须传入一个函数引用，而不像 Vue 和原生 JS 一样传入表达式
  
  - 会自动事件委派，所有事件都挂载到 root 中（React17 之前是 document）：
    
    ```
    // 查看 root 委派的事件
    getEventListeners(document.getElementById('root'))
    ```

示例：

```
pnpm add classnames
```

```
// /src/App.module.less

.box {
  width: 10px;
  height: 10px;
  border: 1px solid #000;
}
```

```
// /src/App.less

button,
span {
  margin-right: 10px;
}

.box {
  width: 20px;
  height: 20px;
  border: 1px solid #000;
}

.big {
  width: 40px;
  height: 40px;
}
```

```
// /src/App.tsx

import classnames from "classnames";

// 一个组件一个 CSS
import "./App.less";

// CSS Module
import Cls from "./App.module.less";

function App() {
  // 事件，React 把原生事件封装为合成事件，翻遍事件委托 ----------------------------------------------
  type BtnClickEvent = React.MouseEvent<HTMLLIElement>;

  const click1 = () => console.log("click1");
  const click2 = (e: BtnClickEvent) => console.log("click2", e);
  const click3 = (num: number) => console.log("click3", num);
  const click4 = (num: number, e: BtnClickEvent) => {
    console.log("click4", num, e);
  };

  return (
    <>
      {/* 样式绑定 --------------------------------------------------------------------- */}
      <div>
        <div className="box" style={{ backgroundColor: "#000" }}></div>
        <div className={`box ${Math.random() > 0.5 && "big"}`}></div>

        {/* classnames */}
        <div className={classnames({ box: true, big: true })}></div>

        {/* CSS Module */}
        <div className={`${Cls.box}`}></div>
      </div>

      {/* 事件绑定 ------------------------------------------------------------------------ */}
      <ul>
        {/* 必须传入一个函数引用 */}
        <li onClick={() => console.log("click0")}>click 0</li>

        {/* 无参 */}
        <li onClick={click1}>click 1</li>

        {/* 有参 */}
        <li onClick={click2}>click 2</li>
        <li onClick={() => click3(123)}>click 3</li>
        <li onClick={(e) => click4(123, e)}>click 4</li>
      </ul>
    </>
  );
}

export default App;
```

### 1.3 表单

与 Vue 区别：

- React 没有指令系统，也就没有 v\-model 

- React 的 text 、textarea 等表单 onChange 对应原生的 input 事件；也没有对应的 change 事件；radio 、checkbox 、select 等的 onChange 就对应原生 change

- React 中，把表单分为非受控组件、受控组件：
  
  * 非受控组件：改为绑定 defaultValue 、defaultChecked 属性，保留浏览器默认的表单行为（如 text 输入），但重新 render 后就不会更新表单的 value 、checked ，即非受控组件的值 React 不会管理，只能用户操作或 DOM 处理：
    
    * 由于保留了表单行为，如果边输入边更新状态，就和 Vue 表单差不多，只是状态更新不会处理非受控组件
    
    * 有些表单如 file 只能是非受控组件，不能转为受控组件
  - 受控组件：如 text 表单绑定 value 、onChange ，通过状态控制内容，和 Vue 的区别是 React 的受控组件不会保留浏览器的表单行为，如果不用 onChange 处理，表单的值无法更新，就会出现无法输入的情况
    
    * 受控组件的优点就是能保证状态和视图的一致性

示例：

```
import { useState, useRef, useId } from "react";

function App() {
  console.log("render");

  const [defaultText, setDefaultText] = useState("");
  const [text, setText] = useState("");
  const [agree, setAgree] = useState(true);

  // 生成唯一 id
  const checkboxId = useId();

  const inpRef = useRef<HTMLInputElement | null>(null);

  function textChange(e: React.ChangeEvent<HTMLInputElement>) {
    setText(e.target.value);

    // 在 onChange 中，无法用 DOM 的方式修改受控组件的值
    // inpRef.current!.value = e.target.value;
  }

  const clearDefaultText = () => setDefaultText("");

  const clear1 = () => setText("");
  // 可以这样用 DOM 方式修改受控组件，但应尽量避免这样做，因为这就和非受控组件一样状态和视图不一致了
  const clear2 = () => (inpRef.current!.value = "");

  return (
    <>
      <div>
        {/* 非受控组件，类似 Vue ，区别是状态更新时无法同步，除非是边输入边更新 */}
        <div>
          <input
            type="text"
            defaultValue={defaultText}
            onChange={(e) => setDefaultText(e.target.value)}
          />
          <span>{" " + defaultText}</span>
        </div>
        <div>
          <button onClick={clearDefaultText}>clear 内容依然存在</button>
        </div>

        {/* 受控组件，和 Vue 区别是必须用 onChange 更新状态才能正常输入 */}
        <div>
          <input type="text" ref={inpRef} value={text} onChange={textChange} />
          <span>{" " + text}</span>
        </div>
        <div>
          <button onClick={clear1}>clear1 正确做法</button>
          <button onClick={clear2}>clear2 内容亲空但状态未更新</button>
        </div>
      </div>

      <p>
        <label htmlFor={checkboxId}>
          <input
            type="checkbox"
            id={checkboxId}
            checked={agree}
            onChange={() => setAgree(!agree)}
          />
          <span>{" " + agree}</span>
        </label>
      </p>
    </>
  );
}

export default App;
```

受控组件优化，由于受控组件必须 onChange 处理才能继续输入，所以无论如何优化都会一直重新 render ，不能像 Vue 一样实现防抖的派发更新。常用的优化手段有：

* 防抖：
  
  ```
  import React, { useState, useEffect } from "react";
  
  // 方式一，逻辑防抖
  function useDebounce<T extends (...args: unknown[]) => unknown>(
    callback: T,
    deps: React.DependencyList,
    delay: number = 100
  ) {
    useEffect(() => {
      const timer = setTimeout(callback, delay);
      return () => clearTimeout(timer);
    }, deps);
  }
  
  // 方式二，返回防抖的 state
  function useDebounceState<T>(value: T, delay: number): T {
    const [debouncedValue, setDebouncedValue] = useState(value);
  
    useEffect(() => {
      const timer = setTimeout(() => setDebouncedValue(value), delay);
      return () => clearTimeout(timer);
    }, [value, delay]);
  
    return debouncedValue;
  }
  
  // 测试
  function App() {
    // console.log("render");
  
    // 方式一
    const [text1, setText1] = useState("text1");
    useDebounce(() => console.log("ajax", text1), [text1], 1000);
  
    // 方式二
    const [text2, setText2] = useState("text2");
    const debouncedText = useDebounceState(text2, 1000);
    useEffect(() => console.log("ajax", debouncedText), [debouncedText]);
  
    return (
      <>
        {/* 方式一 */}
        <input
          type="text"
          value={text1}
          onChange={(e) => setText1(e.target.value)}
        />
        <p>{text1}</p>
  
        {/* 方式二 */}
        <input
          type="text"
          value={text2}
          onChange={(e) => setText2(e.target.value)}
        />
        <p>{text2}</p>
        <p>{debouncedText}</p>
      </>
    );
  }
  
  export default App;
  ```

* useDeferredValue ，延迟状态更新，类似防抖，delay 由 React 随时根据运行环境自动确定，适合用于延迟单个的 state 更新：
  
  ```
  import { useState, useDeferredValue, useEffect } from "react";
  
  function App() {
    const [text, setText] = useState("text");
    const deferredText = useDeferredValue(text);
  
    useEffect(() => console.log("ajax", deferredText), [deferredText]);
  
    return (
      <>
        <input
          type="text"
          value={text}
          onChange={(e) => setText(e.target.value)}
        />
  
        <p>{text}</p>
        <p>{deferredText}</p>
      </>
    );
  }
  
  export default App;
  ```

* useTransition ，用于管理过度状态，在不阻塞 UI 的情况下更新状态，适合用于需要耗费大量性能的状态更新，如列表渲染大量数据、tab 切换后展示大量数据等，提供过渡状态的 boolean ，用于提高用户体验。
  
  本质是把过度的状态的优先级降低：
  
  ```
  import { useState, useTransition } from "react";
  
  function App() {
    const [text, setText] = useState("");
    const [list, setList] = useState<string[]>([]);
  
    const [isPending, startTransition] = useTransition();
  
    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const value = e.target.value;
      setText(value);
  
      // 异步处理大量数据，避免阻塞 UI ，注意  startTransition 回调内不能有异步代码，但  startTransition 可以再异步代码内
      startTransition(() => {
        const items = Array.from({ length: 1000 }, (_, i) => `${value} - ${i}`);
        setList(items);
  
        console.log("ok");
      });
  
      // 如果直接更新 list ，且这个状态更新需要耗费大量时间，就会阻塞 UI 渲染，无法继续输入
      // const items = Array.from({ length: 1000 }, (_, i) => `${value} - ${i}`);
      // setList(items);
    };
  
    return (
      <div>
        <input type="text" value={text} onChange={handleChange} />
        {isPending && <p>Loading...</p>}
        <ul>
          {list.map((item, i) => (
            <li key={i}>{item}</li>
          ))}
        </ul>
      </div>
    );
  }
  
  export default App;
  ```

### 1.4 条件渲染、列表渲染

与 Vue 区别：

* 没有类似 v\-show 的语法，但可以绑定样式实现

* 引用类型的状态修改需要传入新引用，较为繁琐，可以使用扩展运算符、或返回新引用的纯函数等处理

```
// /src/App.tsx

import { useState } from "react";

function App() {
  // 条件渲染 ------------------------------------------------------------------------------
  const [isShow, setIsShow] = useState(true);
  const switchShow = () => setIsShow(!isShow);

  // 列表渲染 ---------------------------------------------------------------------------------
  interface ListItem {
    id: string;
    text: string;
  }

  // useState 不会修改原始数据
  const data = [{ id: "0", text: "0" }];
  const [list, setList] = useState(data);

  const pushList = () => {
    const newText = list.length ? Number(list.at(-1)!.text) + 1 + "" : "0";
    setList([...list, { id: newText, text: newText }]);
  };

  function sortList() {
    const newArr = [...list].sort(
      (a: ListItem, b: ListItem) => Number(a.text) - Number(b.text)
    );

    setList(newArr);
  }

  function deleteItem(index: number) {
    const newArr = list.filter((_, iIndex) => iIndex !== index);
    // const newArr = [...list.slice(0, index), ...list.slice(index + 1)];

    setList(newArr);
  }

  function insertItem(index: number) {
    const text = list[index].text;
    const id = list[index].id + Date.now();

    setList([...list.slice(0, index), { id, text }, ...list.slice(index)]);
  }

  function addItem(text: string) {
    setList(
      list.map((item: ListItem) => {
        if (item.text === text) {
          return { ...item, text: Number(item.text) + 1 + " " };
          // return Object.assign({}, item, { text: Number(item.text) + 1 + " " });
        }

        return item;
      })
    );
  }

  return (
    <>
      {/* 条件渲染 */}
      <div>
        <button onClick={switchShow}>switch</button>

        {isShow && <div>类似 v-if</div>}
        {isShow ? <div>类似 v-if</div> : <></>}

        <div style={{ display: isShow ? "inline" : "none" }}>类似 v-show</div>
      </div>

      {/* 列表渲染 */}
      <ul>
        <li>
          <button onClick={pushList}>push</button>
          <button onClick={sortList}>sort</button>
        </li>

        {list.map((item, index) => {
          return (
            <li key={item.id}>
              <span>{item.text + " "}</span>

              <button onClick={() => deleteItem(index)}>delete</button>
              <button onClick={() => insertItem(index)}>insert</button>
              <button onClick={() => addItem(item.text)}>+</button>
            </li>
          );
        })}
      </ul>
    </>
  );
}

export default App;
```

### 1.5 缓存状态、生命周期、hook

与 Vue 区别：

* React 的 useMemo 用于缓存状态，依赖项变化就会重新执行，类似 Vue 的 computed 、updated/nextTick 、watch

* React 的 useEffect 主要用于处理副作用，因为如果副作用如 ajax 、定时器等放在 render 函数顶层，那么每次重新 render 都会产生新的副作用
  
  * 也可以实现生命周期，或类似 Vue 的 watch ，但与 Vue 不同的是 useEffect 的处理函数是异步的，不阻塞主线程，在渲染完成后执行
  * useLayoutEffect ：与 useEffect 的唯一区别就是处理函数是同步执行的，真正的声明周期，如 mounted 时和 Vue 一样真实 DOM 已经插入，准备异步渲染 ，而 useEffect 渲染完成才会执行
  * useLazyEffect ：自定义 hook ，mounted 不执行，updated 才执行

* useMemo 、useEffect 等 hook 的依赖项变化时就会重新执行处理函数；
  
  * 依赖项不一定需要状态，普通的变量引用变化也会重新执行，所以飞状态的依赖项必须是引用类型（这种情况一般用于重新 render 后引用变化重新执行 effect）
  
  * useRef 、以及空依赖项 useMemo 、useCallback 等 hook 的返回值会缓存，作为依赖项等价于空数组
  
  * 具体执行时机：
    
    * 最开始 mounted 会执行一次，等价于依赖项为空数组的情况
    
    * 依赖项默认为 undefined 则依赖所有状态和普通引用类型，等价于 mounted \+ updated/nextTick
    
    * 设置依赖项等价于 mounted \+ watch

* React 的 hook 规范中约定只能用在组件内或 hook 内，且只能用在函数体顶层，自定义 hook 也规范约定用 useXxx 命名：而 Vue 的 hook 几乎可以用在任何位置

示例：

```
// /src/App.tsx

import {
  useState,
  useMemo,
  useEffect,
  useLayoutEffect,
  useRef,
  useCallback,
  useDebugValue,
} from "react";

// 自定义 hook ，如实现 useLazyEffect
function useLazyEffect(
  effect: () => void | (() => void),
  deps: React.DependencyList,
  trigger: boolean | null = null
) {
  const isTrigger = useRef(false);

  // 若传入可选参数 trigger 则可以更精细控制执行时机
  useEffect(() => {
    if (trigger !== null) isTrigger.current = trigger;
  }, [trigger]);

  // 可以在 React devtool 中调试这个 value
  // useDebugValue(trigger);

  useEffect(() => {
    if (!isTrigger.current && trigger === null) {
      isTrigger.current = true;
    } else if (isTrigger.current) return effect();

    return;
  }, [trigger, ...deps]);
}

function App() {
  const [count, setCount] = useState(1);

  // useMemo --------------------------------------------------------------------------------
  const doubleCount = useMemo(() => {
    // console.log("useMemo");
    return count * 2;
  }, [count]);

  /**useEffect ，一个 Hook 多个用途 ---------------------------------------------------------------
   * undefined ：类似 Vue 的 mounted + updated/nextTick
   * [] ：类似 Vue 的 mounted
   * [state] ：类似 Vue 的 mounted + watch
   */
  // const testVar = 0;
  // const testFunc1 = () => [];
  // const testFunc2 = useCallback(testFunc1, []);
  // const testFunc3 = useMemo(testFunc1, []);
  // const testFunc4 = useRef(testFunc1);

  useEffect(
    // 处理函数
    () => {
      console.log("mounted 、updatedt");

      // 清理函数（卸载函数），可选，类似 Vue 的 beforeUpdate + beforeUnMount
      return () => console.log("beforeUpdate 、beforeUnmount");
    },

    // 类似 mounted + updated
    [count]
    // [testFunc1]

    // 等价于 []
    // [testVar, testFunc2, testFunc3, testFunc4]
  );

  // useLayoutEffect ----------------------------------------------------------------------------
  useLayoutEffect(() => {
    // const now = Date.now();
    // while (Date.now() - now < 3000);
    console.log("LayoutEffect");
  });

  // useLazyEffect ----------------------------------------------------------------------------
  const [flag, setFlag] = useState(false);

  useLazyEffect(() => {
    console.log("lazy");
    return () => console.log("clear");
  }, [flag]);

  useEffect(() => {
    setTimeout(() => setFlag(true), 1000);
  }, []);

  return (
    <>
      <p>
        <button onClick={() => setCount(count + 1)}>add</button>
        <span>{" " + count}</span>
        <span>{" " + doubleCount}</span>
      </p>
    </>
  );
}

export default App;
```

useSyncExternalStore ，用于订阅浏览器的事件，控制派发更新，封装复杂逻辑：

```
import { useSyncExternalStore } from "react";

// 实现 history 不刷新跳转 -------------------------------------------------------------------
function useHistory() {
  // let testOldObj = { url: "asdf" };

  const url = useSyncExternalStore(
    // subscribe
    (trigger) => {
      window.addEventListener("popstate", trigger);
      return () => window.removeEventListener("popstate", trigger);
    },

    // getSnapshot ，快照，即返回的值
    () => {
      // 有缓存功能，会比较 return 的新旧 value ，不同就更新
      return location.href;

      // 注意引用类型不要直接 return ，不然每次的引用都不同，需要自己判断处理是否 return 新引用，避免无限 render
      // if (testOldObj.url !== location.href) {
      //   const testNewObj = { url: location.href };
      //   testOldObj = testNewObj;
      //   return testNewObj;
      // } else return testOldObj;
    }
  );

  const push = (path: string) => {
    history.pushState({}, "", path);

    // pushState 、replaceState 不会触发 popstate 事件，需要手动触发，返回新的快照，更新视图
    window.dispatchEvent(new PopStateEvent("popstate"));
  };

  const replace = (path: string) => {
    history.replaceState({}, "", path);
    window.dispatchEvent(new PopStateEvent("popstate"));
  };

  return [url, push, replace] as const;
}

// 实现 storage 同源实时通信 ---------------------------------------------------------------------
function useStorage<T>(key: string, initialValue: T, callback?: () => void) {
  const value = useSyncExternalStore(
    (trigger) => {
      const handle = () => {
        trigger();
        callback?.();
      };

      window.addEventListener("storage", handle);
      return () => window.removeEventListener("storage", handle);
    },

    () => JSON.parse(localStorage.getItem(key) || "null") ?? initialValue
  );

  const setValue = (newValue: T) => {
    localStorage.setItem(key, JSON.stringify(newValue));
    window.dispatchEvent(new StorageEvent("storage"));
  };

  return [value, setValue];
}

// 测试 ---------------------------------------------------------------------------------------
function App() {
  const [url, push, replace] = useHistory();

  const [count, setCount] = useStorage("testhookaa", 0, () =>
    console.log("ok")
  );

  return (
    <>
      <p>
        <button onClick={() => push("/about")}>push</button>
        <button onClick={() => replace("/profile")}>replace</button>
        <span>{" " + url}</span>
      </p>

      <p>
        <button onClick={() => setCount(count + 1)}>add</button>
        <button onClick={() => setCount(0)}>clear</button>
        <span>{" " + count}</span>
      </p>
    </>
  );
}

export default App;
```

## 2 组件

### 2.1 父子组件通信、插槽、

与 Vue 区别：

* JSX 中，大驼峰的标签即组件，所以 react 的组件库才可以直接使用 \<button\> ；而 Vue 支持 "\-" 的标签写法，会全部转为小写和 \- 连接，所以 Vue 的组件库才会有类似 \<el\-button\> 的写法，否则 \<Button\> 会变为 \<button\>

* 子组件不需要注册
- 父子组件通信、插槽都是通过 props

示例：

```
// 子组件

export type OnAddArgs = number;

interface Props {
  // 父子组件通信
  count: number;
  onAdd: (oldCount: OnAddArgs) => void;

  // 默认插槽，必须是 children
  children?: React.ReactNode;
  // 具名插槽，接收一个 render 函数
  slotA?: (msg: string) => React.ReactNode;
}

export interface Cpn2Ref {
  cpn2Current: HTMLDivElement | null;
  inpCurrent: HTMLInputElement | null;
  inputFocus: () => void;
}

// 也可以用 React.FC ，区别是 FC 在老版本会多一些属性如 children ，但新版本都去除了，基本没啥区别
// const Cpn: React.FC<Props> = (props) => {};
function Cpn(props: Props) {
  console.log(props.count);

  return (
    <>
      <div>
        <button onClick={() => props.onAdd(props.count)}>add</button>
        <span>{" " + props.count}</span>
      </div>
      {props.children}
      {props.slotA?.("asdf")}
    </>
  );
}

export default Cpn;
```

```
// 父组件

import { useState } from "react";
import Cpn from "./Cpn";
import type { OnAddArgs } from "./Cpn";

function App() {
  // 父子组件通信
  const [count, setCount] = useState(0);
  const onAdd = (e: OnAddArgs) => setCount(e + 1);

  // 插槽
  const defaultSlot = <h1>default slot</h1>;
  const slotA = (msg: string) => {
    console.log("作用域插槽", msg);
    return <h1>has name slot</h1>;
  };

  // const p = { count, onAdd, slotA, children: defaultSlot };

  return (
    <>
      <Cpn count={count} onAdd={onAdd} slotA={slotA}>
        {defaultSlot}
      </Cpn>

      {/* 默认插槽也可以 props 形式传入，若此时子组件标签写了 html ，则会覆盖 props 的 childern */}
      {/* 
      <Cpn count={count} onAdd={onAdd} slotA={slotA} children={defaultSlot}>
        <h1>123</h1>
      </Cpn> 
      */}

      {/* props 解构简写 */}
      {/* <Cpn {...p}></Cpn> */}
    </>
  );
}

export default App;
```

### 2.2 Context

React 中用于全局状态共享的机制，可以实现任意组件通信：

```
import { useState, createContext, useContext } from "react";

interface State {
  count: number;
  add: () => void;
}

const Context = createContext<State | null>(null);

function Cpn1() {
  const context = useContext(Context);

  return (
    <>{context ? <button onClick={() => context.add()}>add</button> : "Cpn1"}</>
  );
}

function Cpn2() {
  const context = useContext(Context);

  return <>{context ? " " + context.count : " Cpn2"}</>;
}

function App() {
  const [count, setCount] = useState(0);
  const value: State = {
    count,
    add: () => setCount(count + 1),
  };

  return (
    <>
      {/* 直接使用 context ，则使用默认值，这里是 null //{" "} */}
      {/* 
      <p>
        <Cpn1 />
        <Cpn2 />{" "}
      </p> 
      */}

      {/* 使用 Context 的器组件，注入数据，覆盖默认值 */}
      {/* React19 后可以省略 .Provider */}
      <Context.Provider value={value}>
        <Cpn1 />
        <Cpn2 />
      </Context.Provider>
    </>
  );
}

export default App;
```

配合 useReducer 可以实现一个全局状态管理工具：

```
// /src/context/reducer.ts

// 状态类型
type State = {
  count: number;
  text: string;
};

// 动作类型
type Action =
  | { type: "INC" }
  | { type: "DEC" }
  | { type: "SET_TEXT"; payload: string };

// 初始状态
const initState: State = { count: 0, text: "text" };

// Reducer 函数
function counterReducer(state: State, action: Action): State {
  switch (action.type) {
    case "INC":
      return { ...state, count: state.count + 1 };
    case "DEC":
      return { ...state, count: state.count - 1 };
    case "SET_TEXT":
      return { ...state, text: action.payload };
    default:
      return state;
  }
}

export { initState, counterReducer };
export type { State, Action };
```

```
// /src/context/context.ts

import { createContext } from "react";
import type { Dispatch } from "react";
import type { State, Action } from "./reducer.ts";

// 创建 Context
const StateContext = createContext<State | null>(null);
const ActionContext = createContext<Dispatch<Action> | null>(null);

export { StateContext, ActionContext };
```

```
// /context/hooks.ts

import { useContext } from "react";
import type { Dispatch } from "react";

import { StateContext, ActionContext } from "./context.ts";
import type { State, Action } from "./reducer.ts";

// // useContext 强制使用器组件
function useMyContext(): [State, Dispatch<Action>] {
  const state = useContext(StateContext);
  const dispatch = useContext(ActionContext);
  if (state === null || dispatch === null) throw new Error("必须使用 Provider");

  return [state, dispatch];
}

export { useMyContext };
```

```
// /src/context/index.tsx

import { useReducer } from "react";
import { initState, counterReducer } from "./reducer.ts";
import { StateContext, ActionContext } from "./context.ts";

// 器组件
const ContextProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [state, dispatch] = useReducer(counterReducer, initState);

  return (
    {/* 若嵌套相同的 Context 则使用最底层的 value ；若嵌套不同的 Context 则都可以使用 */}
    <StateContext.Provider value={state}>
      <ActionContext.Provider value={dispatch}>
        {children}
      </ActionContext.Provider>
    </StateContext.Provider>
  );
};

export default ContextProvider;
```

```
// /src/main.tsx

import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App.tsx";
import ContextProvider from "./context";

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <ContextProvider>
      <App />
    </ContextProvider>
  </StrictMode>
);
```

```
// 使用

import { useMyContext } from "./context/hooks";

function Cpn1() {
  const [state, dispatch] = useMyContext();

  return (
    <div>
      <div>
        {" "}
        <input
          type="text"
          value={state.text}
          onChange={(e) =>
            dispatch({ type: "SET_TEXT", payload: e.target.value })
          }
        />
      </div>

      <div>
        <button onClick={() => dispatch({ type: "DEC" })}>-</button>
        <button onClick={() => dispatch({ type: "INC" })}>+</button>
      </div>
    </div>
  );
}

function Cpn2() {
  const [state] = useMyContext();

  return (
    <p>
      <span>{state.count}</span>
      <span>{" " + state.text}</span>
    </p>
  );
}

function App() {
  return (
    <>
      <Cpn1 />
      <Cpn2 />
    </>
  );
}

export default App;
```

### 2.3 获取子组件实例、DOM

与 Vue 区别：

* 子组件的 DOM 也需要主动暴漏，父组件才能获取

```
// 子组件

import { forwardRef, useRef, useImperativeHandle } from "react";

/**获取子组件实例
 * 需要 forwardRef ，父组件才能获取
 * 泛型：ref 类型、props 类型
 * args：_ 即 props ，ref：父组件传入的 ref
 */
export type Cpn1Ref = HTMLDivElement;

export const Cpn1 = forwardRef<Cpn1Ref>((_, ref) => {
  return <div ref={ref}>Cpn1</div>;
});

/**若需要暴漏其他资源，则需要 useImperativeHandle ，args：
 * ref ：父组件传入的 ref
 * 处理函数：return 一个对象，用于暴漏资源
 * 依赖项（可选）
 */
export interface Cpn2Ref {
  cpn: HTMLDivElement | null;
  func: () => void;
}

export const Cpn2 = forwardRef<Cpn2Ref>((_, ref) => {
  const cpnRef = useRef<HTMLDivElement | null>(null);

  const func = () => console.log("func");

  useImperativeHandle(ref, () => ({
    cpn: cpnRef.current,
    func,
  }));

  // 使用 useImperativeHandle 后，把父组件传入的 ref 绑定到子组件是无效的，只能主动暴漏出去
  return <div ref={cpnRef}>Cpn2</div>;
});

// React19 新特性，废弃 forwardRef ，把 ref 放到了 props 中
export interface Cpn3Ref {
  cpn: HTMLDivElement | null;
  name: string;
}

interface Props {
  ref?: React.Ref<Cpn3Ref>;
}

export const Cpn3 = ({ ref }: Props) => {
  const cpnRef = useRef<HTMLDivElement | null>(null);

  useImperativeHandle(ref, () => ({
    cpn: cpnRef.current,
    name: "Cpn3",
  }));

  return <div ref={cpnRef}>Cpn3</div>;
};

// 父组件获取不到 Cpn4 的组件实例
export function Cpn4() {
  return <div>Cpn4</div>;
}
```

```
// 父组件

import { useRef, useEffect } from "react";
import { Cpn1, Cpn2, Cpn3, Cpn4 } from "./Cpn";
import type { Cpn1Ref, Cpn2Ref, Cpn3Ref } from "./Cpn";

function App() {
  const divRef = useRef<HTMLDivElement | null>(null);

  const cpn1Ref = useRef<Cpn1Ref | null>(null);
  const cpn2Ref = useRef<Cpn2Ref | null>(null);
  const cpn3Ref = useRef<Cpn3Ref | null>(null);

  const cpn4Ref = useRef(null);

  useEffect(() => {
    // <div>
    console.log(divRef.current);
    console.log(cpn1Ref.current);

    console.log(cpn2Ref.current);
    cpn2Ref.current!.func();

    console.log(cpn3Ref.current);

    // null
    console.log(cpn4Ref.current);
  }, []);

  return (
    <>
      <div ref={divRef}>test</div>

      <Cpn1 ref={cpn1Ref} />
      <Cpn2 ref={cpn2Ref} />
      <Cpn3 ref={cpn3Ref} />

      {/* eslint-disable-next-line @typescript-eslint/ban-ts-comment */}
      {/* @ts-ignore */}
      <Cpn4 ref={cpn4Ref} />
    </>
  );
}

export default App;
```

### 2.4 特殊组件

（1）缓存组件

只有 props 变化才会重新 render ：

```
// 子组件

import { memo } from "react";

interface MemoProps {
  count?: number;
  arr?: number[];
  fn?: () => void;
}

// 缓存组件，只有 props 变化了才会重新 render ，底层用 Object.is() 判断
const MemoCpn = memo((props: MemoProps) => {
  console.log("memo cpn render");
  return <>{props.count}</>;
});

export default MemoCpn;
```

```
// 父组件

import { useState, useMemo, useCallback } from "react";
import Cpn from "./Cpn";

function App() {
  console.log("father render");
  const [flag, setFlag] = useState(false);
  const renderFather = () => setFlag(!flag);

  // let cnt = 0;
  // let a = [0];
  // let f = () => {};

  // const memoA = useMemo(() => a, []);
  // const memoF = useCallback(f, []);

  // const [count, setCount] = useState(0);
  const [arr, setArr] = useState([1]);

  function updateProps() {
    // ++cnt;
    // a = [0];
    // f = () => {};

    // setCount(count + 1);
    setArr([...arr, 2]);
  }

  return (
    <>
      <button onClick={renderFather}>render Father</button>
      <button onClick={updateProps}>update props</button>

      {/**非状态变量
       *  修改不是响应式的，不会重新 render 任何组件
       * 若修改其他状态导致父组件重新 render ：
         - 若是基本类型，父组件重新 render 初始值不变，props 不变，就不会重新 render 缓存组件
         - 若是引用类型，父组件重新 render ，引用改变，props 就变了，就重新 render 缓存组件
           - 这种情况可以用 useMemo 、useCallback 缓存非状态的引用类型解决
       */}
      {/* <Cpn count={cnt} /> */}
      {/* <Cpn arr={a} /> */}
      {/* <Cpn fn={f} /> */}
      {/* <Cpn arr={memoA} /> */}
      {/* <Cpn fn={memoF} /> */}

      {/**状态
       *  状态变化，重新 render 父组件，props 也变了，就重新 render 缓存组件
       * 若修改其他状态导致父组件重新 render ，基本类型的值/引用类型的引用都不变，就不会重新 render 缓存组件
       */}
      {/* <Cpn count={count} /> */}
      <Cpn arr={arr} />
    </>
  );
}

export default App;
```

（2）全局组件

React 没有提供全局组件的 API ，可以参考 ant\-design 的做法，把函数挂载到 window 中，调用这个函数渲染组件：

```
// /src/components/Message/index.tsx

import "./index.less";

// 给 window 扩充类型
declare global {
  interface Window {
    showMsg: (text?: string) => void;
  }
}

function Message(props: { text: string }) {
  return <div className="message">{props.text}</div>;
}

export default Message;
```

```
// /src/components/index.tsx

import { createRoot } from "react-dom/client";
import Message from "./Message";

window.showMsg = (text: string = "message") => {
  // 创建一个容器
  const container = document.createElement("div");
  document.body.appendChild(container);

  // 注册根组件 ，并 render
  createRoot(container!).render(<Message text={text} />);

  // 清除
  setTimeout(() => document.body.removeChild(container), 3000);
};
```

```
// /src/main.tsx
import "./components/index.tsx";
```

（3）异步组件

懒加载，会分包，与 Vue 区别：

* 懒加载只能导入默认导出的组件，但由于 React 在 tsx 文件可以导出多个组件，所以懒加载非默认导出的组件需要 then 内处理

* 懒加载同一个 tsx 文件的多个组件也只会打包为一个分包；且这些组件最好都放在 Suspense 中，只要其中一个没有在 Suspense 中，都会阻塞父组件的渲染，且最终的 loading 时间都是最晚渲染完成的那个组件的时间，即使在不同的 Suspense 中

* 基于以上情况，一个 tsx 文件最好只对应一个组件

示例：

```
// 子组件

import { useLayoutEffect } from "react";

function Cpn1() {
  useLayoutEffect(() => {
    const now = Date.now();
    while (Date.now() - now < 3000);
  }, []);

  return <p>Cpn1</p>;
}

export function Cpn2() {
  return <p>Cpn2</p>;
}

export default Cpn1;
```

```
// 父组件

import { lazy, Suspense } from "react";

// 懒加载组件会分包
const Cpn1 = lazy(() => import("./Cpn"));
// 懒加载非默认导出的组件
const Cpn2 = lazy(() =>
  import("./Cpn").then((module) => ({ default: module.Cpn2 }))
);

function App() {
  return (
    <>
      <p>App</p>

      {/* 和 Vue 一样，直接使用懒加载组件，会阻塞父组件的渲染 */}
      {/* <Cpn1 /> */}

      {/* 注意，若直接使用非默认导出的懒加载组件，即使使用了 Suspense 处理 Cpn1 ，Cpn1 也会阻塞父组件渲染 */}
      {/* <Cpn2 /> */}

      {/* 和 Vue 的 Suspense 一样，不会阻塞父组件渲染 */}
      <Suspense fallback={<div>loading...</div>}>
        <Cpn1 />
        <Cpn2 />
      </Suspense>
    </>
  );
}

export default App;
```

关于 async ：

* React 客户端渲染的组件都不能用 async 修饰

* React 内置 hook 若有处理函数，都不能用 async 修饰

* 若需要使用类似 await 简化异步的逻辑并实现异步组件，可以使用 Suspense \+ React19 的 use ，同样的和 await 一样也会等待 Promise 结束后再执行下面的代码：
  
  ```
  import React, { use, Suspense } from "react";
  
  function fetchData() {
    return new Promise<string>((resolve, reject) => {
      setTimeout(() => {
        resolve("ok");
        // reject("err");
      }, 2000);
    });
  }
  
  const promise = fetchData();
  
  // rejected 组件，只能写成类组件
  class ErrorBoundary extends React.Component<{ children?: React.ReactNode }> {
    state = { hasError: false, error: null };
  
    // 接收 reject() 的内容
    static getDerivedStateFromError(error: any) {
      return { hasError: true, error };
    }
  
    render() {
      if (this.state.hasError) {
        return <div>错误：{this.state.error}</div>;
      }
  
      return this.props.children;
    }
  }
  
  function Cpn() {
    /**use
     * 和 hook 一样只能在组件顶层、hook 顶层使用
     * 接收一个 Promise ，返回 Promise 完成的结果
     * 有缓存功能，组件重新 render 时，use 会判断前后 Promise 的引用是否相同，不同就会重新执行 use ，所以为了防止无限 render ， fectData 需要再组件外部执行
     * 会根据 Promise 的泛型自动推导 data 类型 
    */
    const data = use(promise);
  
    return <div>{data}</div>;
  }
  
  function App() {
    return (
      <ErrorBoundary>
        <Suspense fallback={<div>加载中...</div>}>
          <Cpn />
        </Suspense>
      </ErrorBoundary>
    );
  }
  
  export default App;
  ```

（4）传颂 API

类似 Vue 的 Teleport ：

```
import { createPortal } from "react-dom";

function App() {
  return <>{createPortal(<div>msg</div>, document.body)}</>;
}

export default App;
```

（5）高阶组件

HOC ，参数或返回值是组件的函数，有了 hook 后比较少用了：

```
// 高阶组件命名规范用 with
const withAuth = <P extends object>(role: string, Component: React.FC<P>) => {
  return function (props: P) {
    if (role === "admin") return <Component {...props} />;
    else return <h1>无权限</h1>;
  };
};

const Cpn1 = withAuth<{ title: string }>("admin", (props) => {
  return <>Cpn1: {props.title}</>;
});

const Cpn2 = withAuth("xxx", () => {
  return <>Cpn2</>;
});

function App() {
  return (
    <>
      <Cpn1 title="asdf" />
      <Cpn2 />
    </>
  );
}

export default App;
```

（6）类组件

React 16.8 以前的语法，新版本依然支持，但不推荐：

```
import { Component } from "react";

interface Props {
  count: number;
  add: () => void;
}

class Cpn extends Component<Props> {
  render() {
    return (
      <>
        <button onClick={this.props.add}>add</button>
        <span>{" " + this.props.count}</span>
      </>
    );
  }
}

class App extends Component {
  state = {
    count: 0,
  };

  add = () => {
    this.setState(
      // 语法糖，类组件修改 state 可以只传入修改的状态，会转化为传入新引用
      {
        count: this.state.count + 1,
      },

      // 相当于 useEffect 中获取最新状态
      () => {
        console.log(this.state.count);
      }
    );
  };

  // 生命周期
  // constructor() {}
  // componentWillMount() {}
  // componentDidMount() {}
  // render() {}
  // componentWillReceiveProps() {}
  // shouldComponentUpdate() {}
  // componentWillUnmount() {}
  // componentDidUpdate() {}
  // componentWillUnmount() {}

  render() {
    // return <Cpn {...(this.state, this.add)} />;
    return <Cpn {...this.state} add={this.add} />;
  }
}

export default App;
```

## 3 生态

### 3.1 React Router

有框架模式和库模式：

* 框架模式：react\-router 自己的脚手架创建项目，不常用

* 库模式：分为数据模式、声明模式

库模式：

```
# pnpm add react-router-dom
```

（1）基本

与 Vue 区别：

* 模式多一个 static 模式，用于 SSR

* 跳转：
  
  * 声明式导航：三种，
    
    * Link 类似 Vue 的 router\-link 
    
    * NavLink 是 Link 的增强版，跳转时会保存状态信息，也带有一些 class 类名如激活态
    
    * Navigate 用于重定向
  
  * 编程式导航：useNavigate 最常用，redirect 用于 loader 中

* 传参方式多一个 state ，参数不显示在 url 中，参数仅当前会话保存，刷新后依然存在，但是分享后打开就不在了

* 路由懒加载有两种方式：
  
  - lazy + Suspense ，和 Vue 一样
  
  - 路由配置项 lazy 传入函数，函数内部动态 import ，这种方式缺点是会卡在 from ，只有 to 渲染完成才会跳转，可以用 useLocation 但只能在嵌套路由中解决

方式一，推荐，数据模式，拥有 router 全部功能：

```
// /src/router/index.tsx

/*模式*
 * createBrowserRouter 是 history 模式
 * createHashRouter 是 hash 模式
 * createMemoryRouter 是 memory 模式
 * createStaticRouter React 独有，用于 SSR
 */
import { createBrowserRouter, Navigate } from "react-router-dom";

// 同步导入
import Home from "../views/Home";

// 路由懒加载方式一
import { lazy, Suspense } from "react";
const About = lazy(() => import("../views/About"));
const AboutA = lazy(() => import("../views/About/children/AboutA"));
// const AboutB = lazy(() => import("../views/About/children/AboutB"));
const Profile = lazy(() => import("../views/Profile"));
// 自定义 loading 组件，用于路由懒加载
export function LazyLoad(props: { children: React.ReactNode }) {
  return <Suspense fallback={<div>loading...</div>}>{props.children}</Suspense>;
}

// 懒加载方式二，不推荐，缺点是会卡在 from ，直到 to 渲染完成才会跳转
// 虽然可以用 useNavigation().state === "loading" 判断并条件渲染 loading 、Outlet 解决，但也只能用在嵌套路由中
const myLazy = (url: string) => {
  return async () => {
    const cpn = await import(url);
    return {
      Component: cpn.default,
    };
  };
};

const aboutb = myLazy("../views/About/children/AboutB");

// 路由配置
const router = createBrowserRouter([
  // 默认路由
  {
    path: "/",
    element: <Navigate to="/home" />,
  },

  {
    path: "/home",

    // 两种方式，element 更灵活 ，如果用 Component 则可以写成 ts 文件而不用 tsx
    element: <Home />,
    // Component: Home,
  },

  /**嵌套路由
   * 布局路由：不配置父路由的 path ，跳转时 url 可以直接用子路由 path ，不常用
   * 前缀路由：不配置父路由的 element ，相当于给普通路由 url 加了个 path 前缀，不常用
   * 最常用的还是下面的写法
   */
  {
    path: "/about",

    // 副路由可以不用 Suspense ，一般副路由组件都比较小，用了 Suspense 反而会阻塞副路由渲染
    element: <About />,

    children: [
      // 索引路由，级子路由的默认路由
      {
        index: true,
        element: (
          <LazyLoad>
            <AboutA />
          </LazyLoad>
        ),
      },

      {
        path: "aboutb",
        lazy: aboutb,
      },
    ],
  },

  // 动态路由，可以配置多一个无参路由实现可选参数
  {
    path: "profile",
    element: (
      <LazyLoad>
        <Profile />
      </LazyLoad>
    ),
  },
  {
    path: "profile/:id",
    element: (
      <LazyLoad>
        <Profile />
      </LazyLoad>
    ),
  },

  // 404
  {
    path: "*",
    element: <div>404</div>,
  },
]);

export default router;
```

```
// /src/App.tes

import { RouterProvider } from "react-router-dom";
import router from "./router";

function App() {
  return (
    <>
      {/* 初始化 + 使用 Outlet （Outlet 类似 router-view）*/}
      <RouterProvider router={router} />
    </>
  );
}

export default App;
```

```
// /src/views/Home/index.tsx ，路由跳转

import { Link, useNavigate } from "react-router-dom";

function Home() {
  const navigate = useNavigate();

  // 编程式导航
  function toProfile() {
    const query = new URLSearchParams({ a: "1", b: "2" }).toString();

    // replace 默认为 false
    navigate("/profile/123?" + query, {
      replace: false,
      state: { c: 3, d: 4 },
    });

    // 前进后退
    // navigate(1);
    // navigate(-1);
  }

  return (
    <>
      <p>Home</p>

      {/* 声明式导航 */}
      <p>
        <Link to="/about">to about</Link>
      </p>
      <p>
        <Link to="/about/aboutb"> to About b</Link>
      </p>
      <p>
        <Link to="/profile/123?a=1&b=2">to Profile</Link>
      </p>
      <p>
        <Link to="/profile/123" state={{ c: 3, d: 4 }}>
          to Profile by state
        </Link>
      </p>

      {/* 编程式导航 */}
      <p>
        <button onClick={toProfile}>to Profile</button>
      </p>
    </>
  );
}

export default Home;
```

```
// /src/views/Profile/index.tsx ，获取 path 、参数

import { useParams, useSearchParams, useLocation } from "react-router-dom";

function Profile() {
  /**path、参数等信息
   * 参数有 3 种，params、search、state
   * params 、search 直接通过 path 传入
   * state 参数通过 state 配置项传入，不会影响 url
   */
  // 没有则 undefined
  const { id } = useParams();

  // 没有则 null ，setSearch 用于修改 url search 参数
  const [search, setSearch] = useSearchParams();
  const a = search.get("a");
  const b = search.get("b");

  // 没有则 undefined
  const loc = useLocation();
  const { pathname, state } = loc;
  const c = state?.c;
  const d = state?.d;

  return (
    <div>
      <p>Profile</p>

      <p>{`params: ${id}`}</p>
      <p>{`search: ${a} ${b}`}</p>
      <p>{`state: ${c} ${d}`}</p>

      <p>{`pathname: ${pathname}`}</p>
    </div>
  );
}

export default Profile;
```

```
// /src/views/About/index.tsx ，嵌套路由需要使用 <Outlet />

import { Outlet, useOutlet } from "react-router-dom";

function About() {
  // 获取该路由的嵌套路由对象，没有嵌套路由就返回 null
  console.log(useOutlet());

  return (
    <>
      <p>About</p>
      <Outlet />
    </>
  );
}

export default About;
```

```
// /src/views/About/children/AboutA/index.tsx ，获取路由信息

import {
  useMatch,
  useInRouterContext,
  useNavigationType,
  useResolvedPath,
} from "react-router-dom";

function AboutA() {
  // 获取某个路由的 match 信息
  console.log(useMatch("/about"));

  // 判断该组件是否在 RouterProvider 组件内，返回布尔值哦
  console.log(useInRouterContext());

  // 判断是什么方式进入的该路由，返回 'POP' | 'PUSH' | 'REPLACE' ，'POP' 表示是刷新页面进入的路由
  console.log(useNavigationType());

  // 解析某个路由的 path 、search、hash
  console.log(useResolvedPath("/about"));

  return <>About A</>;
}

export default AboutA;
```

方式二，声明模式，只有部分 router 功能；

```
// /src/router/index.tsx

import { BrowserRouter, useRoutes, Navigate } from "react-router-dom";
import Home from "..//views/Home";

const routes = [
  {
    path: "/",
    element: <Navigate to="/home" />,
  },

  {
    path: "/home",
    element: <Home />,
  },
];

function RoutesElement() {
  const element = useRoutes(routes);
  return <>{element}</>;
}

function RouterView() {
  return (
    <BrowserRouter>
      <RoutesElement />
    </BrowserRouter>
  );
}

export default RouterView;
```

```
// /src/App.tes

import RouterView from "./router";

function App() {
  return (
    <>
      <RouterView></RouterView>
    </>
  );
}

export default App;
```

方式三，老版本的声明模式：

```
// /src/router/index.tsx

import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
import Home from "../views/Home";

function RouterView() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Navigate to="/home" />}></Route>
        <Route path="/home" element={<Home />}></Route>
      </Routes>
    </BrowserRouter>
  );
}

export default RouterView;
```

```
// /src/App.tes

import RouterView from "./router";

function App() {
  return (
    <>
      <RouterView></RouterView>
    </>
  );
}

export default App;
```

（2）导航守卫`

React Router 并没有提供导航守卫，但可以用 loader 模拟实现独享守卫：

* loading 在舔砖之前执行，可以做一些炎症

* loader 本身是用来做异步数据获取的，在组件中为了避免副作用，都会在 useEffect 中发送 ajax ，比较繁琐，此时可以用 loader 代替，但也有缺点：
  
  * loader 会卡在 from ，直到 await 结束，且 to 渲染完成才会跳转，为了用户体验就需要添加 loading ，此时只能用 lazy 配置型 \+ useLocation ，不适合用 lazy \+ Suspense
  
  * 即使使用了 lazy 配置项 \+ useLocation ，在首页也显示不出 loading ，所以首页不要使用 loader

loader 示例：

```
// /src/router/index.tsx

import { createBrowserRouter, redirect } from "react-router-dom";
import Layout from "../views/Layout";
import Home from "../views/Home";
import ErrorPage from "../views/ErrorPage";

const about = async () => {
  const cpn = await import("../views/About");
  return {
    Component: cpn.default,
  };
};

async function getData() {
  return await new Promise((resolve) => {
    setTimeout(() => resolve("asdf"), 3000);
  });
}

const router = createBrowserRouter([
  {
    path: "/",
    element: <Layout />,
    children: [
      {
        index: true,
        element: <Home />,
      },

      {
        path: "/about",
        lazy: about,

        loader: async () => {
          // 模拟独享守卫
          if (Math.random() < 0.5) {
            console.log("无权限");
            return redirect("/");
          }

          // throw 会跳转到 ErrorBoundary 页面
          if (Math.random() < 0.5) throw "err";

          // 异步数据获取
          return await getData();
        },

        ErrorBoundary: ErrorPage,
      },
    ],
  },
]);

export default router;
```

```
// /src/views/Layout/index.tsx

import { Outlet, useNavigation } from "react-router-dom";

function Layout() {
  const navigation = useNavigation();
  const isLoading = navigation.state === "loading";

  return (
    <div>
      <p>Layout</p>
      {isLoading ? <div>Loading......</div> : <Outlet />}
    </div>
  );
}

export default Layout;
```

```
// /src/views/Home/index.tsx

import { useLoaderData, Link } from "react-router-dom";

function Home() {
  const data = useLoaderData();

  return (
    <>
      <p>Home: {data}</p>
      <p>
        <Link to="/about">to about</Link>
      </p>
    </>
  );
}

export default Home;
```

```
// /src/views/About/index.tsx

import { useState } from "react";
import { useLoaderData } from "react-router-dom";

function About() {
  const [cnt, setCnt] = useState(0);

  // 重新 render 不会重新执行
  const data = useLoaderData();

  return (
    <>
      <p>About: {data}</p>

      <p>
        <button onClick={() => setCnt(cnt + 1)}>test render</button>
        <span>{" " + cnt}</span>
      </p>
    </>
  );
}

export default About;
```

```
// /src/views/ErrorPage/index.tsx

import { useRouteError } from "react-router-dom";

function ErrorPage() {
  const err = useRouteError();
  return <p>{err as string}</p>;
}

export default ErrorPage;
```

也可以用高阶组件实现导航守卫：

* 独享守卫：通过高阶组件拦截实现

* 全局前置、后置守卫：需要全局守卫的路由通过把所有路由都配置为 layout 的嵌套路由，在 layout 拦截实现

* 获取 from 、to ：自己实现的前置守卫的时机有些不同，此时 url 已经被修改，所以可以用 useLocation 拿到 to ；from 则设置为前一个 to 即可

示例：

```
// /src/router/hooks.ts ，获取 from 、to

import { useState, useEffect } from "react";
import { useLocation } from "react-router-dom";
import type { Location } from "react-router-dom";

export function useFromTo() {
  const [from, setFrom] = useState<Location | null>(null);
  const to = useLocation();

  useEffect(() => {
    setFrom(to);
  }, [to]);

  return [from, to];
}
```

```
// /src/router/BeforeEnter/index.tex ，独享守卫

import { Navigate } from "react-router-dom";
import { useFromTo } from "../hooks";

function BeforeEnter(props: { children: React.ReactNode }) {
  const to = useFromTo()[1];

  const token = localStorage.getItem("token");

  if (!token) {
    return <Navigate to="/login" state={{ to }} replace />;
  }

  return props.children;
}

export default BeforeEnter;
```

```
// /src/router/Layout/index.tsx ，全局前置、后置守卫

import { useEffect } from "react";
import { Outlet } from "react-router-dom";
import { useFromTo } from "../hooks";
import type { Location } from "react-router-dom";

function beforeEach(from?: Location | null, to?: Location | null) {}
function afterEach(from?: Location | null, to?: Location | null) {}

function Layout() {
  const [from, to] = useFromTo();

  beforeEach(from, to);

  useEffect(() => {
    afterEach(from, to);
  }, [to]);

  return <Outlet />;
}

export default Layout;
```

```
// /src/router/index.tsx

import { createBrowserRouter, Navigate } from "react-router-dom";
import Layout from "./Layout";
import BeforeEnter from "./BeforeEnter";

import Home from "../views/Home";
import About from "../views/About";
import Login from "../views/Login";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Layout />,
    children: [
      {
        index: true,
        element: <Navigate to="/home" />,
      },

      {
        path: "home",

        // 若是懒加载，则 lazy 组件要在最外层
        element: (
          <BeforeEnter>
            <Home />
          </BeforeEnter>
        ),
      },

      {
        path: "about",
        element: (
          <BeforeEnter>
            <About />
          </BeforeEnter>
        ),
      },
    ],
  },

  {
    path: "/login",
    element: <Login />,
  },
]);

export default router;
```

（3）动态修改路由

三种配置路由的方式中，方式一暂时没有对应的 API，方式三可以直接遍历路由配置生成路由组件。

这里用方式二，将 routes 定义成响应式的状态变量，通过 setRoutes 修改路由：

```
// /src/router/index.tsx

import { useState, useEffect } from "react";
import { BrowserRouter, useRoutes } from "react-router-dom";
import Home from "../views/Home";
import About from "../views/About";

function useUpdateRoutes() {
  const [routes, setRoutes] = useState([
    {
      path: "/",
      element: <Home />,
    },
  ]);

  // 测试
  // useEffect(() => {
  //   setRoutes([
  //     ...routes,

  //     {
  //       path: "/about",
  //       element: <About />,
  //     },
  //   ]);
  // }, []);

  return { routes, setRoutes };
}

function RoutesElement() {
  return <>{useRoutes(useUpdateRoutes().routes)}</>;
}

function RouterView() {
  return (
    <BrowserRouter>
      <RoutesElement />
    </BrowserRouter>
  );
}

export { useUpdateRoutes };

export default RouterView;
```

### 3.2 Redux/Zustand

React 比较流行的两个全局状态管理工具，Zustand 使用更方便。

（1）Redux

Redux 调试工具：chrome 浏览器插件 Redux DevTools 。

React 使用 Redux 需要两个插件：

- @reduxjs/toolkit（RTK），官方推荐的编写 Redux 逻辑的方式，简化原生 Redux 的写法。RKT 也有一套现成的工具

- react-redux，react 接入 redux 之间的中间件

```
pnpm add @reduxjs/toolkit react-redux
```

```
// /src/store/counter.ts

import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

export interface CounterState {
  count: number;
}

// 异步 action
const asyncIncrement = createAsyncThunk("async/increment", async () => {
  const res = await new Promise((resolve) =>
    setTimeout(() => {
      resolve("ok");
    }, 1000)
  );
  return res;
});

const initialState: CounterState = {
  count: 0,
};

const counterSlice = createSlice({
  name: "counter",
  initialState,

  // 同步 action
  reducers: {
    increment(state) {
      state.count += 1;
    },

    decrement(state) {
      state.count -= 1;
    },

    addBy(state, action) {
      state.count += action.payload;
    },
  },

  // 异步 action
  extraReducers: (builder) => {
    builder.addCase(asyncIncrement.fulfilled, (state) => {
      state.count += 1;
    });
  },
});

export const { increment, decrement, addBy } = counterSlice.actions;
export { asyncIncrement };

export default counterSlice.reducer;
```

```
// /src/store/index.ts

import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "./counter";

const store = configureStore({
  reducer: {
    counter: counterReducer,
  },

  // true 开启浏览器 redux devtools 调试，这里在非生产环境开启
  devTools: import.meta.env.MODE !== "production",
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export default store;
```

```
// /src/main.tsx

import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App.tsx";
import { Provider } from "react-redux";
import store from "./store";

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </StrictMode>
);
```

持久化：

```
pnpm add redux-persist
```

```
// /src/store/index.ts

import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "./counter";
import {
  persistStore,
  persistReducer,
  FLUSH,
  REHYDRATE,
  PAUSE,
  PERSIST,
  PURGE,
  REGISTER,
} from "redux-persist";

// localStorage 、sessionStorage
import storage from "redux-persist/lib/storage"; // 使用 localStorage
// import storageSession from "redux-persist/lib/storage/session"; // ✅ 引入 sessionStorage 版本

// 配置 persist
const persistConfig = {
  // 默认为 "root"
  key: "root",
  storage,
};

// 创建持久化 reducer
const persistedReducer = persistReducer(persistConfig, counterReducer);

// 创建 store
const store = configureStore({
  reducer: {
    counter: persistedReducer,
  },

  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
      },
    }),
});

// 创建持久化控制器
export const persistor = persistStore(store);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export default store;
```

```
// /src/main.tsx

import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App.tsx";
import { Provider } from "react-redux";
import { PersistGate } from "redux-persist/integration/react";
import store, { persistor } from "./store";

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <Provider store={store}>
      <PersistGate loading={null} persistor={persistor}>
        <App />
      </PersistGate>
    </Provider>
  </StrictMode>
);
```

（2）Zustand

浏览器调试工具也是 Redux devtool 。

```
pnpm add zustand
```

```
// /src/store/index.ts

import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { subscribeWithSelector } from "zustand/middleware";

interface CounterState {
  testRerender: string;
  count: number;
  getDoubleCount: () => number;
  increment: () => void;
  addBy: (num: number) => void;
  asyncIncrement: () => Promise<void>;
}

interface UserState {
  user: { o: { text: string } };
  setText: (str: string) => void;
}

const useCounterStore = create<CounterState>((set, get) => ({
  testRerender: "",

  count: 0,
  getDoubleCount: () => get().count * 2,

  // set 和 useState 一样，但 Zustand 做了简化，第一层直接传入需要修改的属性就行
  increment: () => set((state) => ({ count: state.count + 1 })),
  addBy: (num) => set((state) => ({ count: state.count + num })),

  asyncIncrement: async () => {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    set((state) => ({ count: state.count + 1 }));
  },
}));

// 修改深层就完全和 useState 一样
// const useUserStore = create<UserState>((set) => ({
//   user: { o: { text: "asdf" } },
//   setText: (str: string) =>
//     set((state) => ({
//       user: {
//         ...state.user,
//         o: {
//           ...state.user.o,
//           text: str,
//         },
//       },
//     })),
// }));

// 可以用 immer 简化深层 set 操作
// const useUserStore = create<UserState>()(
//   immer((set) => ({
//     user: { o: { text: "asdf" } },
//     setText: (str) =>
//       set((state) => {
//         // 不要 return
//         state.user.o.text = str;
//       }),
//   }))
// );

// subscribe 中间件，使用后就可以只订阅部分 state ，而不是全部
const useUserStore = create<UserState>()(
  subscribeWithSelector(
    immer((set) => ({
      user: { o: { text: "asdf" } },
      setText: (str) =>
        set((state) => {
          state.user.o.text = str;
        }),
    }))
  )
);

export { useCounterStore, useUserStore };
```

```
// 无需注入，可直接使用

import { useMemo, useEffect } from "react";
import { useCounterStore, useUserStore } from "./store";
import { useShallow } from "zustand/react/shallow";

function Cpn1() {
  // 性能差，若 set 且其他组件也用到了相同的 store ，即使 set 的 state 那个组件没用到，也会重新 render 那个组件
  // const { count, doubleCount, increment, addBy, asyncIncrement } = useCounterStore();

  // 解决方法，使用状态选择器，这样 set 其他组件无关的 state 就不会重新 render 其他组件了
  // const count = useCounterStore((state) => state.count);

  /**简化状态选择器
   * 不使用 useShallow ，每次 set 后 Zustand 都会严格比较前后的引用，所以才会影响其他无关 state 的组件
   * 使用 useShallow 后就只会比较属性的变化
   */
  const { count, getDoubleCount, increment, addBy, asyncIncrement } =
    useCounterStore(
      useShallow((state) => ({
        count: state.count,
        getDoubleCount: state.getDoubleCount,
        increment: state.increment,
        addBy: state.addBy,
        asyncIncrement: state.asyncIncrement,

        // 或者直接解构
        // ...state,
      }))
    );

  /** Zustand 的 get 没有缓存功能，解决方法：
   * 可以结合 useMemo
   * 若某个组件只需要用到 doubleCount  且不需要用到 count ，就不适合用 useMemo 了，
     会造成多余的 render ，因此放弃 get 改用 subscribe ，在内部 set 当前组件的状态：
     // const [doubleCount, setDoubleCount] = useState(0);
    // subscribe 设置订阅初始就触发，函数中 if(state.count > 10) setDoubleCount();
   */
  const doubleCount = useMemo(() => getDoubleCount(), [count]);

  // 订阅，任何 state set 就回调
  useEffect(() => {
    // 订阅全部 state
    const unSubscribe = useUserStore.subscribe(
      // 订阅全部 state
      // (state, oldState) => {
      //   console.log("seted", state.user.o.text, oldState.user.o.text);
      // },

      // 若配置了 subscribe 中间件，也可以订阅部分 state
      (state) => state.user.o.text,
      (newValue, oldValue) => {
        console.log("seted", newValue, oldValue);
      },

      // 若使用了 subscribe 中间件就可以设置 options 配置项，类似 Vue 的 watch
      {
        // 即 immediate ，默认 false
        fireImmediately: true,

        // 自定义比较函数，不同就执行上面的回调，默认使用 Object.is 所以只能潜比较，可以自定义深比较实现深度监听
        // equalityFn: () => {},
      }
    );

    // 取消订阅
    // unSubscribe();
  }, []);

  return (
    <div>
      <button onClick={increment}>add</button>
      <span>{" " + count}</span>
      <span>{" " + doubleCount}</span>

      <p>
        <button onClick={() => addBy(5)}>+5</button>
      </p>

      <p>
        <button onClick={() => asyncIncrement()}>async +1</button>
      </p>
    </div>
  );
}

function Cpn2() {
  // 其他组件也需要使用状态选择器才不会被无关 state set 而 render
  // console.log("Cpn2 render");
  // const { testRerender } = useCounterStore();
  // const testRerender = useCounterStore((state) => state.testRerender);

  const { user, setText } = useUserStore();

  return (
    <div>
      <input
        type="text"
        value={user.o.text}
        onChange={(e) => setText(e.target.value)}
      />
      <span>{" " + user.o.text}</span>
    </div>
  );
}

function App() {
  return (
    <>
      <Cpn1 />
      <Cpn2 />
    </>
  );
}

export default App;
```

持久化：

```
// /src/store/index.ts

import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";

interface CounterState {
  count: number;
  increment: () => void;
}

const useCounterStore = create<CounterState>()(
  persist<CounterState>(
    (set) => ({
      count: 0,
      increment: () => set((state) => ({ count: state.count + 1 })),
    }),

    // 默认 key 为 "zustend" ，使用 localStorage，持久化所有 state
    {
      name: "zustend",
      storage: createJSONStorage(() => localStorage),

      // 持久化部分 state
      // partialize: (state) => ({ count: state.count }),
    }
  )
);

export { useCounterStore };
```

自定义中间件；

```
// /src/store/index.ts

import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

import type { StateCreator, StoreMutators } from "zustand";
type MutatorTuple = [keyof StoreMutators<unknown, unknown>, unknown];
type Middleware = <T, Mps extends MutatorTuple[]>(
  config: StateCreator<T, [], Mps, T>
) => StateCreator<T, [], Mps, T>;

interface CounterState {
  count: { o: { num: number } };
  increment: () => void;
}

// 自定义中间件写法
// const log = (config) => {
//   return (set, get, api) => {
//     return config((...args) => {}, get.api);
//   };
// };

// 自定义日志中间件
const log: Middleware = (config) => (set, get, api) =>
  config(
    (...args) => {
      console.log("beforeSet");
      (set as any)(...args);
      console.log("seted", get(), api);
    },

    get,
    api
  );

// 组合中间件：log -> devtools -> persist -> immer ，若需要传入泛型，则要放在最后一个中间件
const useCounterStore = create<CounterState>()(
  log(
    devtools(
      persist(
        immer<CounterState>((set) => ({
          count: { o: { num: 0 } },
          increment: () => {
            set((state) => {
              state.count.o.num++;
            });
          },
        })),
        {
          name: "aaaaa",
        }
      )
    )
  )
);

export { useCounterStore };
```

```
// 无需注入，可直接使用

import { useShallow } from "zustand/shallow";
import { useCounterStore } from "./store";

function App() {
  const { count, increment } = useCounterStore(
    useShallow((state) => ({ ...state }))
  );

  console.log(count);
  return (
    <>
      <button onClick={() => increment()}>add</button>
      <span>{" " + count.o.num}</span>
    </>
  );
}

export default App;
```

切片，组织多个模块：

```
// /src/store/index.ts

import { create } from "zustand";
import type { StateCreator } from "zustand";

interface CounterASlice {
  countA: number;
  addA: () => void;
}

interface CounterBSlice {
  countB: number;
  addB: () => void;
}

type StoreState = CounterASlice & CounterBSlice;

// 切片 A
const createCounterASlice: StateCreator<StoreState, [], [], CounterASlice> = (
  set
) => ({
  countA: 0,
  addA: () => set((state) => ({ countA: state.countA + 1 })),
});

// 切片 B
const createCounterBSlice: StateCreator<StoreState, [], [], CounterBSlice> = (
  set
) => ({
  countB: 0,
  addB: () => set((state) => ({ countB: state.countB + 1 })),
});

export const useStore = create<StoreState>()((...a) => ({
  ...createCounterASlice(...a),
  ...createCounterBSlice(...a),
}));
```

```
// 使用

import { useStore } from "./store";

function App() {
  const countA = useStore((state) => state.countA);
  const addA = useStore((state) => state.addA);
  const countB = useStore((state) => state.countB);
  const addB = useStore((state) => state.addB);

  // clear storage
  function clear() {
    // useStore 类型需要补充 persist 属性，待补充
    useStore.persist.clearStorage();
    useStore.setState({ count: 0 });
  }

  return (
    <>
      <p>
        <button onClick={addA}>add</button>
        <span>{" " + countA}</span>
      </p>

      <p>
        <button onClick={addB}>add</button>
        <span>{" " + countB}</span>
      </p>

      <p>
        <button onClick={clear}>clear</button>
      </p>
    </>
  );
}

export default App;
```

## 4 React 原理

### 4.1 状态

### 4.2 虚拟 DOM 、diff 算法

数据结构：

```
 // HTML DOM 树、Vue 、React 虚拟 DOM 树结构，是一个多叉树，只不过孩子节点用数组保存
interface Element {
  // ...
  children: Element[];
}

// React Fiber 树结构，用左孩子右兄弟表示的二叉树，兄弟节点形成一条单链表
interface Fiber {
  // ...
  child: Fiber | null;
  sibling: Fiber | null;
  parent: Fiber;
}
```

Fiber 架构：

* Fiber 是 React16 引入的新的协调引擎，用类似 requestIdleCallback 的思想实现调度器，将任务拆分为一个个工作单元（切片），按照任务优先级在浏览器空闲时运行

* React  的 render 函数会创建虚拟 DOM ，在调度器的作用下会逐步转为 Fiber 树，Fiber 树的节点就是一个工作单元，从而实现分片渲染

* 双缓存树，即新旧的两个 Fiber 树，用于 diff 算法，实现最小量更新

工作流程；

* 开启调度器，不断检查是否有要执行的工作单元：
  
  * React 中不直接使用 requestIdleCallback ，而是 React 自己实现，原因：
    
    * requestIdleCallback 兼容性差，且就算浏览器支持，各个浏览器的实现也可能不同，使得渲染速度不同；自己实现可以保证可用，也保证一致性
    
    * 自己实现可以更精细的控制，如设置优先级、控制执行时机
  
  * 核心逻辑：
    
    - 用宏任务代替，React 使用 MessageChannel（不支持则改用 setTimeout），用一个任务队列保存任务并 postMessage ，在 ommessage 接收时执行任务队列中的全部任务
    
    - 每种任务有对应的初始优先级，对应不同的延迟时间，再加上任务入队的当时时间，得到最终的过期时间，再对过期时间排序既可得到综合的优先级
      
      总的来说，初始优先级越高，入队时间越早，综合优先级越高；也就会出现初始优先级高的任务由于入队时间晚，综合优先级反而会更低的情况
  
  * 简单实现（未实现时间分片）：
    
    ```
    // 任务优先级，数字越小优先级越高 --------------------------------------------------------------
    enum Priority {
      // 立即执行的优先级, 级别最高 [点击事件，输入框，]
      Immediate = 1,
    
      // 用户阻塞级别的优先级, [滚动，拖拽这些]
      UserBlocking = 2,
    
      // 正常的优先级 [redner 列表 动画 网络请求]
      Normal = 3,
    
      // 低优先级  [分析统计]
      Low = 4,
    
      // 最低阶的优先级, 可以被闲置的那种 [console.log]
      Idle = 5,
    }
    
    // 实现 ----------------------------------------------------------------------------------
    type TaskCallback = (...args: unknown[]) => unknown;
    
    interface Task {
      callback: TaskCallback;
      priority: Priority;
      expirationTime: number;
    }
    
    // 调度器
    class SimpleScheduler {
      // 任务队列，是否正在执行任务，channel port
      isPerformingWork: boolean;
      taskQueue: Task[];
      port: MessagePort;
    
      constructor() {
        this.taskQueue = [];
        this.isPerformingWork = false;
    
        // 使用 MessageChannel 处理任务调度
        const channel = new MessageChannel();
        this.port = channel.port2;
    
        // 接收
        channel.port1.onmessage = this.performWorkUntilDeadline.bind(this);
      }
    
      // 入队、出兑、获取任务 ----------------------------------------------------------------------
      push(task: Task) {
        this.taskQueue.push(task);
    
        // 根据优先级排序，优先级高的在前 从小到大
        this.taskQueue.sort((a, b) => a.expirationTime - b.expirationTime);
      }
    
      pop() {
        return this.taskQueue.shift();
      }
    
      peek() {
        return this.taskQueue[0] || null;
      }
    
      // 调度 ------------------------------------------------------------------------------------
      // 执行任务队列的全部任务
      performWorkUntilDeadline() {
        this.isPerformingWork = true;
    
        let curTask = this.peek();
        while (curTask) {
          const callback = curTask.callback;
          if (typeof callback === "function") callback();
          this.pop();
          curTask = this.peek();
        }
    
        this.isPerformingWork = false;
      }
    
      // 通过 MessageChannel 调度执行任务
      schedulePerformWorkUntilDeadline() {
        // 防止重复 postMessage
        if (this.isPerformingWork) return;
        this.isPerformingWork = true;
    
        // 发送
        this.port.postMessage(null);
      }
    
      // 调度任务，传入优先级和任务，添加到任务队列，然后 postMessage
      scheduleCallback(priority: Priority, callback: TaskCallback) {
        // 根据优先级设置超时时间
        let timeout: number;
        switch (priority) {
          case Priority.Immediate:
            timeout = -1;
            break;
    
          case Priority.UserBlocking:
            timeout = 250;
            break;
    
          case Priority.Low:
            timeout = 10000;
            break;
    
          case Priority.Idle:
            timeout = 1073741823;
            break;
    
          case Priority.Normal:
          default:
            timeout = 5000;
            break;
        }
    
        // 将任务加入队列
        this.push({
          callback,
          priority,
    
          // 直接根据当前时间加上超时时间，performance.now() 是 React 提供的获取时间的 API ，精确到微秒
          expirationTime: performance.now() + timeout,
        });
    
        this.schedulePerformWorkUntilDeadline();
      }
    }
    
    // 测试 ---------------------------------------------------------------------------------------
    const scheduler = new SimpleScheduler();
    
    scheduler.scheduleCallback(Priority.Low, () => {
      console.log("Task 1: Low Priority");
    });
    
    scheduler.scheduleCallback(Priority.Immediate, () => {
      console.log("Task 2: Immediate Priority");
    });
    
    scheduler.scheduleCallback(Priority.Idle, () => {
      console.log("Task 3: Idle Priority");
    });
    
    scheduler.scheduleCallback(Priority.UserBlocking, () => {
      console.log("Task 4: User Blocking Priority");
    });
    
    scheduler.scheduleCallback(Priority.Normal, () => {
      console.log("Task 5: Normal Priority");
    });
    ```

* render 函数：函数式组件会编译为 render 函数，生成虚拟 DOM ，并开启一个工作单元，开始处理 Fiber 树

* 执行工作单元：
  
  * 当工作单元不为 null 时，调度器就会执行工作单元
  
  * 处理工作单元的所有孩子，在 diff 过程中生成 Fiber 结点：
    
    * 先遍历一遍孩子，生成 key 的映射表，同一层、标签类型和 key 相同即可赋用
    
    * 仅右移：赋用的结点若需要移动，则仅右移，通过前后 Fiber 结点的 index 判断
  
  * 返回下一个工作单元

* commit 提交，当这一帧剩余时间不足时，且有 Fiber 处理过，就更新真实 DOM
  
  * 后序遍历 Fiber 树，让靠右兄弟先移动，，保证移动顺序
  
  * 删除的结点不需要便利，直接删除即可，它的孩子结点会一并删除

简单实现：

```
// 创建虚拟 DOM ----------------------------------------------------------------------------
interface Element {
  type: string;
  props: {
    [key: string]: any;
    children?: Element[];
  };
}

// 创建虚拟元素节点、虚拟文本节点
const MyReact = {
  // 创建虚拟 DOM 文本节点
  createTextElement(text: string): Element {
    return {
      type: "TEXT_ELEMENT",
      props: {
        nodeValue: text,
        children: [],
      },
    };
  },

  // 创建虚拟 DOM 元素
  createElement(
    type: string,
    props: object = {},
    ...children: (Element | string)[]
  ): Element {
    return {
      type,
      props: {
        ...props,

        children: children.map((child): Element => {
          return typeof child === "object"
            ? child
            : MyReact.createTextElement(child);
        }),
      },
    };
  },
};

// Fiber 树 --------------------------------------------------------------------------------
// 二叉树（左孩子右兄弟）
interface Fiber extends Element {
  effectTag: "PLACEMENT" | "UPDATE" | "MOVE" | "DELETION" | null;

  // 关联的真实 DOM 节点
  dom: HTMLElement | Text | null;

  // 父、兄、子
  return: Fiber | null;
  sibling: Fiber | null;
  child: Fiber | null;

  // 由于兄弟是单链表，所以需要用 index 表示在真实 DOM 的下标
  index: number;

  // 对应的就 Fiber 节点
  alternate: Fiber | null;
}

/**
 * wipRoot ：新 Fiber 树（work in process），即正在进行的工作 Fiber 树 ，它是 Fiber 架构中渲染任务的起点
 * currentRoot ：旧 Fiber 树，即当前正在渲染使用的 Fiber 树
 * nextUnitOfWork ：下一个要执行的工作单元（即 Fiber 节点）。在这里
 * deletions ：存放更新过程中需要删除的节点，最后在 commitRoot 阶段将它们从 DOM 中删除
 */
let wipRoot: Fiber | null = null;
let currentRoot: Fiber | null = null;
let nextUnitOfWork: Fiber | null = null;
let deletions: Fiber[] = [];

// 创建 Fiber 节点
function createFiber(
  element: Element,
  parent: Fiber,
  index: number = 0
): Fiber {
  return {
    ...element,
    effectTag: null,
    dom: null,
    return: parent,
    sibling: null,
    child: null,
    index,
    alternate: null,
  };
}

// 更新真实 DOM 属性，文本内容也在 props 中
function updateDom(
  dom: HTMLElement | Text,
  prevProps: Fiber["props"],
  nextProps: Fiber["props"]
) {
  if (dom instanceof Text) {
    dom["nodeValue"] = nextProps["nodeValue"];
    return;
  }

  // 删除旧属性
  Object.keys(prevProps)
    .filter(
      (name) => name !== "children" && prevProps[name] !== nextProps[name]
    )
    .forEach((name) => ((dom as any)[name] = ""));

  // 添加、更新属性
  Object.keys(nextProps)
    .filter(
      (name) => name !== "children" && prevProps[name] !== nextProps[name]
    )
    .forEach((name) => ((dom as any)[name] = nextProps[name]));
}

// 创建 DOM 节点
function createDom(fiber: Fiber): HTMLElement | Text {
  const dom =
    fiber.type === "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type);

  updateDom(dom, {}, fiber.props);

  return dom;
}

// Diff 算法 --------------------------------------------------------------------------------
function diff(wipFiber: Fiber, elements: Element[]) {
  // key map ---------------------------------------------------------------------------
  const oldFibersByKey: Record<string | number, Fiber> = {};
  let oldFiber = wipFiber.alternate?.child ?? null;

  let p = oldFiber;
  while (p) {
    const key = p.props.key;
    if (key) oldFibersByKey[key] = p;
    p = p.sibling;
  }

  // console.log(oldFibersByKey);

  // 开始 diff ，并生成 Fiber 节点 ----------------------------------------------------------------------------
  let index = 0;
  let cnt = 0;
  let prevSibling: Fiber | null = null;
  let newFiber: Fiber | null = null;

  while (index < elements.length || oldFiber !== null) {
    const element = elements[index] || null;

    const noKeySame =
      oldFiber &&
      element &&
      element.type === oldFiber.type &&
      !element.props.key &&
      !oldFiber.props.key;

    // 未设置 key ，type 相同，不需要移动，直接复用
    if (noKeySame) {
      console.log("直接复用");

      newFiber = {
        type: element.type,
        props: element.props,
        return: wipFiber,
        child: null,
        sibling: null,
        index,

        effectTag: "UPDATE",
        dom: oldFiber!.dom,
        alternate: oldFiber,
      };

      if (oldFibersByKey[element.props.key]) {
        delete oldFibersByKey[element.props.key];
      }
    }
    // 再去 keyMap 匹配，看是否可以复用，若复用看是否需要移动（仅右移）
    else if (element) {
      const keyFiber = oldFibersByKey[element.props.key];

      // 赋用
      if (
        keyFiber &&
        element.type === keyFiber.type &&
        element.props.key === keyFiber.props.key
      ) {
        const move = index > keyFiber.index + cnt;

        console.log(
          move ? "移动" : "直接复用",
          element.type,
          element.props.key
        );

        newFiber = {
          type: element.type,
          props: element.props,
          return: wipFiber,
          child: null,
          sibling: null,
          index,

          effectTag: move ? "MOVE" : "UPDATE",
          dom: keyFiber.dom,
          alternate: keyFiber,
        };
      }

      // 无法复用，则重新创建
      else {
        console.log("创建", element.type, element.props.key);
        --cnt;
        newFiber = createFiber(element, wipFiber, index);
        newFiber.effectTag = "PLACEMENT";
      }

      delete oldFibersByKey[element.props.key];
    }

    // 检查没有设置 key 的情况，剩余的就删除
    if (oldFiber && !oldFiber.props.key && !noKeySame) {
      console.log("删除1", oldFiber.type, oldFiber.props.key);
      ++cnt;
      oldFiber.effectTag = "DELETION";
      deletions.push(oldFiber);
    }

    // 更新到 Fiber 树 -------------------------------------------------------------------
    // 左孩子、右兄弟
    if (index === 0) wipFiber.child = newFiber;
    else if (element) prevSibling!.sibling = newFiber;

    // 下一个兄弟
    ++index;
    oldFiber = oldFiber?.sibling || null;

    prevSibling = newFiber;
    newFiber = null;
  }

  // 剩余的未赋用的，删除
  for (const key in oldFibersByKey) {
    console.log("删除2", oldFibersByKey[key].type, key);
    oldFibersByKey[key].effectTag = "DELETION";
    deletions.push(oldFibersByKey[key]);
  }
}

// 执行一个工作单元，返回下一个工作单元
function performUnitOfWork(fiber: Fiber): Fiber | null {
  // 如果没有 DOM 节点，则为当前 Fiber 创建 DOM 节点
  if (!fiber.dom) fiber.dom = createDom(fiber);

  // diff 并创建 Fiber 节点，使兄弟成为单链表
  diff(fiber, fiber.props.children || []);

  // 返回下一个工作单元（child, sibling, or parent
  if (fiber.child) return fiber.child;

  let nextFiber: Fiber | null = fiber;
  while (nextFiber) {
    if (nextFiber.sibling) return nextFiber.sibling;
    nextFiber = nextFiber.return;
  }

  return null;
}

// render -------------------------------------------------------------------------------------
function render(element: Element, container: HTMLElement) {
  wipRoot = {
    type: "root",
    props: {
      children: [element],
    },

    effectTag: null,
    dom: container,

    return: null,
    sibling: null,
    child: null,
    index: 0,

    /**alternate
     * 是 React Fiber 树中的一个关键概念，用于双缓冲机制（双缓冲 Fiber Tree）
     * 新旧 Fiber 树通过 alternate 属性相互关联
     */
    alternate: currentRoot,
  };

  // 开启任务
  nextUnitOfWork = wipRoot;

  deletions = [];
}

// commit ------------------------------------------------------------------------------------
// 提交单个 Fiber 节点，根据操作类型更新真实 DOM
function commitWork(fiber: Fiber | null) {
  if (!fiber) return;

  // 后序遍历，让靠右的兄弟先移动，顺序才不会错；删除就不用便利了，直接删除，子元素也会一并删除
  if (fiber.effectTag !== "DELETION" && fiber.effectTag !== null) {
    commitWork(fiber.child);
    commitWork(fiber.sibling);
  }

  console.log(
    fiber.type,
    fiber.props.key,
    fiber.effectTag,
    fiber.sibling?.props?.key
  );

  const domParent = fiber.return!.dom;

  if (fiber.effectTag === "PLACEMENT" && fiber.dom != null) {
    // domParent!.appendChild(fiber.dom);

    domParent!.insertBefore(
      fiber.dom,
      fiber.sibling?.dom?.parentElement === domParent ? fiber.sibling.dom : null
    );
  } else if (fiber.effectTag === "UPDATE" && fiber.dom != null) {
    updateDom(fiber.dom, fiber.alternate!.props, fiber.props);
  } else if (fiber.effectTag === "MOVE" && fiber.dom != null) {
    domParent!.insertBefore(
      fiber.dom,
      fiber.sibling?.dom?.parentElement === domParent ? fiber.sibling.dom : null
    );

    updateDom(fiber.dom, fiber.alternate!.props, fiber.props);
  } else if (fiber.effectTag === "DELETION") {
    domParent!.removeChild(fiber.dom!);
  }
}

// 提交，更新到真实 DOM
function commitRoot() {
  console.log("comit");

  // 删除需要删除的节点
  // console.log(deletions.map((el) => ({ type: el.type, key: el.props.key })));
  deletions.forEach(commitWork);

  // 更新
  if (!wipRoot) return;
  commitWork(wipRoot.child);

  // 保存旧 Fiber 树
  currentRoot = wipRoot;
  wipRoot = null;
}

// Fiber 调度器，实现将耗时任务拆分成多个小的工作单元 --------------------------------------------------
function workLoop() {
  requestIdleCallback((deadline) => {
    // 开始执行工作单元，如果剩余时间 < 1ms ，就在下一帧再执行，防止阻塞
    while (nextUnitOfWork && deadline.timeRemaining() >= 1) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }

    // 若没有下一个工作单元，且有待提交的工作根，就提交，将结果应用到真实 DOM 中
    if (!nextUnitOfWork && wipRoot) commitRoot();

    // 下一帧
    requestIdleCallback(workLoop);
  });
}

// start
workLoop();

// 测试 --------------------------------------------------------------------------------------------
// render(
//   MyReact.createElement(
//     "div",
//     { id: "root" },

//     MyReact.createElement("p", {}, "1"),
//     MyReact.createElement("p", {}, "2"),
//     MyReact.createElement("p", {}, "3")
//   ),

//   document.getElementById("root")!
// );

// setTimeout(() => {
//   console.log("beforeUpdate");

//   render(
//     MyReact.createElement(
//       "div",
//       { id: "root" },

//       // MyReact.createElement("p", {}, "1"),
//       // MyReact.createElement("p", { key: "2" }, "2"),
//       // MyReact.createElement("p", {}, "3")

//       MyReact.createElement(
//         "ul",
//         {},

//         MyReact.createElement("li", {}, "0-1"),
//         MyReact.createElement("li", {}, "0-2"),
//         MyReact.createElement("li", {}, "0-3")
//       ),
//       MyReact.createElement("div", {}, "2")
//     ),

//     document.getElementById("root")!
//   );
// }, 2000);

// setTimeout(() => {
//   console.log("beforeUpdate 2");

//   render(
//     MyReact.createElement(
//       "div",
//       { id: "root" },

//       MyReact.createElement(
//         "ul",
//         {},

//         MyReact.createElement("li", {}, "0-1"),
//         MyReact.createElement("li", {}, "0-3")
//       ),

//       MyReact.createElement(
//         "ul",
//         {},

//         MyReact.createElement("li", {}, "1-1"),
//         MyReact.createElement("li", {}, "1-2"),
//         MyReact.createElement("li", {}, "1-3")
//       )
//     ),

//     document.getElementById("root")!
//   );
// }, 4000);

// 测试 key ----------------------------------------------------------------------------------
render(
  MyReact.createElement(
    "div",
    { id: "root" },

    MyReact.createElement("p", { key: "1" }, "1"),
    MyReact.createElement("p", { key: "2" }, "2"),
    MyReact.createElement("p", { key: "3" }, "3")
  ),

  document.getElementById("root")!
);

setTimeout(() => {
  console.log("beforeUpdate");

  // 未使用 key ，则两个元素都会删除，再创建；若使用 key ，则只是移动
  render(
    MyReact.createElement(
      "div",
      { id: "root" },

      // MyReact.createElement("p", { key: "1" }, "1"),
      // MyReact.createElement("p", { key: "3" }, "3"),
      // MyReact.createElement("p", { key: "5" }, "5"),
      // MyReact.createElement("p", { key: "2" }, "2"),
      // MyReact.createElement("p", { key: "4" }, "4")

      // MyReact.createElement("p", { key: "3" }, "3"),
      // MyReact.createElement("p", { key: "5" }, "5"),
      // MyReact.createElement("p", { key: "2" }, "2"),
      // MyReact.createElement("p", { key: "4" }, "4")

      // MyReact.createElement("p", { key: "5" }, "5"),
      // MyReact.createElement("p", { key: "1" }, "1"),
      // MyReact.createElement("p", { key: "3" }, "3"),
      // MyReact.createElement("p", { key: "2" }, "2"),
      // MyReact.createElement("p", { key: "4" }, "4")

      // MyReact.createElement("p", { key: "4" }, "4"),
      // MyReact.createElement("p", { key: "3" }, "3"),
      // MyReact.createElement("p", { key: "2" }, "2"),

      MyReact.createElement("p", { key: "2" }, "2"),
      MyReact.createElement("p", {}, "1"),
      MyReact.createElement("p", { key: "4" }, "4"),
      MyReact.createElement("p", {}, "3")
    ),

    document.getElementById("root")!
  );
}, 2000);

setTimeout(() => {
  console.log("beforeUpdate 2");
  render(
    MyReact.createElement(
      "div",
      { id: "root" },

      MyReact.createElement("p", { key: "1" }, "1"),
      MyReact.createElement("p", { key: "2" }, "2"),
      MyReact.createElement("p", { key: "3" }, "3")
    ),

    document.getElementById("root")!
  );
}, 4000);
```

# 三、
