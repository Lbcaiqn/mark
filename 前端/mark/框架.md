# 一、Vue

浏览器 Vue 调试插件：vue devtools ，Vue2、Vue3 使用的版本不同，两者不能共存。

vscode Vue 语法插件：Vetur（Vue2），Volar（Vue3），两者不能共存。

## 1 基本

Vue2 、Vue3 主要区别：

* Vue2 使用 Options API ，Vue3 使用 Composition API（即 hook）， Vue3 依旧支持 Options API ，但不推荐混用，防止冲突以及可读性差。

* Vue3 中不再是用 Vue 构造函数创建 vue ，而是用 createApp 工厂函数创建；Vue 中的各种属性、方法都转移到 app 中：
  
  ```
  // Vue2
  import Vue from "vue";
  import App from "./App";
  new Vue({
    render: h => h(APP)
  }).$mount("#app");
  
  // Vue3
  import { createApp } from "vue";
  import App from "./App";
  createApp(App).mount("#app");
  ```

* Vue2.7 比 Vue3.0 晚发布，具备 Vue3 部分特性，作用是让 Vue2 老项目平滑升级 Vue3 。

### 1.1 使用 CDN

Vue2 ：

```
<!DOCTYPE html>
<html lang="en">
  <body>
    <div id="app"></div>
  </body>

  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
  <script>
    // 子组件
    const Cpn = Vue.extend({
      template: `<div>cpn</div>`,
    });

    // 注册全局组件
    // Vue.component("cpn2", cpn1);

    // 根组件，各个配置项叫 OptionsAPI (选项式 API)，内部的 this 指向 vue 实例
    // Options API 谨慎使用箭头函数，确保 this 为组件实例
    const App = new Vue({
      // document.querySelector("#app").appendChild(vue);
      el: "#app",

      // 注册局部组件，仅当前组件可用
      components: { Cpn },

      data() {
        return {
          list: [10, 20, 30],
        };
      },

      methods: {
        itemClick(e) {
          console.log(e);
        },
      },

      // 渲染
      render(h) {
        return h(
          "ul",
          { attrs: { class: "list" } },

          [
            ...this.list.map((item) => {
              return h(
                "li",
                {
                  attrs: { class: "item" },
                  on: { click: this.itemClick },
                },
                item
              );
            }),

            h("li", {}, [h(this.$options.components.Cpn)]),
          ]
        );
      },

      // 或者使用 template ，会编译为 render 函数，优先级低于自己配置的 render
      template: `
        <ul class="list">
          <li class="item" v-for="item in this.list" @click="this.itemClick">
            {{ item }}
          </li>
          <li><Cpn></Cpn></li>
        </ul>
      `,
    });
  </script>
</html>
```

Vue3 ：

```
<!DOCTYPE html>
<html lang="en">
  <body>
    <div id="app"></div>
  </body>

  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script>
    // Vue3 用 Composition API（组合式 API）
    const { createApp, defineComponent, h, reactive } = Vue;

    // 子组件
    const Cpn = defineComponent({
      setup() {
        return () => h("div", "cpn");
      },
    });

    // 根组件
    const App = defineComponent({
      components: { Cpn },

      setup() {
        // undefined
        console.log(this);

        const list = reactive([10, 20, 30]);

        const itemClick = (e) => console.log(e);

        // return 一个 render 函数
        // return () => {
        //   return h("ul", { class: "list" }, [
        //     ...list.map((item) =>
        //       h(
        //         "li",
        //         {
        //           class: "item",
        //           onClick: itemClick,
        //         },
        //         item
        //       )
        //     ),
        //     h("li", {}, [h(Cpn)]),
        //   ]);
        // };

        // 或者 return 数据给 template 使用
        return { list };
      },

      template: `
        <ul class="list">
          <li class="item" v-for="item in this.list" @click="this.itemClick">
            {{ item }}
          </li>
          <li><Cpn></Cpn></li>
        </ul>
      `,
    });

    createApp(App).mount("#app");
  </script>
</html>
```

### 1.2 单文件组件（SFC）

最常用的写法，允许在 \.vue 文件编写代码。

Vue2 、Vue3 区别：

* Vue3 的 \<template\> 不在必须有一个根元素，原理是 Vue3 没有根元素时会自动加上一个虚拟元素 \<Fragments\> ：
  
  * 若有一个根元素，则这个组件的根节点就是这个根元素，行盒、块盒由根元素决定
  
  * 若没有根元素，而是多根元素的形式，就会用一个空文本节点作为根节点，使得这个组件成为一个行盒
  
  * 若没有任何元素，则就是一个空注释节点

* \<style\ scoped> 的样式穿透，Vue2 使用 /deep/ select ，Vue3 使用 \:deep\(select\)

Vue2 ：

```
<script>
// 导入样式，但一般不会这么做，都是写在 vue 文件的 <style> 中，或在 main.js 中导入全局样式
// import "./xxx.css";

// 定义子组件，但一般不会这么做，都是导入一个单独的 vue 文件
const Cpn = {
  render(h) {
    return h("p", "Cpn");
  },
};

// 可以导出资源
// export const a = 0;

// Vue2 响应式会修改原始数据
const obj = { a: 1 };

// 导出组件
export default {
  // this 指向 Vue 组件实例

  components: { Cpn },

  /**data ，都是响应式数据
   * 除根组件 App 外，其他组件的 data 必须是函数 return obj 的形式，这是为了防止组件多次使用的 data 冲突
   * 当然 App 也可以用函数形式
   */
  data() {
    return {
      list: [10, 20, 30],
      obj,
    };
  },

  methods: {
    itemClick(e) {
      console.log(e);
    },
  },

  mounted() {
    // true ，Vue2 响应式给原始数据使用 Object.defineProperty
    console.log(obj === this.obj);
  },
};
</script>

<!--template
  * template 不会渲染到真实 DOM ；在木模板内部也可以用 template 作为包裹的虚拟元素
  * template 只能用 v-if、v-else、v-else-if、v-for、无法使用 v-show
  * 每个组件必须有且只有一个跟标签，用于渲染函数插入试图
 -->
<template>
  <ul class="list">
    <!-- 可以省略 this -->
    <li class="item" v-for="item in list" :key="item" @click="itemClick(item)">
      {{ item }}
    </li>
    <li>
      <Cpn />
    </li>
  </ul>
</template>

<!--style
  * scoped: 样式不会影响外部但会受到外部影响，原理是设置 scoped 后组件会多一个自定义属性 data-v-xxx ，再用属性选择器
  * 一般 App 不加 scoped ，做一些全局样式；其他组件加 scoped ，防止冲突
 -->
<style scoped>
/* 引入样式，会受到 scoped 影响加上属性选择器 */
/* @import "./1.css"; */

/**修改有 scoped 的子组件样式，如组件库
 * 在无 scoped 的组件如 App.vue 修改，写对应的选择器
 * 在有 scoped 的组件用样式穿透 /deep/ 修改
 */
/deep/ .el-input__inner {
}
</style>
```

Vue3 ：

```
<script setup lang="ts">
// script setup ，Vue3.2 支持

import { ref, reactive, toRef } from "vue";

// 响应式、函数等 ------------------------------------------------------------------------
const obj = { a: 1 };

// ref ，定义基本类型的响应式数据，若传入引用类型，则会再使用 reactive
const d1 = ref(0);
const d2 = ref(obj);
// ref 用 Object.defineProperty 的 ES6 语法糖访问器实现，所以需要 .value
console.log(d1.value, d2.value);

// reactive ，定义引用类型的响应式数据
const d3 = reactive(obj);
// reactive 使用 Proxy 实现
console.log(d3, d3.a);
// false ，所以不会处理原始数据，而是得到一个新对象
console.log(d3 === obj);

// 函数
const func = (e: MouseEvent) => console.log(e);

// 注意 -------------------------------------------------------------------------------------
const t1 = ref(0);
const t2 = reactive({ a: 1 });

// 谨慎响应式丢失，如取出原始值
const t3 = t1.value;
const t4 = t2.a;
console.log(t3, t4);
// 可以用 toRef 解决响应式丢失问题
const t5 = toRef(t1, "value");
const t6 = toRef(t2, "a");
console.log(t5, t6);
// true true ，和 ref 的区别是，toRef 会和原来的数据关联
t5.value = 123;
t6.value = 123;
console.log(t5.value === t1.value, t6.value === t2.a);

// 禁止直接赋值，重新赋值就不是原来的响应式数据了
let t7 = ref({ a: 1 });
// t7 = ref({ b: 2 });
// 正确做法，如果是 reactive ，就只能遍历 key 处理了
t7.value = { b: 2 };

// 其他 -------------------------------------------------------------------------------
// 定义 Options API ，defineOptions 是一个宏定义，不需要导入
defineOptions({
  name: "Cpn",
});

// script setup 中只能导入类型，且不能默认导出
// export type T = number;
</script>

<!-- 
<script lang="ts">
// Vue3 基础写法，script setup 会编译为这种形式

import { defineComponent, ref, reactive, toRef, toRefs, h } from "vue";

// 和 Vue2 一样可以 export ，不像 script setup 只能 export 类型
// export const a = 1;
// export type T = number;

// 使用 defineComponent 是为了得到 ts 类型提示，也可以不用
export default defineComponent({
  name: "Cpn",

  setup() {
    const d1 = ref(0);
    const d2 = reactive({ a: 1 });
    const d3 = ref({ a: 1 });
    const func = (e: MouseEvent) => console.log(e);

    // 只有 return 的资源，template 才能使用；script setup 编译后自动补上 return
    return { d1, d2, d3, func };

    // 也可以把资源都放到一个变量中，在使用 toRefs
    // return { ...toRefs(data) };

    // 也可以 return render 函数，覆盖 template
    // return () => h("p", "123");
  },
});
</script> 
-->

<!-- 不需要根元素，会自动加上虚拟节点 Fragments -->
<template>
  <!-- ref 可以省略 .value -->
  <p>{{ d1 }}</p>
  <p>{{ d2 }}</p>
  <p>{{ d3 }}</p>
  <button @click="func">click</button>
</template>

<style scoped lang="less">
// 样式穿透
:deep(.box) {
}

// 也可以指定穿透某个组件的样式
:deep(ChildCpn 。box) {
}
</style>
```

defineOptions 在 Vue3.4 才支持，若版本不够且使用 script setup ，择有两种方式：

* 写两个 \<script\> ，lang 必须一样；
  
  ```
  <script setup lang="ts"></script>
  
  <script lang="ts">
  // 多个 script 属于不同的作用域，变量不共享，但资源不用重复导入
  export default {
    name: "Cpn",
  };
  </script>
  
  <template></template>
  ```

* 使用 vite 插件，如配置组件 name ：
  
  ```
  npm install -D vite-plugin-vue-setup-extend
  ```
  
  ```
  // /src/vite.config.ts
  
  import vueSetupExtend from "vite-plugin-vue-setup-extend";
  
  export default defineConfig({
    plugins: [vue(), vueSetupExtend()],
  });
  ```
  
  ```
  <script setup lang="ts" name="home"></script>
  ```

## 2 语法

Vue2 中，在非生产环境会有提示（Vue3 则没有），这个提示是为了提醒开发者：上线时要开启生产模式（通过构建工具，打包压缩，去除调试信息等，这个提示可以关闭：

```
// /src/main.js
Vue.config.productionTio = false;
```

### 2.1 插值语法、数据绑定、指令、事件绑定

Vue2 ，Vue3 用法基本一样，区别：

* Vue2 、Vue3 的自定义指令的回调函数名字不同

* Vue3 新增指令 v\-memo

* Vue3 删除了事件修饰符 navtie 、keycode

* Vue3 新增 CSS 相关新特性：
  
  * style v\-bind ；支持在 CSS 中绑定 JS 变量，原理是 JS 添加 CSS 变量
  
  * CSS Module ：支持写多个 \<style\> 并标注 module ，每个 CSS Module 都是独立的

Vue2 ：

```
<script>
// Vue2

export default {
  data() {
    return {
      text: "msg",
    };
  },

  methods: {
    func: () => console.log("func"),
  },

  // 自定义指令，只有 3 个钩子
  directives: {
    yyy: {
      bind(e, binding) {},
      inserted(e, binding) {
        console.log("yyy mounted");
      },
      update(e, binding) {},
    },
  },
};
</script>

<template>
  <div>
    <!-- this 可以省略，编译模板时会补上 -->

    <div>{{ text }}</div>
    <div v-yyy></div>
    <button @click="func">click</button>

    <!-- 使得组件可以监听原生事件、Vue3 已删除
       * 组件绑定的事件默认会认为是自定义事件、Vue3 更是只认 emits 声明的事件
       * .native 其实是给组件根元素绑定事件，不推荐，所以 Vue3 就删除了，让具体触发
         事件的元素 emit 自定义事件即可
      -->
    <!-- <Cpn @click.native="console.log('native')">native</Cpn> -->

    <!-- keycode 修饰符，按下某个案件触发,Vue3 已删除，原因是兼容性差
       * 若要使用 keycode，只能用原生 JS
       * input 的 enter 键，可以用 <form> 包裹 input 、监听 submit 即可
      -->
    <div @keydown.13="console.log('keycode')">keycode</div>
  </div>
</template>

<style scoped></style>
```

Vue3 ：

```
<script setup lang="ts">
// Vue3

import { ref, reactive, useCssModule } from "vue";
import type { Directive, DirectiveBinding } from "vue";

// 数据、函数 ----------------------------------------------------------------------------------
// 响应式数据，用 ref 、reactive 定义
const hello = ref("hello");
const inpValue = ref(123);
const isDisable = ref(true);
const title = ref("title");
const titleClass2 = ref("title2");

// style v-bind ，根据需求，看是否需要响应式
const size = "50px";
const border = ref("1px solid #000");
const center = reactive({
  a: "center",
});

// 默认 CSS Module 和其他 CSS Module ，若需要 JS 操作则可以使用 hook
// const dm = useCssModule();
// const m1 = useCssModule("m1");

// v-memo
const memoValue = ref(123);

// 函数
function say() {
  return "world";
}

// 事件 -----------------------------------------------------------------------------
const click1 = (): void => console.log("click 1");

const click2 = (e: MouseEvent): void => console.log("click 2", e);

const click3 = (num: number, e: MouseEvent): void =>
  console.log("click 3", num, e);

const click4 = (a: number, b: number): void => console.log("click 4 ，", a, b);

/**自定义指令 ------------------------------------------------------------------------------------
 * 共 7 个钩子 ，从 created 到 unMounted
 * 原始写法是 Options API ，也可以在 script setup 中写但必须加上 v 前缀，以便编译处理
 *
 */
// 简写
const vXxx = (el: HTMLElement, dir: DirectiveBinding) => {
  console.log("v-xxx", dir.value, el);
};

// 完整写法
const vYyy: Directive = {
  mounted(el: HTMLElement, dir: DirectiveBinding) {
    console.log("v-yyy", dir.value, el);
  },
};
</script>

<!-- Options API 自定义指令 --------------------------------------------------------------------->
<script lang="ts">
import { defineComponent } from "vue";

export default defineComponent({
  directives: {
    zzz(el: HTMLElement, dir: DirectiveBinding) {
      console.log("v-zzz", dir.value, el);
    },
  },
});
</script>

<template>
  <!-- 插值语法，也叫 Mustache 语法，内容为 JS 表达式，作用是使用 Model -->
  <div>{{ hello + " " + say() }}</div>

  <!-- 数据绑定指令，v-bind 可以省略 -->
  <input type="text" v-bind:value="inpValue" :disabled="isDisable" />

  <!-- 绑定样式 ---------------------------------------------------->
  <p class="title1" :class="titleClass2">{{ title }}</p>

  <p :class="{ title1: true, [titleClass2]: true }">{{ title }}</p>

  <p :style="{ backgroundColor: '#000', color: '#fff' }">{{ title }}</p>

  <p :style="[{ backgroundColor: '#000' }, { color: '#fff' }]">
    {{ title }}
  </p>

  <!-- style v-bind -->
  <div class="box">box</div>

  <!-- CSS Module -->
  <div class="a b c">无效，CSS Module 是独立的</div>
  <div :class="$style.a">默认 module</div>
  <div :class="[m1.b, m1.c]">m1</div>

  <!-- 指令 ---------------------------------------------------->
  <!-- v-once ，只 render 一次，并缓存，以后每次 render 都会忽略它 -->
  <div v-once>v-once</div>

  <!-- v-pre ，跳过模板编译，如不解析差值语法 -->
  <div v-pre>{{ 不解析插值语法 }}</div>

  <!-- v-cloak ，JS 未解析完成时，隐藏该元素（display: none;），防止闪烁 -->
  <div v-cloak>v-clock</div>

  <!-- v-text 、v-html，即 innerText、innerHTML -->
  <div v-text="'123'"></div>
  <div v-html="'<input />'"></div>

  <!-- v-memo ，缓存
     - 只有依赖的数据变化时才会重新 render，无变化直接跳过 VDOM 构建、diff 和 patch 
     * 空数组即等价于 v-once
     * 为了避免不必要的错误，v-for 的 item 不要使用 v-memo ，只能和 v-for 用在一个元素中
  -->
  <div v-memo="[memoValue]">v-memo</div>

  <!-- 自定义指令 -->
  <div v-xxx="'a'" v-yyy v-zzz></div>

  <!-- v-on 绑定事件，可以简写为 @ -------------------------------------------------------->
  <ul>
    <!-- 只有一行逻辑就可以简写 -->
    <li @click="console.log('click 0')">click 0</li>

    <!-- 无参 -->
    <li @click="click1">click 1</li>

    <!-- 简写则默认传入 $event，也可以主动控制传入 $event -->
    <li @click="click2">click 2-1</li>
    <li @click="click2($event)">click 2-2</li>
    <li @click="click3(1, $event)">click 3</li>

    <!-- 不需要 $event -->
    <li @click="click4(1, 2)">click 4</li>

    <!-- 事件修饰符 -->
    <li @click.stop="console.log('stop')">阻止事件冒泡</li>
    <li @click.prevent="console.log('prevent')">阻止默认行为</li>
    <li @click.once="console.log('once')">只执行一次</li>
  </ul>
</template>

<style scoped lang="less">
.title1 {
  background-color: #000;
}

.title2 {
  color: #fff;
}

.box {
  font-size: v-bind("size");
  border: v-bind("border");
  text-align: v-bind("center.a");
}
</style>

<!-- CSS Module ----------------------------------------------------------------------------------- -->
<style module scoped lang="less">
.a {
  width: 100px;
  height: 100px;
  border: 1px solid #000;
}
</style>

<style module="m1" scoped lang="less">
.b {
  width: 50px;
}

.c {
  height: 50px;
  border: 10px solid #000;
}
</style>
```

### 2.2 表单 v-model 双向绑定

Vue2 ，Vue3 用法一样。

用于绑定表单，是数据绑定、事件绑定的语法糖，所以必须传入响应式数据：

* ttext 、textarea 等默认绑定 value ，监听 input 事件，由于每次输入撤销都会重新 render ，性能就比较差，特别是有动画的场景，解决方法：
  
  * 使用 lazy 修饰符改为 change 事件，只有 enter 或失焦才触发
  
  * 使用防抖，最佳实现是 Vue3 的 customRef

* radio 、checkbox 等，绑定 value 和 change

```
<script>
// Vue2

export default {
  data() {
    return {
      text: "msg",
    };
  },
};
</script>

<template>
  <div>
    <input type="text" v-model="text" />
    <span>{{ text }}</span>
  </div>
</template>

<style scoped></style>
```

```
<script setup lang="ts">
// Vue3

import { ref, reactive } from "vue";

const inpValue = ref("input");
const textAreaValue = ref("textarea");

const radios = reactive({
  value: "b",
  items: [
    { value: "a", text: "选项 A" },
    { value: "b", text: "选项 B" },
    { value: "c", text: "选项 C" },
    { value: "d", text: "选项 D" },
  ],
});

const checkboxs = reactive({
  value: ["b", "c"],
  items: [
    { value: "a", text: "选项 A" },
    { value: "b", text: "选项 B" },
    { value: "c", text: "选项 C" },
    { value: "d", text: "选项 D" },
  ],
});

const agree = ref(true);

const select = reactive({
  value: "2000",
  items: [
    { value: "", text: "请选择年份" },
    { value: "1999", text: "1999年" },
    { value: "2000", text: "2000年" },
    { value: "2001", text: "2001年" },
  ],
});

const inp1 = ref("1");
const inp2 = ref<string | number>("2");
const inp3 = ref("3");
</script>

<template>
  <!-- text、textarea ， :value @input -->
  <div>
    <input type="text" v-model="inpValue" />
    <span>{{ inpValue }}</span>
  </div>
  <div>
    <textarea v-model="textAreaValue"></textarea>
    <span>{{ textAreaValue }}</span>
  </div>

  <!-- radio ， :value @change -->
  <div>
    <label v-for="i in radios.items" :key="i.value">
      <input type="radio" v-model="radios.value" :value="i.value" />
      <span>{{ i.text }}</span>
    </label>
    <p>我已选中 {{ radios.value }}</p>
  </div>

  <!-- checkbox :value @change -->
  <div>
    <label v-for="i in checkboxs.items" :key="i.value">
      <input type="checkbox" v-model="checkboxs.value" :value="i.value" />
      <span>{{ i.text }}</span>
    </label>
    <p>我已选中 {{ checkboxs.value }}</p>
  </div>

  <!-- 单个 checkbox ， :value @change -->
  <div>
    <label for="single">
      <input type="checkbox" id="single" v-model="agree" />
      <span>{{ agree }}</span>
    </label>
  </div>

  <!-- select ， :value @change -->
  <div>
    <select v-model="select.value">
      <option v-for="i in select.items" :key="i.value" :value="i.value">
        {{ i.text }}
      </option>
    </select>
  </div>

  <!-- 表单 v-model 修饰符 -------------------------------------------------------------->
  <!-- 改为 change 事件 -->
  <div>
    <input type="text" v-model.lazy="inp1" />
    <span>{{ inp1 }}</span>
  </div>

  <!--转为 number 
    * 若初始绑定为 string 则还是 string ，需要触发 input 才转 number 
    * 空字符串不转换
    * 若将转为 NaN ，则会去掉后面的字符，直到能转为正常数字为止，如 2a3 转为 2 ，2.. 转为 2
  -->
  <div>
    <input type="text" v-model.number="inp2" />
    <span>{{ inp2 }}</span>
    <span>{{ " " + typeof inp2 }}</span>
  </div>

  <!-- 去掉 string 首尾空格 -->
  <div>
    <input type="text" v-model.trim="inp3" />
    <span>{{ inp3 }}</span>
  </div>
</template>

<style scoped lang="less">
input,
textarea,
select {
  margin: 10px;
}
</style>
```

Vue3 customRef 实现表单 v\-model 防抖：

```
// /src/hooks/vmodel.ts

import { customRef } from "vue";

export function useDebouncedRef<T>(value: T, delay = 1000) {
  let timeout: ReturnType<typeof setTimeout>;

  return customRef<T>((track, trigger) => {
    let current = value;

    return {
      get() {
        track();
        return current;
      },

      set(newValue: T) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          current = newValue;
          trigger();
        }, delay);
      },
    };
  });
}
```

```
<script setup lang="ts">
import { useDebouncedRef } from "@/hooks/vmodel";
const text = useDebouncedRef("msg", 500);
</script>

<template>
  <input type="text" v-model="text" />
  <span>{{ text }}</span>
</template>
```

### 2.3 计算属性、过滤器、侦听器

Vue2 ，Vue3 用法基本一样，区别：

* Vue3 都是 Composition API
  
  * Vue3 由于可以自定义是否为响应式数据，所以会有非响应式数据， wacth 监听非响应式数据时，需要写成函数形式，作为一个依赖
  
  * Vue2 的 watch 配置项 immediate 、deep 默认值都是 false ；Vue3 的 immediate 默认为 false ，deep 默认为 true
  
  * ue3 watch 可以同时监听多个数据
  
  * Vue3 watch 引用类型的 oldVal 有 bug ，值为 newVal

* Vue3 删除了过滤器，新增 watchEffect

computed 、 watch 、watchEffect 都会在数据变化时回调，不同的是：

- 应用场景不同：computed 主要是做数据处理，watch 、watchEffect 则在数据变化时处理一些逻辑

- watch 在 Vue3 才支持同时监听多个数据

- track 不同：
  
  * watch 初始就绑定了依赖，不需要 track ，所以初始不会执行，除非 immediate 为 true
  
  * computed 、watchEffect 需要 track 收集依赖，所以初始会执行一次；注意 computed 是 lazy 的，只有用到才会执行，除非 lazy 为 true
  
  * computed 、watchEffect 依赖的数据 get 逻辑不能异步，否则无法 track ；watch 则同步异步都行

```
<script>
// Vue2

export default {
  data() {
    return {
      a: 1,
      b: 2,
      obj: { k1: 4, k2: { kk: 5 } },
    };
  },

  computed: {
    // 简写
    sum() {
      console.log("computed sum run");
      return this.a + this.b;
    },
  },

  // 过滤器，Vue3 已删除，完全可以用 computed、function 代替
  filters: {
    myToFixed(value) {
      return Math.round(value);
    },
  },

  watch: {
    obj: {
      handler(newVal, oldVal) {
        console.log("obj", newVal, oldVal);
      },

      immediate: true,
      deep: true,
    },

    "obj.k1": function (newVal, oldVal) {
      console.log("obj.k1", newVal, oldVal);
    },
  },
};
</script>

<template>
  <div>
    <div>
      <span>{{ sum }}</span>
      <button @click="++a">add a</button>
    </div>

    <div>{{ 3.14 | myToFixed }}</div>

    <div>
      <button @click="++obj.k2.kk">watch obj</button>
      <button @click="++obj.k1">watch obj.k1</button>
    </div>
  </div>
</template>

<style scoped>
button {
  margin: 0 10px;
}
</style>
```

```
<script setup lang="ts">
// Vue3

import { ref, reactive, computed, watch, watchEffect } from "vue";

/**计算属性 --------------------------------------------------------------------------------
 * 当成属性使用，所以无法传参；不能 return function
 * 具有缓存功能，只有依赖的响应式数据修改了（dirty），才会重新执行；而普通 function 每次都会执行
 * computed 一开始会执行一次，进行 track
 */
const a = ref(1);
const b = ref(2);

// 简写
const sum1 = computed(() => {
  console.log("computed sum1 run");
  return a.value + b.value;
});

// 返回一个 ref 对象
console.log(sum1.value);

// 完整写法
const sum2 = computed({
  get() {
    console.log("computed sum2 get run");
    return a.value + b.value;
  },

  // 参数类型会自动推断
  set(newValue) {
    console.log("computed sum2 set run", newValue);

    // err ，setter 不能修改计算属性本身，只用来处理一些逻辑
    // sum2 = newValue;
  },
});

/**侦听器 ----------------------------------------------------------------------------------
 * 用于监听数据的变化，数据修改就会回调，必须传入响应式数据
 * 响应式数据可以传入单个，也可以是数组形式传入多个，多个则 oldValue 、newValue 也是数组
 * 一开始不执行，除非设置了 immediate ；deep 控制是否深度监听
 */
const c = ref(3);
const obj = reactive({ k1: 4, k2: { kk: 5 } });

// 简写，回调的参数类型会自动推断
watch(c, (newVal, oldVal) => {
  console.log("watch c run", newVal, oldVal);
});

// 完整写法并监听多个
watch(
  [c, obj],
  (newVal, oldVal) => {
    console.log("watch [c, obj] run", newVal, oldVal);

    // true true ，Vue3 监听引用类型的 oldVal 有 bug ，值为 newVal ；immediate 首次 oldVal 为 undefined 才为 false
    console.log(oldVal[1]?.k1 === newVal[1]?.k1);
    console.log(oldVal[1]?.k2.kk === newVal[1]?.k2.kk);
  },
  { immediate: true, deep: true }
);

// 监听非响应式数据，必须写成函数形式，作为一个依赖
watch(
  () => obj.k1,
  (newVal, oldVal) => {
    console.log("watch obj.k1 run", newVal, oldVal);

    // console.log()
  }
);

/**watchEffect -----------------------------------------------------------------------------------
 * 内部使用的响应式数据变化时，就重新执行
 * 一开始执行一次，进行 track
 */
watchEffect(() => {
  a.value;
  b.value;
  console.log('watchEffect run""');
});
</script>

<template>
  <!-- 计算属性，watchEffect 测试 -->
  <div>
    <span>sum1：{{ sum1 + " , " }}</span>
    <span>sum2：{{ sum2 }}</span>
  </div>
  <div>
    <button @click="++a">add a</button>
    <button @click="++b">add b</button>
    <button @click="sum2 = 123">set sum2</button>
  </div>

  <!-- watch 测试 -->
  <div>
    <button @click="++c">test watch c ，add c</button>
    <button @click="++obj.k2.kk">test watch [c, obj] ，add obj.k2.kk</button>
    <button @click="++obj.k1">test watch obj.k1 ，add obj.k1</button>
  </div>
</template>

<style scoped lang="less">
button {
  margin: 10px 10px 10px 0;
}
</style>
```

### 2.4 条件渲染、列表渲染

Vue2 ，Vue3 基本一样，区别：

* Vue2 的 v\-if 优先级低于 v\-for ，一起使用则 warn ，因为便利出来再删除没有必要也浪费性能；Vue3 的 v\-if 优先级高于 v\-for ，一起使用则 err ，因为 if 的时候元素还没有便利出来

v\-if 、v\-show 的区别：

* false 时，v\-if 直接删除元素，适合不需要重复切换的场景，提升初始性能

* false 时，v\-show 则设置 display: none; ，适合需要平凡切换的场景，防止删除元素消耗性能

* 因此两者一起使用，v\-if 生效，应该避免这么做

v\-if 。v\-for 一起使用的替代：

* 渲染部分子项的场景，使用 computed filter 一个新 Array

* 显示隐藏整个 list 的场景，v\-if 父节点，或者外部包裹一个虚拟节点 \<template v\-if="boolean" \>
  
  * template 在 Vue2 默认显示、Vue3 默认不显示
  
  * template 只能使用 v\-if ，无法使用其他指令如 v\-show 、v\-for

```
<script>
export default {
  data() {
    return {
      isShow: true,
      list: [
        { id: 1, value: 10 },
        { id: 2, value: 20 },
        { id: 3, value: 30 },
      ],
    };
  },
};
</script>

<template>
  <div>
    <div>
      <button @click="isShow = !isShow">switch show</button>
      <div v-show="isShow">v-show</div>
      <div v-if="isShow">v-if</div>
    </div>

    <ul>
      <li v-for="i in list" :key="i.id">{{ i.value }}</li>
    </ul>
  </div>
</template>
```

```
<script setup lang="ts">
// Vue3

import { ref, reactive, computed } from "vue";

const isShow = ref(true);

const list = reactive([
  { id: 1, value: 10 },
  { id: 2, value: 20 },
  { id: 3, value: 30 },
]);

const filterList = computed(() => {
  return list.filter((i: (typeof list)[0]) => i.value > 15);
});
</script>

<template>
  <!-- 条件渲染 
     * v-show 和 v-if、v-else、v-else-if
     * v-if 优先级高于 v-show ，只有 v-if 显示元素时，v-show 才有意义
     * v-show、v-if 和 v-once 一起使用时，由于 v-once 只渲染一次，所以显示隐藏状态只会是初始状态 
  -->
  <div>
    <button @click="isShow = !isShow">switch show</button>
    <div v-show="isShow">v-show</div>
    <div v-if="isShow">v-if</div>
  </div>

  <!-- 列表渲染 
     * 便利 arr 编译后是使用 arr.map() ，不需要 index 也可以 i in list
     * 也可以遍历 Object ，(value, key, index) in obj
     * 也可以用数字 i in 10
     * key 默认为 index ，最好给 key 唯一的 id ，提高 diff 算法性能 
  -->
  <ul>
    <li v-for="(i, iIndex) in list" :key="i.id">
      {{ `index: ${iIndex}，value: ${i.value}` }}
    </li>
  </ul>

  <!-- v-if 、v-for 结合，不要直接写在一起 --------------------------------------------------------------
     * 显示部分子项，就用 computed filter 新的 arr
     * 显示隐藏整个 list ，就 v-if 父节点或者虚拟节点 template
  -->

  <!-- err
  <ul>
    <li v-if="i.value > 15" v-for="i in list" :key="i.id">
      {{ i.value }}
    </li>
  </ul> 
  -->

  <!-- computed filter -->
  <ul>
    <li v-for="i in filterList" :key="i.id">{{ i.value }}</li>
  </ul>

  <!-- v-if 父节点 -->
  <ul v-if="false">
    <li v-for="i in list" :key="i.id">{{ i.value }}</li>
  </ul>

  <!-- template 默认 false -->
  <template v-if="true">
    <div v-for="i in list" :key="i.id">{{ i.value }}</div>
  </template>
</template>

<style scoped lang="less">
ul {
  margin: 20px 0;
}
</style>
```

长列表渲染，会消耗大量性能，解决方法：

* 分页

* 分片加载更多

* 虚拟列表，也叫虚拟滚动，只渲染当前看得见的元素

* 若必须一次性全部渲染：
  
  * 可以用 v\-once 、v\-memo ，但场景不太常见
  
  * raf 延迟加载，通常用于组件分片

```
pnpm add vue-virtual-scroller@next
```

```
declare module "vue-virtual-scroller" {
  import { DefineComponent } from "vue";

  export const RecycleScroller: DefineComponent<any, any, any>;
  export const DynamicScroller: DefineComponent<any, any, any>;
  export const DynamicScrollerItem: DefineComponent<any, any, any>;
}
```

```
<script setup lang="ts">
import { ref, reactive, computed, onMounted } from "vue";

import { RecycleScroller } from "vue-virtual-scroller";
import "vue-virtual-scroller/dist/vue-virtual-scroller.css";

interface ListItem {
  id: number;
  value: number;
}

const list = reactive<ListItem[]>([]);
for (let i = 1; i <= 1000; i++) {
  list.push({
    id: i,
    value: i,
  });
}

// 分页 ---------------------------------------------------------------------------------
const page = ref(1);
const size = ref(5);

const pageList = computed(() => {
  const start = (page.value - 1) * size.value;
  const end = start + size.value;
  return list.slice(start, end);
});

const addPage = () => {
  if (page.value >= Math.ceil(list.length / size.value)) return;
  ++page.value;
};

const reducePage = () => {
  if (page.value <= 1) return;
  --page.value;
};

// 分片加载更多 --------------------------------------------------------------------------
const loadingRef = ref<HTMLDivElement | null>(null);
const scrollerRef = ref<HTMLDivElement | null>(null);

const loadingFlag = ref(true);
const loadingSize = ref(10);
const endIndex = ref(10);

const isEnd = computed(() => currentList.value.length >= list.length);

const currentList = computed(() => {
  return list.slice(0, endIndex.value);
});

onMounted(() => {
  const ob = new IntersectionObserver(
    (entries) => {
      if (!entries[0].isIntersecting || !loadingFlag.value || isEnd.value) {
        console.log(123);
        return;
      }

      loadingFlag.value = false;
      setTimeout(() => {
        endIndex.value += loadingSize.value;
        loadingFlag.value = true;
      }, 1000);
    },

    {
      root: scrollerRef.value,
    }
  );

  ob.observe(loadingRef.value!);
});
</script>

<template>
  <!-- 分页 -->
  <div class="container page">
    <div>
      <div v-for="i in pageList" :key="i.id">{{ i.value }}</div>
    </div>
    <div>
      <button @click="reducePage">-</button>
      <span>{{ " " + page + " " }}</span>
      <button @click="addPage">+</button>
    </div>
  </div>

  <!-- 分片加载更多 -->
  <div class="container load-scroller">
    <div v-for="i in currentList" :key="i.id">{{ i.value }}</div>
    <div ref="loadingRef" v-show="!isEnd">loading...</div>
  </div>

  <!-- 虚拟滚动 -->
  <RecycleScroller
    class="container"
    :items="list"
    :item-size="20"
    key-field="id"
  >
    <template #default="{ item }">
      <div class="item">{{ item.value }}</div>
    </template>
  </RecycleScroller>
</template>

<style scoped lang="less">
.container {
  margin: 20px;
  width: 100px;
  height: 200px;
  border: 1px solid #000;
}

.page {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.load-scroller {
  overflow: scroll;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.item {
  text-align: center;
}
</style>
```

### 2.5 生命周期

生命周期函数、也叫生命周期钩子，在 Vue 特定时刻回调。

Vue2 、Vue3 区别：

* Vue3 都是 Composition API ，且有 on 前缀；若混用，则 Composition API 比 Options API 先执行，如 setup 比 created 先执行

* setup 相当于 beforeCreate 、created ，没有这两个的 Composition API ；this 为 undefined ；

* Vue3 中无 el 就不会执行任何生命周期，而 Vue2 会直行道 created 阶段，若无 el 就不会继续生命周期
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <body>
      <div id="app"></div>
  
      <!-- vue2 -->
      <!-- <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
      <script>
        new Vue({
          // el: "#app",
          created() {
            console.log(123);
          },
        });
      </script> -->
  
      <!-- vue3 -->
      <script src="https://unpkg.com/vue@3.5.4/dist/vue.global.js"></script>
      <script>
        const { createApp, ref } = Vue;
        createApp({
          created() {
            console.log(123);
          },
        });
        // .mount("#app");
      </script>
    </body>
  </html>
  ```

* Vue3 可以注册多个相同的生命周期钩子，按照代码顺序执行，注意必须在 setup 阶段同步执行；Vue2 直接配置注册，但只能配置一个

* 销毁阶段 destroyed 改为 unMounted

* Vue3 新增 3 个钩子 ，onRenderTracked ，onRenderTriggered ，onServerPrefetch,

```
<script>
// Vue2

export default {
  data() {
    return {
      a: 1,
    };
  },

  beforeCreate() {},
  created() {
    console.log("created");
  },

  beforeMount() {},
  mounted() {
    console.log("mounted");
  },

  beforeUpdate() {},
  updated() {
    this.$nextTick(() => console.log("nextTick", this.a));
  },

  beforeDestroy() {},
  destroyed() {},

  activated() {},
  deactivated() {},
};
</script>

<template>
  <div>
    <button @click="++a">add a</button>
    <span>{{ " " + a }}</span>
  </div>
</template>
```

```
<script setup lang="ts">
// Vue3

import {
  ref,
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  nextTick,
  onBeforeUnmount,
  onUnmounted,
  onActivated,
  onDeactivated,
  onErrorCaptured,
  onRenderTracked,
  onRenderTriggered,
  onServerPrefetch,
} from "vue";

// 组件生命周期 ----------------------------------------------------------------------------------

/**初始化阶段
 * 等价于 Vue2 的 create 阶段
   - beforeCreate ：准备数据，初始化
   - created ：数据准备完毕，可以使用 data 、computed 等，可以 ajax
 * 此时组件未挂载，所以整个 setup 的 this 都是 undefined
 * 此时数据已经准备完毕
 */
console.log(this);

const a = ref(1);
const spanRef = ref<HTMLSpanElement | null>(null);

/**挂载阶段
 * beforeMount ：template 编译为 render 函数，生成 VDOM
 * mounted ：真实 DOM 渲染完毕，可以获取 DOM
 */
onBeforeMount(() => console.log("beforeMount"));

//1 2 3 , Vue3 可以注册多个相同生命周期钩子
onMounted(async () => {
  console.log("mounted", 1);

  // 生命周期使用 async await 语法没问题，但可能会有歧义，因为异步执行已经不是这个生命周期的时机了
  await Promise.resolve();
  console.log("mounted", 3);
});
onMounted(() => console.log("mounted", 2));

// err ，禁止这么做，必须在 setup 时机中同步注册，因为异步执行注册时 mounted 已经过去了
// setTimeout(() => onMounted(() => console.log("mounted", 4)));

/**DOM 更新阶段
 * 钩子：
   - beforeUpdate ：生成新 VDOM ，diff 比较
   - updated ：真实 DOM 更新完毕，但需要异步渲染
 * 异步更新：
   - 通过异步更新，多次数据更新只会执行一次依赖更新，更新时：beforeUpdate - render - updated
   - 若在 updated 外想要得到更新完的真实 DOM ，则使用 nextTick ，在异步更新后下一个微任务中获取
   - beforeUpdate 在所有依赖执行完后，且只有 render 用到的数据修改后才会执行；这是因为只有执行 render 才会有生命周期，且 render 是最后收集的依赖
 * 禁止在更新钩子内部修改响应式数据，防止无线执行更新
 */
onBeforeUpdate(() => {
  // 2 1 ，此时真实 DOM 还未更新
  console.log("beforeUpdate", a.value, spanRef.value?.textContent);

  // 2 2 ，真实 DOM 更新完毕
  nextTick(() => console.log("nextTick", a.value, spanRef.value?.textContent));

  // 也可以
  // await nextTick();
});

onUpdated(() => {
  // 2 2 ，真实 DOM 更新完毕
  console.log("updated", a.value, spanRef.value?.textContent);

  // 禁止这么做
  // ++a.value;
});

/**卸载阶段（销毁）
 * beforeUnMount ：卸载之前，DOM 还在，用于清除需要调用 DOM 的副作用，如事件监听等
 * unMounted ：卸载完毕，DOM 清除了，此时只能清除不需要调用 DOM 的副作用，如定时器 、window 事件等
 */
onBeforeUnmount(() => console.log("beforeUnMount"));
onUnmounted(() => console.log("unMounted"));

// 路由组件钩子 ---------------------------------------------------------------------------

// 路由激活
onActivated(() => console.log("activated"));

// 路由失活
onDeactivated(() => console.log("deactivated"));

// err 捕获钩子 -----------------------------------------------------------------------------
onErrorCaptured((err, instance, info) => {
  console.log("errorCaptured 捕获错误", err, info);

  // 是否进一步向上冒泡传播，默认 undefined 等同于 true
  return false;
});

/**响应式 -------------------------------------------------------------------------------------
 * e.effect ：收集的依赖
 * e.target ：响应式数据
 * e.key ：reactive 的 key ，如果是 ref 则是 "value"
 * e.type ：操作类型，如 get
 * 在 beforeMount 后，mounted 之前执行；在 beforeUpdate 后，updated 之前执行
 */
// track 时回调
onRenderTracked((e) => console.log("track"));

// trigger 时回调
onRenderTracked((e) => console.log("trigger"));

// SSR ------------------------------------------------------------------------------------------
// SSR 渲染前执行异步数据加载，仅在服务端执行，客户端不执行
onServerPrefetch(async () => {});
</script>

<template>
  <button @click="++a">add a</button>
  <span ref="spanRef">{{ " " + a }}</span>
</template>
```

父子组件生命周期的顺序，多个子组件就按顺序依次走完各个子组件的生命周期：

```
初始化、挂载
父：bc -> c -> bm                    | -> m 
子：            |-> bc -> c -> bm -> m

更新
父：bu ->         | -> u
子：   | -> bu -> u 

销毁
父：bd ->         | -> d
子：   | -> bd -> d 
```

## 3 组件

基本：

- 组件命名：大驼峰，如 AaaBbb ，aaa\-bbb ，可以单标签、双标签

- 组件注册：
  
  * 局部注册，仅当前组件可用：
    
    ```
    export default {
      // key 为组件标签名，不是组件 name
      components: { Cpn: Cpn },
    }
    ```
* 全局注册，全部组件均可用：
  
  ```
  // /src/main.ts ，第一个参数为组件标签名，不是组件 name
  
  // Vue2
  Vue.component("Cpn", Cpn);
  // Vue3
  createApp(App).component("Cpn", Cpn).mount('#app')
  ```
  
  若全局注册分包的组件，由于必须在 main\.ts 中注册，打包后的主包就也会存一份分包代码，这样分包的意义就不大了，所以全局注册适合不分包的小组件。
- v\-if 都会走一遍组件生命周期；而 v\-show 不会，因为不删除组件；应该避免大量 v\-if 组件的场景、组件渲染性能消耗比原生 DOM 大得多

### 3.1 组件通信

#### 3.1.1 props 、emit 、透传、获取 DOM 和组件实例

实现父子组件通信。

Vue2 、Vue3 区别：

* props ：
  
  * Vue2 也会吧 props 代理到 this 中，因此 data 等就无法声明同名资源
  
  * Vue3 把 props 抽离出来，单独使用
- 自定义组件默认无法绑定原生事件，编译时都认为是自定义事件：
  
  - Vue2 可以使用 .native 绑定原生事件，绑定的是子组件根元素
  
  - Vue3 删除了 .native ，只能在子组件内部触发原生事件再 emit 自定义事件

- Vue3 新增 emits 选项 ：
  
  - Vue2 可以 emit 任何自定义事件
  
  - Vue3 若未配置 emits 选项也是可以 emit 任何自定义事件，但若配置了 emits 则只能 emit 已声明的自定义事件

- Vue3 新增 expose 函数：
  
  * Vue2 子组件所有的资源父组件都可以使用
  
  * Vue3 默认和 Vue2 一样，但若执行了 expose 函数就只能使用暴露的资源

- 透传：
  
  * Vue2：
    
    * this\.\$attrs 保存了所有父组件传入但未在 props 声明的资源
    
    * this\.\$listeners ：保存了所有父组件监听的自定义事件，不保存 \.native 原生事件
    
    * this\.\$slots ：保存了所有插槽
  
  * Vue3：
    
    * attrs 、slots 存放于 setup 第二个参数 context ；script setup 则需要 useAttrs 、useSlots 获取
    
    * Vue3 删除 listener ，整合到了 attrs ：且 Vue3 新增了 emits 选项，使得 attrs 只会保存父组件已传入但未在 emits 声明的自定义事件
* 获取 DOM 、组件实例：
  
  * Vue2 直接用 this\.\$refs\.xxx 获取实例；还可以用 this\.\$children 、this\.\$parent 、this\.\$root
  
  * Vue3 需要 ref 定义；删除了 \$children ，另外两个还可以用 getCurrentInstance 获取

（1）Vue2

```
<script>
// 子组件

export default {
  // props 三种写法

  // props: ["num", "arr"],

  // props: {
  //   num: Number,
  //   fn: Array,
  // },

  props: {
    num: {
      type: Number,
      required: true,
      default: 0,
    },

    arr: {
      type: Array,
      required: false,
      default: () => [],
    },

    fn: {
      type: Function,
      required: false,
      default: () => "props fn",
    },
  },

  methods: {
    clickBtn() {
      this.$emit("myevent", 123);
    },
  },

  created() {
    console.log(this.num, this.arr, this.fn());

    console.log(this.$attrs);
    console.log(this.$listeners);
    console.log(this.$slots);
  },
};
</script>

<template>
  <div>
    <div>{{ num }}</div>
    <div>{{ arr }}</div>
    <div>{{ fn() }}</div>

    <div>{{ typeof $emit }}</div>
    <button @click="clickBtn">emit</button>
  </div>
</template>
```

```
<script>
// 父组件

import Cpn from "./Cpn.vue";

export default {
  components: { Cpn },

  methods: {
    mouseenterFn() {
      console.log("原生事件");
    },

    myevent(e) {
      console.log(e);
    },
  },

  mounted() {
    // 所有子组件、一个或没有父组件、一个根组件 App
    console.log(this.$children, this.$parent, this.$root);

    // 指定子组件或 DOM 元素
    console.log(this.$refs["cpnRef"]);
  },
};
</script>

<template>
  <div>
    <Cpn
      ref="cpnRef"
      :num="0"
      @mouseenter.native="mouseenterFn"
      @myevent="myevent"
      :xxx="'xxx'"
      @yyy="() => 'yyy'"
    />
  </div>
</template>
```

（2）Vue3 script setupt

```
<script setup lang="ts">
/**子组件 -----------------------------------------------------------------------------------
 * defineProps, withDefaults, defineEmits, defineExpose 都是宏定义，不需要导入
 * 每种宏只能存在一个，其中 defineProps, withDefaults 只能有一种
 */

import { ref, useAttrs, useSlots } from "vue";
import type { Ref } from "vue";

const cpnData = ref(456);

// props ，属性只读的响应式数据，父传子，也可以通过传递 fn 实现子传 父 ----------------------------------------------
// props 的类型必须是一个 object
interface Props {
  num: number;
  fn: (cpnData: number) => void;
  msg?: string;
  arr?: number[];
}

// const props = defineProps<Props>();

const props = withDefaults(defineProps<Props>(), {
  // 默认值，必选参数就不必设置默认值了，ts 会检查
  msg: "msg",

  // 除了 function外，其他引用类型需要写成函数形式，防止多个父组件使用该组件时共享引用
  arr: () => [],
});

console.log(props.num, props.fn);
console.log(props.msg, props.arr);

// 自定义事件，子传父 -------------------------------------------------------------------------
export type EventPayload = { text: string; data: number };

interface Emits {
  (type: "myevent", payload?: EventPayload): void;
  (type: "mouseenter", payload?: EventPayload): void;
}

const emit = defineEmits<Emits>();

// 也可以这么写，但是 payload 类型为 any
// const emit = defineEmits(["myevent", "mouseenter"]);

/**defineExpose ---------------------------------------------------------------------------
 * 父组件 cpnRef.value 是 Proxy 响应式数据，保存了 expose 的资源和 $el 等，类似反过来的 props
 * 规范中应该通过组件通信修改数据
 * 注意：
   - Vue3.2 secript setup 只有 expose 暴漏的资源，父组件才能使用，防止父组件修改数据；
     原理是 script setup 编译为 setup() {} 后，执行了 expose 函数
   - Vue3.0 setup() {} 的写法，默认不会执行 expose 函数，这种情况下全部 setup() 中 return 的资源父组件都可以使用；
     当然这种写法也可以手动执行 expose 函数
 */
interface Expose {
  btnRef: Ref<HTMLButtonElement | null>;
  a: Ref<number>;
}

const btnRef = ref<HTMLButtonElement | null>(null);
const a = ref(0);

defineExpose<Expose>({ btnRef, a });

setInterval(() => {
  console.log(a.value);
}, 2000);

// 透传，都是 Proxy 响应式数据 ----------------------------------------------------------------------
const attrs = useAttrs();
const slots = useSlots();

console.log(attrs, slots);

// 测试 ------------------------------------------------------------------------------------------
// 原生事件
const keydownFn = () => {
  // props.fn(cpnData.value);
  // emit("mouseenter", { text: "mouseenter", data: cpnData.value });
};

// 自定义事件
const myEventFn = () => {
  // props fn 或 emit 自定义事件 ，emit 第二个参数为自定义事件对象
  // props.fn(cpnData.value);
  emit("myevent", { text: "myevent", data: cpnData.value });
};
</script>

<!-- 
<script lang="ts">
export default {
  mounted() {
    // 依然可用
    console.log(this.$attrs, this.$slots);

    // undefined ，已删除
    console.log(this.$listeners);
  },
};
</script> 
-->

<template>
  <div @mouseenter="keydownFn">
    <button ref="btnRef" @click="myEventFn">btn</button>

    <!-- 若 props 和自定义数据冲突，优先使用自定义数据 -->
    <p>{{ num }}</p>
    <p>{{ props.num }}</p>
    <p>{{ $props.num }}</p>

    <p>{{ typeof emit }}</p>
    <p>{{ typeof $emit }}</p>

    <p>{{ $attrs }}</p>
    <p>{{ $slots }}</p>
  </div>
</template>
```

```
<script setup lang="ts">
// 父组件 ，子组件不需要注册，编译后会自动配置注册

import { ref, onMounted, getCurrentInstance } from "vue";
import Cpn from "@/Cpn.vue";
import type { EventPayload } from "@/Cpn.vue";

const num = ref(123);
const fn = (cpnData: number) => console.log(cpnData);
const callback = (e?: EventPayload) => console.log(e);

/**获取子组件实例 ---------------------------------------------------
 * 若是 setup() 写法，则需要 return cpnRef
 * DPM 和组件实例都只有在 mpunted 后才能拿到
 */
const cpnRef = ref<InstanceType<typeof Cpn> | null>(null);

onMounted(() => {
  const { $el, btnRef, a } = cpnRef.value!;

  /**$el 不需要 expose
   * 若子组件有且只有一个根元素，则 $el 就是该根元素
   * 若没有根元素：
     - 则使用虚拟节点 <Fragment> 包裹，生成一个空文本节点 #text 来保证 DOM 树结构
     - 这种情况只能在子组件中 ref 需要的 DOM 元素再 expose 给父组件使用
  * 若子组件为空 template ，则得到一个空注释节点
  */
  console.log($el, btnRef);

  console.log(a);

  // getCurrentInstance 不能获取子元素、子组件
  const instance = getCurrentInstance();
  const parent = instance?.proxy?.$parent;
  const root = instance?.proxy?.$root;
  console.log(parent, root);
});
</script>

<!-- 
<script lang="ts">
export default {
  mounted() {
    // 依然可用
    console.log(this.$parent, this.$root);

    // undefined ，已删除
    console.log(this.$children);
  },
};
</script> 
-->

<template>
  <Cpn
    ref="cpnRef"
    :num="num"
    :fn="fn"
    msg="hello"
    @mouseenter="callback"
    @myevent="callback"
    :xxx="'xxx'"
    @yyy="console.log('yyy')"
  />
</template>
```

（3）script setup 编译为 setup\(\)

```
# 这个 vite 插件可以查看编译结果
pnpm add -D vite-plugin-inspect
```

```
// /src/vite.config.ts ，npm run dev 会打印 Inspect 地址，浏览器打开查看即可

import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import inspect from "vite-plugin-inspect";

export default defineConfig({
  plugins: [vue(), inspect()],
});
```

```
<!-- 
<script setup lang="ts">
// 子组件

import { ref, useAttrs, useSlots } from "vue";

interface Props {
  num?: number;
}

interface Emits {
  (type: "myevent", payload?: any): void;
}

const props = withDefaults(defineProps<Props>(), { num: 0 });
console.log(props.num);
const num = ref(-1);

const emit = defineEmits<Emits>();
emit("myevent");

const attrs = useAttrs();
const slots = useSlots();
console.log(attrs, slots);

const a = ref(0);
defineExpose({ a });
</script> 
-->

<script lang="ts">
// 编译后的大概结构

import { defineComponent, ref } from "vue";

export default defineComponent({
  // 写法和 Vue2 一样
  props: {
    num: {
      type: Number,
      required: false,
      default: 0,
    },
  },

  // Vue3 新增，若不配置，则 Vue 不会校验 emit ，即和 Vue2 一样可以 emit 任何自定义事件；若配置了，则只能 emit 这里声明的自定义事件
  // script setup 由于必须 defineEmits 才能拿到 emit ，所以编译后必然会有这个选项
  emits: ["myevent"],

  setup(props, context) {
    const { emit, attrs, slots, expose } = context;

    console.log(props.num);
    const num = ref(-1);

    emit("myevent");

    console.log(attrs, slots);

    // 不执行 expose 则所有 return 的资源父组件都可以使用
    const a = ref(123);
    expose({ a });

    return { num, props, emit, a };
  },
});
</script>

<template>
  <!-- 注意，当父组件传入了多余的 props 和自定义事件时，子组件必须有且只有一个根元素来接收这些到 attrs 中 -->
  <!-- 
  <div>
    <p>1</p>
    <p>2</p>
  </div> 
  -->

  <!-- 若想要保持多跟绝点，则需要手动把 $attr 注入到某个元素中 -->
  <div>1</div>
  <div v-bind="$attrs">2</div>

  <!-- props 的属性不需要 return 也能使用，若和 return 的自定义数据冲突，优先使用 return 的 -->
  <div>{{ num }}</div>
</template>
```

```
<!-- 
<script setup lang="ts">
// 父组件

import { ref } from "vue";
import Cpn from "./Cpn.vue";

const cpnRef = ref<InstanceType<typeof Cpn> | null>(null);
</script> 
-->

<script lang="ts">
// 父组件，编译后的大概结构

import { defineComponent, ref } from "vue";
import Cpn from "./Cpn.vue";

export default defineComponent({
  components: { Cpn },

  setup() {
    const cpnRef = ref<InstanceType<typeof Cpn> | null>(null);
    return { cpnRef, Cpn };
  },
});
</script>

<template>
  <Cpn
    ref="cpnRef"
    @myevent="console.log('msg')"
    xxx="xxx"
    @yyy="console.log('yyy')"
  />

  <!-- 不当成组件使用时，需要 return -->
  {{ typeof Cpn }}
</template>
```

#### 3.1.2 组件 v\-model

（1）单项数据流

规范中，规定数据只能从上层组件流向下层组件，这是为了保证单项数据流，便于代码维护。

因此 props 是只读的，若修改 props 的属性则会 err ，但当修改 props 中的引用类型内部的数据时就检测不到，需要谨慎，特别是子组件中的表单 v\-model 的场景。

可以用 computed 解决：

（2）组件 v\-model

父组件传入 props、emit 的语法糖。

Vue2 、Vue3 区别：

* Vue2 默认 props 为 value ，默认 event 为 input ；Vue3 默认 props 为 modelValue  ，默认 event 为 update\:modelValue

* Vue2 通过 model 配置项修改默认 props 和 emit ，只能有一个 v\-model 但可以通过 \.sync 修饰符使用多个数据（事件为 update\:xxx ）；Vue3 可以使用多个 v\-model 且任意命名，因此删除了 model 和 \.sync 修饰符；

* Vue3 新增组件 v|-model 自定义修饰符

Vue2 ：

```
<script>
// 子组件

export default {
  // 修改默认绑定
  // model: {
  //   prop: "val",
  //   event: "inp",
  // },
  // props: ["val", "num"],

  props: ["value", "num"],
};
</script>

<template>
  <div>
    <!-- 测试 model -->
    <!-- <button @click="$emit('inp', val + 1)">add {{ val }}</button> -->

    <button @click="$emit('input', value + 1)">add {{ value }}</button>
    <button @click="$emit('update:num', num + 1)">add {{ num }}</button>
  </div>
</template>
```

```
<script>
// 父组件

import Cpn from "./Cpn.vue";

export default {
  components: { Cpn },

  data() {
    return {
      cnt1: 0,
      cnt2: 0,
    };
  },
};
</script>

<template>
  <div>
    <Cpn v-model="cnt1" :num.sync="cnt2" />
  </div>
</template>
```

Vue3 ：

```
<script setup lang="ts">
// 子组件

const props = defineProps<{
  modelValue: number;
  num: number;

  // 自定义修饰符
  modelModifiers?: { xxx: boolean };
  numModifiers?: { xxx: boolean };
}>();

// { xxx: true } ，若没有传入修饰符则整个为 undefined
console.log(props.modelModifiers);
console.log(props.numModifiers);

const emit = defineEmits(["update:modelValue", "update:num"]);
</script>

<template>
  <button @click="emit('update:modelValue', props.modelValue + 1)">
    add {{ props.modelValue }}
  </button>

  <button @click="emit('update:num', props.num + 1)">
    add {{ props.num }}
  </button>
</template>
```

```
<script setup lang="ts">
// 父组件

import { ref } from "vue";
import Cpn from "./Cpn.vue";

const cnt1 = ref(0);
const cnt2 = ref(0);
</script>

<template>
  <!-- 等价于
  <Cpn
    :modelValue="cnt1"
    :modelModifiers="{ xxx: true }"
    :num="cnt2"
    :numModifiers="{ xxx: true }"
    @update:modelValue="cnt1 = $event"
    @update:num="cnt2 = $event"
  /> 
  -->

  <Cpn v-model.xxx="cnt1" v-model:num.xxx="cnt2" />
</template>
```

#### 3.1.3 非父子组件通信

（1）依赖注入

祖先 provide 数据，后代组件 inject 响应式注入数据。

Vue2 、Vue3 用法一样，区别：

* Vue2 必须 provide 引用类型才会有响应式，而 Vue3 都可以

Vue2 ：

```
<script>
// 子组件

export default {
  inject: ["msg", "updateMsg"],
};
</script>

<template>
  <div>
    <input
      type="text"
      :value="msg.value"
      @change="updateMsg($event.target.value)"
    />

    <p>{{ msg.value }}</p>
  </div>
</template>
```

```
<script>
// 父组件

import Cpn from "./Cpn.vue";

export default {
  components: { Cpn },

  data() {
    return {
      msg: { value: "msg" },
    };
  },

  methods: {
    updateMsg(newMsg) {
      this.msg.value = newMsg;
    },
  },

  provide() {
    return {
      msg: this.msg,
      updateMsg: this.updateMsg,
    };
  },
};
</script>

<template>
  <Cpn />
</template>
```

Vue3 ：

```
<script setup lang="ts">
// 子组件

import { inject } from "vue";

// 第二个参数为默认值
const msg = inject("msg", "");
const updateMsg = inject("updateMsg", (newMsg: string) => {});
</script>

<template>
  <input
    type="text"
    :value="msg"
    @change="updateMsg(($event.target! as HTMLInputElement).value)"
  />

  <span>{{ " " + msg }}</span>
</template>
```

```
<script setup lang="ts">
// 父组件

import { ref, provide } from "vue";
import Cpn from "./Cpn.vue";

const msg = ref("msg");
const updateMsg = (newMsg: string) => (msg.value = newMsg);

provide("msg", msg);
provide("updateMsg", updateMsg);
</script>

<template>
  <Cpn />
</template>
```

（2）事件总线

任意组件通信，仅 Vue2 可用：

```
// /src/eventbus/index.js

// 通过 $on 、$off 实现，为了更好的维护，可以抽离出来，也可以实现多个事件总线
import Vue from "vue";
export default new Vue();
```

```
<script>
// 子组件

import EventBus from "./eventbus";

export default {
  data() {
    return {
      msg: "",
    };
  },

  methods: {
    getMsg(msg) {
      this.msg = msg;
    },

    updateMsg(e) {
      EventBus.$emit("updateMsg", e.target.value);
    },
  },

  created() {
    EventBus.$on("getMsg", this.getMsg);
  },

  beforeDestroy() {
    EventBus.$off("getMsg", this.getMsg);
  },
};
</script>

<template>
  <div>
    <input type="text" :value="msg" @change="updateMsg" />

    <p>{{ msg }}</p>
  </div>
</template>
```

```
<script>
// 父组件

import EventBus from "./eventbus";
import Cpn from "./Cpn.vue";

export default {
  components: { Cpn },

  data() {
    return {
      msg: "msg",
    };
  },

  methods: {
    emitMsg() {
      EventBus.$emit("getMsg", this.msg);
    },

    updateMsg(newMsg) {
      this.msg = newMsg;
      this.emitMsg();
    },
  },

  created() {
    EventBus.$on("updateMsg", this.updateMsg);
  },

  mounted() {
    this.emitMsg();
  },

  beforeDestroy() {
    EventBus.$off("updateMsg", this.updateMsg);
  },
};
</script>

<template>
  <Cpn />
</template>
```

Vue3 删除了 \$on 、\$off 、\$emit ，可以使用第三方库 mitt 代替。

### 3.2 组件扩展

#### 3.2.1 mixin 、hook

用于逻辑扩展

（1）mixin

混入，用于扩展 Options API  ，若产生冲突：

* 非声明周期：冲突不覆盖，直接忽略，再补上没有的

* 生命周期：全部执行，使用的资源同上

```
// /src/mixins/index.js

export const mixinA = {
  data() {
    return { a: 0 };
  },

  computed: {
    sum() {
      return this.a * 0;
    },
  },

  methods: {
    func: () => console.log("mixinA"),
  },

  mounted() {
    // 2
    console.log("mounted mixinA", this.a);
  },
};

export const mixinB = {
  mounted() {
    // 2
    console.log("mounted mixinB", this.a);
  },
};
```

```
<script>
import { mixinA, mixinB } from "./mixins";

export default {
  mixins: [mixinA, mixinB],

  // 也可以继承，等价于单个的 mixins
  extends: mixinA,

  data() {
    return { a: 2 };
  },

  computed: {
    sum() {
      return this.a * 2;
    },
  },

  methods: {
    func: () => console.log("func"),
  },

  mounted() {
    console.log("mounted", this.a);
  },
};
</script>

<template>
  <div>
    <!-- 2 4 func -->
    <p>{{ a }}</p>
    <p>{{ sum }}</p>
    <p>{{ func() }}</p>
  </div>
</template>
```

（2）hook

Vue3 新特性，即 Composition API ，完全可以替代 mixin ，本质是一个函数，有独立的作用于，所以不会产生冲突，hook 命名规范为 useXxx ：

```
// /src/hooks/useHidden.ts ，v-if 、v-show 通用 hook

import { ref } from "vue";
import type { Ref } from "vue";

type UseHiddenReture = [Ref<boolean>, () => void];

export function useHidden(value: boolean = false): UseHiddenReture {
  const isShow = ref(value);
  const switchShow = () => (isShow.value = !isShow.value);

  return [isShow, switchShow];
}
```

```
<script setup lang="ts">
import { useHidden } from "./hooks/useHidden";
const [isShow, switchShow] = useHidden(true);
</script>

<template>
  <button @click="switchShow">switch</button>
  <p v-show="isShow">text</p>
</template>
```

内置 hook ：

```
<script setup lang="ts">
// 除 markRaw 外，都是纯函数

import {
  ref,
  reactive,

  // 响应式处理
  shallowRef,
  shallowReactive,
  readonly,
  shallowReadonly,
  markRaw,
  toRaw,

  // 判断响应式数据
  isRef,
  isReactive,
  isReadonly,
  isProxy,
} from "vue";

/**shallow -----------------------------------------------------------------------------------
 * shallowRef : 若传入引用类型，不在用 reactive 处理
 * shallowReactive : 只处理第一层
 */
// 0 [1, 2]
const sr1 = shallowRef(0);
const sr2 = shallowRef([1, 2]);
console.log(sr1.value, sr2.value);

// ROXY([1, 2, [3]]) [3]
const srt = shallowReactive([1, 2, [3]]);
console.log(srt, srt[2]);

/**readonly 只读 ，常用于 hook 中导出不允许外部修改的响应式数据 -----------------------------------
 * 接收非函数的引用类型原始数据、或任何响应式数据，变成只读的 Proxy
 * 与普通数据的本质区别是，这是 Vue 能够检测到的，只是不允许修改
 * 若修改了原始响应式数据，readonly 也会被修改，因为是浅拷贝
 * shallowReadonly 只处理第一层
 */
const refData = ref(0);
const ro = readonly(refData);

// Proxy({value: 0}) 0
console.log(ro, ro.value);

// err
// ro.value = 1;

// 1 1
refData.value = 1;
const sro = shallowReadonly(refData);
console.log(ro.value, sro.value);

/**markRaw ------------------------------------------------------------------------------------
 * markRaw : 非纯函数，标记一个引用类型，使得无法用他创建响应式数据
   - 原始对象增加一个 "__v_skip": true 属性
   - 常用于响应式对象添加某个成员，而这个成员不需要响应式（如第三方数据），就可以 mark 以下，提高性能
 * toRaw : 还原一个响应式数据，无法还原 markRaw 的原始数据，因为必须传入一个响应式数据
 */
const rawData = { a: 0 };
const rd = markRaw(rawData);

// true
console.log(rd === rawData);

// { a: 0 , __v_skip: true }
const r1 = ref(rawData);
console.log(r1.value);

// Proxy({ a: 1 }) { a: 1 }
const r2 = ref({ a: 1 });
const r3 = toRaw(r2);
console.log(r2.value, r3.value);

/**判断响应式数据 --------------------------------------------------------------
 * 特别的，readoly 的 Proxy 只能用 isProxy 判断，不能用 isReactive
 */

const d1 = ref(0);
const d2 = reactive({ a: 1 });
const d3 = ref({ a: 1 });
const d4 = readonly(d3);

// 都是 "[object Object]" ，没有做处理
console.log(
  Object.prototype.toString.call(d1),
  Object.prototype.toString.call(d2)
);

// true true ture
console.log(isRef(d1), isReactive(d2), isReactive(d3.value));

// true true
console.log(isProxy(d2), isProxy(d3.value));

// true true false
console.log(isReadonly(d4), isProxy(d4), isReactive(d4));
</script>

<template></template>
```

#### 3.2.2 插槽

分为默认插槽、具名插槽、作用域插槽。

Vue2 、Vue3 区别：

* Vue2 父组件中，可以用 slot 属性指定具名插槽；Vue3 已删除

* Vue2 template 用 v\-slot\: 指定具名插槽，且默认插槽可以省略；Vue3 使用 \# 指定，且默认插槽不能省略

Vue2 ：

```
<script>
export default {
  created() {
    console.log(this.$slots);
  },
};
</script>

<template>
  <div>
    <slot></slot>
    <slot name="a"></slot>
    <slot name="b" :msg="'msg'"></slot>
  </div>
</template>
```

```
<script>
import Cpn from "./Cpn.vue";

export default {
  components: { Cpn },

  data() {
    return { slotName: "default" };
  },
};
</script>

<template>
  <div>
    <Cpn>
      <p>默认</p>
      <p slot="a">具名</p>
    </Cpn>

    <Cpn>
      <template v-slot:default>
        <p>默认插槽，被覆盖</p>
      </template>

      <template v-slot:[slotName]>
        <p>默认插槽</p>
      </template>

      <template v-slot:a>
        <p>具名插槽</p>
      </template>

      <template v-slot:b="{ msg }">
        <p>作用域插槽 {{ msg }}</p>
      </template>
    </Cpn>
  </div>
</template>
```

Vue3 ：

```
<script setup lang="ts">
// 子组件

import { useSlots } from "vue";

// 保存了传入的插槽
const slots = useSlots();
console.log(slots);
</script>

<template>
  <!-- 默认插槽，多个插槽都会插入 -->
  <slot></slot>
  <!-- <slot></slot> -->

  <!-- 具名插槽 -->
  <slot name="a"></slot>
  <!-- <slot name="a"></slot> -->

  <!-- 作用于插槽，用于传参，默认插槽也可用 -->
  <slot name="b" :msg="'msg'"></slot>
  <!-- <slot name="b" :msg="'msg'"></slot> -->
</template>

<style scoped lang="less"></style>
```

```
<script setup lang="ts">
// 父组件

import { ref } from "vue";
import Cpn from "./Cpn.vue";

const slotName = ref("default");
</script>

<template>
  <Cpn>
    <p>默认插槽</p>
  </Cpn>

  <Cpn>
    <template #default>
      <p>默认插槽，被覆盖</p>
    </template>

    <!-- 父组件中，只能有一个同名 template 插槽，但若使用响应式数据，同名就会覆盖 -->
    <template #[slotName]>
      <p>默认插槽</p>
    </template>

    <template #a>
      <p>具名插槽</p>
    </template>

    <template #b="{ msg }">
      <p>作用域插槽 {{ msg }}</p>
    </template>
  </Cpn>
</template>
```

### 3.3 特殊组件

（1）transition

过度组件，使用 FLIP 方案实现，可以设置类样式实现结构变化的动画。

Vue2 、Vue3 区别：

* Vue2 的 v\-enter 、v\-leave 在 Vue3 改为 v\-enter\-from 、v\-leave\-from

* Vue3 新增 appear 相关的 4 个生命周期，仅在 appear="true" 时有效，且在 appear 阶段会覆盖 enter 相关的钩子，后续不是 appear 就不会覆盖了

```
<script setup lang="ts">
import { ref } from "vue";
import type { Ref } from "vue";

function useHidden(value: boolean = false): [Ref<boolean>, () => any] {
  const isShow = ref(true);
  const switchShow = () => (isShow.value = !isShow.value);
  return [isShow, switchShow];
}

const [isShow, switchShow] = useHidden(true);
const [isShowItem, switchShowItem] = useHidden(true);
const [isShowText, switchShowText] = useHidden(true);

// transition 生命周期，都有参数 el 为触发动画的元素 -----------------------------------------
const beforeEnter = (el: Element) => console.log("beforeEnter", el);
const enter = (el: Element) => console.log("enter", el);
const afterEnter = (el: Element) => console.log("afterEnter", el);
const enterCancelled = (el: Element) => console.log("enterCancel", el);

const beforeLeave = (el: Element) => console.log("beforeLeave", el);
const leave = (el: Element) => console.log("leave", el);
const afterLeave = (el: Element) => console.log("afterLeave", el);
const leaveCancelled = (el: Element) => console.log("leaveCancel", el);

const beforeAppear = (el: Element) => console.log("beforeAppear", el);
const appear = (el: Element) => console.log("appear", el);
const afterAppear = (el: Element) => console.log("afterAppear", el);
const appearCancel = (el: Element) => console.log("appearCancel", el);
</script>

<template>
  <button @click="switchShow">switch</button>
  <button @click="switchShowItem">switch item</button>
  <button @click="switchShowText">switch text</button>

  <!-- 属性
     * name : 类名，默认为 "v"
     * appear : 初始是否使用动画，默认 false
     * css : 是否使用 css 控制动画，默认值 true ，若为 false 则自己使用 JS 配合 transition 生命周期控制动画
     * type : 不常用，值为 "transition" | "animation" ，Vue 会自动检查 css ，只有极少数情况需要手动指定
     * duration : 不常用，Vue 会自动检查 css ，只有极少数情况需要手动指定，来确定删除 DOM 的时机
  -->

  <!-- 有且只有一个根元素，且只有根元素有动画 -->
  <transition
    appear
    @before-enter="beforeEnter"
    @enter="enter"
    @after-enter="afterEnter"
    @enter-cancelled="enterCancelled"
    @before-leave="beforeLeave"
    @leave="leave"
    @after-leave="afterLeave"
    @leave-cancelled="leaveCancelled"
    @beforeAppear="beforeAppear"
    @appear="appear"
    @after-appear="afterAppear"
    @appear-cancel="appearCancel"
  >
    <div class="box bog" v-show="isShow">
      <div class="box small" v-show="isShowItem"></div>
      <div class="box small" v-show="isShowItem"></div>
    </div>
  </transition>

  <!-- 不需要根元素，通过 tag 指定根元素（默认 "span"），所有次一级 item 都有动画 -->
  <transition-group tag="ul">
    <!-- 需要 key 保证 diff 准确 -->
    <div class="box small" v-show="isShowItem" key="1"></div>
    <div class="box small" v-show="isShowItem" key="2">
      <!-- 再往下级就没有动画 -->
      <span v-show="isShowText">text</span>
    </div>
  </transition-group>
</template>

<style scoped lang="less">
@w: 100px;
@h: 100px;

.box {
  overflow: hidden;
  margin-top: 10px;
  border: 1px solid #000;
}

.bog {
  width: @w;
  height: @h;
  background-color: #000;
}

.small {
  width: calc(@w / 3);
  height: calc(@h / 3);
  background-color: red;
  line-height: calc(@h / 3);
  text-align: center;
}

// transition 类样式 --------------------------------------------------------------------------
.v-enter-from,
.v-leave-to {
  width: 0;
  height: 0;
}

.v-enter-to,
.v-leave-from {
}

.v-enter-active,
.v-leave-active {
  transition: 1s;
}
</style>
```

（2）component

动态组件，可以用变量动态渲染组件。

Vue2 、Vue3 用法一样；

```
<script setup lang="ts">
// 子组件
</script>

<template>
  <div>
    <slot></slot>
  </div>
</template>
```

```
<script setup lang="ts">
// 父组件

import { ref } from "vue";

// 注意子组件 Cpn 除了注册外，Vue2 要放在 data 注入，Vue3 setup\(\) 需要 return 才能在 template 使用.
import Cpn from "./Cpn.vue";

const flag = ref(true);
const changeFlag = () => (flag.value = !flag.value);
</script>

<template>
  <button @click="changeFlag">switch</button>
  <component :is="flag ? Cpn : 'h1'">text</component>
</template>
```

（3）keep\-alive

缓存组件，v\-if 和路由切换不销毁组件，被 keep\-alive 作用的普通组件也可以使用 activated 、deactivated ，但其他路由相关钩子普通组件还是无法使用。

Vue2 、Vue3 用法一样：

```
<script setup lang="ts">
// 子组件

import { onUnmounted, onActivated, onDeactivated } from "vue";

onUnmounted(() => console.log("unmounted"));
onActivated(() => console.log("activated"));
onDeactivated(() => console.log("deactivated"));
</script>

<template>
  <p>Cpn</p>
</template>
```

```
<script setup lang="ts">
// 父组件

import { ref } from "vue";
import Cpn from "./Cpn.vue";

const isShow1 = ref(true);
const isShow2 = ref(true);

const switchShow1 = () => (isShow1.value = !isShow1.value);
const switchShow2 = () => (isShow2.value = !isShow2.value);
</script>

<template>
  <button @click="switchShow1">switch 1</button>
  <button @click="switchShow2">switch 2</button>

  <!-- 无缓存，会执行 unmounted -->
  <Cpn v-if="isShow1" />

  <!-- 缓存，不销毁组件，不执行销毁的钩子 -->
  <keep-alive>
    <Cpn v-if="isShow2" />
  </keep-alive>

  <!-- 结合 transition ，transition 要放在外部 -->
  <transition>
    <keep-alive>
      <Cpn v-if="isShow2" />
    </keep-alive>
  </transition>
</template>

<style scoped lang="less">
.v-enter-from,
.v-leave-to {
  opacity: 0;
}

.v-enter-active,
.v-leave-active {
  transition: opacity 2s;
}
</style>
```

（4）递归组件

组件自己使用自己。

Vue2 、Vue3 用法一样：

```
<script setup lang="ts">
// 子组件

/**方式一
 * 懒加载引入自己并注册，否则会无线递归
 * script setup 可以同步导入是因为会特殊处理，但不是懒加载，也不是设置 name
 */
// import Myself from "./Cpn.vue";

// 方式二，设置·组件 name
defineOptions({
  name: "Myself",
});

interface Data {
  id: string;
  text: string;
  children?: Data[];
}

interface Props {
  data: Data[];
}

defineProps<Props>();
</script>

<template>
  <ul>
    <li v-for="i in data" :key="i.id">
      <span>{{ i.text }}</span>
      <Myself v-if="i.children?.length" :data="i.children" />
    </li>
  </ul>
</template>
```

```
<script setup lang="ts">
// 父组件

import { reactive } from "vue";
import Cpn from "./Cpn.vue";

const data = reactive([
  { id: "0", text: "0", children: [{ id: "0-0", text: "0-0" }] },
  { id: "1", text: "1", children: [{ id: "1-0-0", text: "1-0" }] },
]);
</script>

<template>
  <Cpn :data="data" />
</template>
```

（5）异步组件

懒加载组件：

* 只有用到时才会下载执行分包的 JS，提高初始性能，常用于路由组件。

* 打包后懒加载的组件会分包，生成独立的 JS 文件，而其他正常导入的组件全部打包为一个 JS 文件

* 默认情况下，分包只和是否懒加载有关，和组件结构、嵌套路由等无关，如：
  
  * 懒加载父路由，同步导入子路由，那么这个子路由会打包到主包，而不是父路由组件的分包
  
  * 父路由、子路由都是懒加载，则会打包为两个独立的分包

Vue2 、Vue3 区别：

* Vue2 懒加载的组件可以直接使用；Vue3 懒加载得到一个 Promise ，需要 defineAsyncComponent 才能使用，这是为了支持更丰富的功能和 ts 支持

* 同步加载和懒加载，在子组件没有加载完成时，父组件以及祖先组件都不会渲染，因为子组件 mounted 后父组件才会 mounted；但若是 defineAsyncComponent 的完整写法，会让父组件先 mounted ，就不会停止上级组件的渲染

```
<script>
// Vue2 ，父组件

const Cpn1 = () => import("./Cpn1.vue");

export default {
  components: {
    Cpn1,
    Cpn2: () => import("./Cpn2.vue"),
  },
};
</script>

<template>
  <div>
    <Cpn1 />
    <Cpn2 />
  </div>
</template>
```

```
<script setup lang="ts">
// Vue3 ，父组件

import { defineAsyncComponent } from "vue";
import Loading from "./components/Loading.vue";
import Error from "./components/Error.vue";

// 简写
// const Cpn = defineAsyncComponent(() => import("./Cpn.vue"));

// 完整写法，过度组件、动态组件、缓存组件等对 loading 和 Error 都有小
const Cpn = defineAsyncComponent({
  // 正常使用
  // loader: () => import("./Cpn.vue"),

  // 测试，模拟 3s 后加载完成
  loader: () =>
    new Promise<any>((resolve, reject) => {
      setTimeout(() => {
        resolve(import("./Cpn.vue"));
        // reject("err");
      }, 3000);
    }),

  // 1000ms 后若还未加载完成，就显示 loading 组件
  delay: 1000,
  loadingComponent: Loading,

  // 2000ms 后若还未加载完成，显示 error 组件 ，但不会停止加载
  timeout: 2000,
  errorComponent: Error,

  // 非超时错误触发，如网络断开、reject 等
  onError(error, retry, fail, attempts) {
    // 设置重试次数，retry() 会重新执行 loader 函数
    if (attempts <= 3) retry();
    else fail();
  },

  /**是否结合 Suspense 使用，默认 true
   * true，Suspense 的 loading 插槽覆盖这里的 loading ；false 则使用这里的 loading
   * Suspense 只有 loading 插槽，没有 error 插槽
   * 若不结合 Suspense ，则不管 true 、false 都是使用这里的 loading
   */
  // suspensible: false,
});
</script>

<template>
  <p>Parent</p>
  <Cpn />

  <!-- 
  <Suspense>
    <template #default>
      <Cpn />
    </template>

    <template #fallback>
      <p>Suspense loading ...</p>
    </template>
  </Suspense> 
  -->
</template>
```

Suspense ，Vue3 新特性，用于渲染异步组件：

* 和 defineAsyncComponent 完整写法一样不会停止上级组件的渲染：

* 当子组件为 async setup 时（script setup 顶层使用 await 就会编译为 async setup），或者在非 script setup 顶层使用 await ，都会变为异步组件，父组件就必须使用 Suspense 才能渲染子组件，defineAsyncComponent 完整写法无法渲染

* 由于也是异步加载，所以也会分包

* 只有 loading 插槽，若需要 error ，则需要结合 defineAsyncComponent 完整写法

```
<!-- 
 <script setup lang="ts">
// Vue3 ，子组件
import { ref } from "vue";

const a = ref(0);
const test = new Promise<void>((resolve) => setTimeout(resolve, 3000));

await test;
</script> 
-->

<script lang="ts">
// Vue3 ，子组件

import { ref } from "vue";

const test = new Promise<void>((resolve) => setTimeout(resolve, 3000));

// 也会变为异步组件
// await test;

export default {
  async setup() {
    const a = ref(0);
    await test;

    // 虽然 return 的是 Promise ，但 template 也能正常使用
    return { a };
  },
};
</script>

<template>
  <p>{{ a }}</p>
</template>
```

```
<script setup lang="ts">
// Vue3 ，父组件

import { defineAsyncComponent } from "vue";
const Cpn = defineAsyncComponent(() => import("./Cpn.vue"));
</script>

<template>
  <p>Parent</p>

  <Suspense>
    <template #default>
      <Cpn />
    </template>

    <template #fallback>
      <p>Suspense loading ...</p>
    </template>
  </Suspense>
</template>
```

逐帧渲染，用渲染帧 API 分片渲染，Vue2 、Vue3 用法一样：

（6）Teleport

传颂组件，Vue3 新特性，将插槽内容传颂到 to 指定的选择器的父元素内，是 DOM 结构层面的传颂，父元素会被更换，适合做 loading 、mask 等：

```
<script setup lang="ts">
import { ref } from "vue";
import type { Ref } from "vue";

function useHidden(value: boolean = false): [Ref<boolean>, () => any] {
  const isShow = ref(value);
  const switchShow = () => (isShow.value = !isShow.value);
  return [isShow, switchShow];
}

const [isShowBox1, switchShowBox1] = useHidden(true);
const [isShowBox2, switchShowBox2] = useHidden(true);

const [isShowTP1, switchShowTP1] = useHidden(true);
const [isShowTP2, switchShowTP2] = useHidden(true);

const [isShowSlot1, switchShowSlot1] = useHidden(true);
const [isShowSlot2, switchShowSlot2] = useHidden(true);
</script>

<template>
  <p>
    <button @click="switchShowBox1">v-show box</button>
    <button @click="switchShowBox2">v-if box</button>
  </p>

  <p>
    <button @click="switchShowTP1">v-show TP</button>
    <button @click="switchShowTP2">v-if TP</button>
  </p>

  <p>
    <button @click="switchShowSlot1">v-show Slot</button>
    <button @click="switchShowSlot2">v-if Slot</button>
  </p>

  <!-- 测试父元素
      * 父元素不是 .box 而是 .box 外 body 内的元素，所以 box 的 v-show 对 TP 无效
      * 但 box 的 v-if 对 TP 有效，因为只有创建了 box 才能传颂 TP
      * v-if 对 TP 有效，v-show 无效，因为传颂的是插槽内容，不是 TP 本身
      * v-if 、v-show 对 TP 插槽都有效
   -->
  <div class="box" v-show="isShowBox1" v-if="isShowBox2">
    <Teleport to="body" v-show="isShowTP1" v-if="isShowTP2">
      <div class="loading" v-show="isShowSlot1" v-if="isShowSlot2">loading</div>
    </Teleport>
  </div>
</template>

<style scoped lang="less">
.loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100px;
  height: 50px;
  border: 1px solid #000;
  line-height: 50px;
  text-align: center;
}

// 测试父元素 ---------------------------------------------------------------------
.box {
  width: 100px;
  height: 100px;
  border: 1px solid #000;

  // 无效
  .loading {
    font-size: 100px;
  }
}

body {
  // 有效
  .loading {
    background-color: red;
    color: #fff;
  }

  // 无效，因为不在次一级
  > box {
    font-size: 100px;
  }
}
</style>
```

### 3.4 插件

use 函数极简实现，用于使用插件：

```
const app = {
  use(plugin: { install: Function }) {
    plugin.install(this);
    return this;
  },
};

app.use({
  install(app: any) {
    console.log("hello");
  },
});
```

编写插件时，可能需要再全局注入资源：

```
// Vue2，添加到 Vue 原型上，使用时直接 this 在圆形上找
Vue.prototype.xxx = 123;

// Vue3
app.config.globalProperties.xxx = 123;
```

Vue3 的 setup  this 为 undefined ，使用插件或者获取组件信息需要使用一个 hook ：

```
<script setup lang="ts">
import { getCurrentInstance } from "vue";

// undefined
console.log(this);

const instance = getCurrentInstance();

// 获取全局资源
const global = instance?.appContext.config.globalProperties;
console.log(global);

// 获取组件信息
console.log(instance?.type.name);
</script>

<script lang="ts">
export default {
  name: "Cpn",
};
</script>

<template></template>
```

（1）组件插件

将一个全局组件注册为插件，暴漏一些数据和函数给外部使用，如弹窗插件.，核心：

```
// VUE2
Vue.prototype.cpnName = obj;

// VUE3
app.config.globalProperties["cpnName"] = obj;
```

Vue2 ：

```
// /src/plugins/component/index.js

import Dialog from "./Dialog.vue";

const plugins = [Dialog];

// main.js 中 Vue.use() 即可；使用时 this.$dialog 即可
export default {
  install(Vue) {
    for (const cpn of plugins) {
      if (!cpn.name) continue;

      const cpnConstructor = Vue.extend(cpn);
      const VNode = new cpnConstructor();

      VNode.$mount(document.createElement("div"));
      document.body.appendChild(VNode.$el);

      Vue.prototype[cpn.name] = VNode;
    }
  },
};
```

Vue3 ：

```
<script setup lang="ts">
// /src/plugins/component/Dialog.vue

import { ref } from "vue";

defineOptions({
  name: "$dialog",
});

const isShow = ref(false);
const text = ref("");

const show = (msg: string = "") => {
  text.value = msg;
  isShow.value = true;
};

const hidden = () => {
  text.value = "";
  isShow.value = false;
};

defineExpose({ show, hidden });
</script>

<template>
  <Teleport to="body">
    <div class="my-dialog" v-show="isShow">
      <div class="my-dialog-main">
        <div class="my-dialog-text">{{ text }}</div>
      </div>

      <div class="my-dialog-footer">
        <button @click="hidden">确定</button>
      </div>
    </div>
  </Teleport>
</template>

<style scoped lang="less">
@my-dialog-border: 1px solid #000;

.flex-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.my-dialog {
  display: flex;
  flex-direction: column;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 400px;
  height: 100px;
  border: @my-dialog-border;
  border-radius: 10px;

  > .my-dialog-main {
    .flex-center();
    flex: 1;
    padding: 10px;

    > .my-dialog-text {
      overflow: hidden;
    }
  }

  > .my-dialog-footer {
    .flex-center();
    height: 30px;
    border-top: @my-dialog-border;

    > button {
      border-radius: 5px;
    }
  }
}
</style>
```

```
// /src/plugins/component/index.ts

import { createVNode, isVNode, render } from "vue";
import type { App } from "vue";

import Dialog from "./Dialog.vue";

// 所有插件一起注册
const plugins = [Dialog];

// main.ts 导入，执行 use 即可
export default {
  install: (app: App) => {
    for (const cpn of plugins) {
      if (!cpn.name) continue;

      // 创建虚拟 DOM，render 成真实 DOM
      const VNode = createVNode(cpn);
      render(VNode, document.createElement("div"));

      // render 后才会有 component 属性
      const exposed = VNode.component!.exposed;
      app.config.globalProperties[cpn.name] = exposed;
    }
  },
};
```

```
// /src/main.ts
import component from "./plugins/component";
app.use(component);
```

```
<script setup lang="ts">
import { getCurrentInstance } from "vue";

const instance = getCurrentInstance();
const global = instance?.appContext.config.globalProperties;
const $dialog = global?.$dialog;

$dialog.show();
// $dialog.hidden();
</script>

<template></template>
```

（2）指令插件

用于注册全局指令，核心：

```
// Vue2
Vue.directive("dirName", options);

// Vue3
app.directive("dirName", options);
```

封装：

```
// /src/plugins/directive/index.ts

import type { App, Directive, DirectiveBinding } from "vue";

interface Dir {
  name: string;
  options: Directive;
}

const dirs: Dir[] = [
  {
    name: "auth",
    options: {
      mounted(el: HTMLElement, dir: DirectiveBinding) {
        console.log("v-auth", dir.value);
      },
    },
  },
];

// main.ts 导入，执行 use 即可
export default {
  install(app: App) {
    for (const dir of dirs) app.directive(dir.name, dir.options);
  },
};
```

## 4 生态

### 4.1 Vue Router

（1）基本

传统的多页面应用，有多个 html 文件，浏览器通过对应的 url 访问服务器中各个 html 资源；但 SPA 只有一个页面，就要解决 4 个问题：

- SPA 展示多个页面组件，把 url 变成响应式数据，通过监听 hashchange 事件或 popstate 事件处理 url ，router-view 再通过 url 展示对应的组件

- SPA 在修改 url 时不应该刷新页面，因为都是同一个 html ，同时服务器中对应的 url 也没有对应的资源：
  
  - 可以使用 hash 模式，"#hash" 修改不会刷新页面，url 也不会带上 hash 区访问服务器
  
  - 若不想使用 hash 的 '\#' ，让 url 更美观，可以用 history 模式，但是这样修改 url 就会刷新页面，vue-router 底层已经用 historyAPI 解决；整个 url 区访问服务器，但没有对应的资源，所以服务器也需要处理一下

- SPA 初始化会加载所有要展示的组件，这时候可以用路由懒加载，实现和传统多页面类似的效果，访问对应资源时才加载

- SPA 用 JS 生成内容，不利于 SEO ，可以用 SSR 解决

（2）模式

* hash ：url 带有 "\#" ，后面为哈希值，哈希值变化页面不会刷新，也不会携带给服务器，兼容性最好，因此不需要额外处理

* history ：url 没有 “\#” ，更美观，但也因此 url 变化会刷新页面，Vue Router 底层通过 HTML5 的 history API 解决，实现不刷新，因此兼容性差一些；也因此整个 url 都会携带给服务器，而 SPA 在服务器并没有对应 url 的静态资源，所以服务器也需要处理 url

* abstract ：用于非浏览器环境（没有 BOM），如小程序、app 、桌面应用，这种模式会吧 url 存入到一个不可见对象中，再处理这个对象

（3）使用

Vue2 、Vue3 区别：

* Vue2 使用 VueRouter3 ，Vue3 使用 VueRouter4

* 创建路由的方式不同：Vue2 使用 VueRouter 构造函数，需要 use 且挂载到 Vue 实例，Vue3 使用 createRouter 工厂函数，直接 use 就行

* 模式配置不同：Vue2 用 mode 配置 string 且可以省略，默认为 hash ，Vue3 必须配置 history 选项：
  
  ```
  {
    // Vue2
    mode: "hash",
    // Vue3，需要导入
    history: createWebHashHistory()
  }
  ```

* router\-view 使用 transition 、keep\-alive 时 ，Vue2 和普通组件使用方式一样，Vue3 则需要放在 router\-view 的默认插槽中

* router\-link 删除属性 tag ，完全可以用插槽替代，Vue2 也支持；删除属性 event ，改为 custom ，更好的配合插槽控制跳转行为

* 组件内获取路由实例的方式不同：Vue2 用 this 获取，Vue3 用 hook 获取

* 导航守卫：
  
  * Vue3 守卫都支持 return 代替 next ，此时不允许回调函数传入 next 参数
  
  * Vue3 的组件内守卫只支持 Options API 。但新增 2 个组件内守卫钩子 onBeforeRouteUpdate 、onBeforeRouteLeave

* Vue3 修复了 Vue2 路由跳转的 2 个 bug ：
  
  - 当跳转的路由就是当前路由时，不再有 warn
  
  - next 不再有 warn

Vue2 ：

```
// /src/router/index.js

import VueRouter from "vue-router";

import Home from "../views/Home/index.vue";
const About = () => import("../views/About/index.vue");

const routes = [
  {
    path: "/",
    component: Home,
  },

  {
    path: "/about",
    component: About,
  },
];

const router = new VueRouter({
  routes,
});

export default router;
```

```
// /src/main.js

import Vue from "vue";
import App from "./App.vue";
import VueRouter from "vue-router";
import router from "./router";

Vue.config.productionTip = false;

Vue.use(VueRouter);

new Vue({
  router,
  render: (h) => h(App),
}).$mount("#app");
```

```
<script>
// /src/App.vue
export default {};
</script>

<template>
  <keep-alive>
    <router-view></router-view>
  </keep-alive>
</template>
```

Vue3 ：

```
// /src/router/index.ts

import { createRouter, createWebHistory } from "vue-router";
import type { RouteRecordRaw, RouterScrollBehavior } from "vue-router";

// 同步导入
import Home from "@/views/Home/index.vue";

// 路由懒加载，分包
const About = () => import("@/views/About/index.vue");
const AboutA = () => import("@/views/About/children/AboutA/index.vue");
const AboutB = () => import("@/views/About/children/AboutB/index.vue");
const Profile = () => import("@/views/Profile/index.vue");
const NotFound = () => import("@/views/NotFound/index.vue");

/**路由配置 -------------------------------------------------------------------------------
 * path 、component / components / redirect 是必选参数，其他都是可选参数
 * alias：path 的别名数组，注意不是 name 的别名
 * name：路由 name
 * meta：路由原信息，保存在路由对象中
 */
const routes: RouteRecordRaw[] = [
  {
    // 默认路由，"" 或 "/" ，也可以直接配置一条 { path: "/", component: Home }
    path: "/",
    redirect: "/home",
  },

  {
    path: "/home",
    component: Home,
    meta: { msg: "meta" },

    // 命名试图，<router-view> 默认渲染 default 组件，也可以 <router-view name="xxx"> 渲染对应组件
    // components: {
    //   default: Home,
    //   xxx: Home,
    // },
  },

  {
    path: "/about",
    alias: ["/aboutalias"],
    component: About,
    meta: { msg: "hello" },

    // 若需要用父路由 name 跳转，且显示默认路由，则需要这里也设置 redirect
    // name: "about",
    // redirect: "/about/abouta",

    /**嵌套路由
     * About/index.vue 内也需要使用 <router-view>
     * 配置 path 不需要加 "/" 和父路由前缀
     * 路由跳转的 url 如 "/about/" 、 "/about/aboutb"
     */
    children: [
      { path: "", redirect: "about/abouta" },
      { path: "abouta", name: "abouta", component: AboutA },
      { path: "aboutb", name: "aboutb", component: AboutB },
    ],

    // 独享守卫
    beforeEnter(to, from) {
      return;
    },
  },

  {
    // 动态路由，跳转 url 如 "/profile123"
    path: "/profile:id",
    // 可选参数
    // path: "/profile:id?",

    // 可以用 props 传递参数，组件中用 props 配置项接收
    props: { num: 1 },

    name: "profile",
    component: Profile,
  },

  // 匹配路由
  {
    // 正则匹配，正则不需要加 / /
    // path: "/:pathMatch(正则)",

    // 404 路由
    path: "/:catchAll(.*)",

    component: NotFound,
  },
];

//*自定义滚动行为，即路由跳转后滚动到的位置，默认是顶部
const scrollBehavior: RouterScrollBehavior = (to, from, savedPosition) => {
  if (to.hash) {
    return {
      selector: to.hash,
      behavior: "smooth",
      offset: { x: 0, y: 100 },
    };
  } else return { x: 0, y: 0 };
};

// 创建路由，Vue Router 底层监听 propstate 事件实现路由功能
const router = createRouter({
  routes: routes,
  history: createWebHistory(import.meta.env.BASE_URL),
  scrollBehavior,
});

/**导航守卫、也叫路由守卫，在路由进入之前、之后回调 -----------------------------------------
 * 全局前置守卫，进入路由之前回调，通常用于权限验证
 * 全局后置守卫：进入路由后回调，常用语修改 title ，延迟跳回原页面等
 * 独享守卫：路由中配置，该路由独享，属于前置手误诶
 * 组件内守卫：组件内部配置
 * 前置守卫内部必须使用 next 才能继续跳转（Vue3 还可以用 return）
 * 执行顺序：全局前置 - 独享 - 组件内 - 全局后置
 */
// 全局前置守卫
router.beforeEach((to, from /*next*/) => {
  // to 、from 都是路由对象
  console.log(`即将从当前 ${from.path} 进入 ${to.path}`);

  // 跳转到 to
  // next();
  // return;
  return true;

  // 不跳转到 to ，而是主动指定
  // next('/login')
  // next({ path: "/login", query: {} });
  // return "/login";
  // return { path: "/login", query: {} };

  // 取消导航
  // return false;

  // 取消导航，并回调 router.onError
  // throw new Error("err");
});
router.onError((err) => {
  console.log(err);
});

// 全局后置守卫
router.afterEach((to, from, next) => {
  // 后置守卫不必须要 next ，但也可以用 next 再次跳转路由
  console.log(`进入路由: ${to.path}`);
});

export default router;
```

```
// /src/main.ts ，use 注入一些全局组件和全局资源
import router from "./router";
app.use(router);
```

```
<script setup lang="ts">
// /src/App.vue，泪痣路由后，进入对应的 url 就会执行对应组件的 script ，但模板需要使用 router-view 才会渲染
</script>

<template>
  <!-- 用于展示路由页面，类似 template 只作包裹作用，所以无法使用 v-show -->
  <!-- <router-view></router-view> -->

  <!-- Vue3 的 router-view 使用 keep-alive、transition
     * 必须用默认插槽 
     * route: 当前路由  Component: 当前路由组件
     * 和缓存组件一样，keep-alive 切换路由不会删除路由组件
     * include、exclude 声明缓存起作用的组件 name ，注意不是路由 name ；默认全部路由组件适用
     * 若父路由缓存了，离开父路由不想缓存某个子组件，可以在父组件中，用响应式数据 v-if 子组件，在 actived、deactived 修改这个数据
  -->
  <router-view #default="{ route, Component }">
    <keep-alive>
      <component :is="Component"></component>
    </keep-alive>
  </router-view>
</template>
```

```
<script setup lang="ts">
// /src/views/Home/index.vue ，获取当前路由、路由跳转、组件内守卫

import {
  useRoute,
  useRouter,
  onBeforeRouteUpdate,
  onBeforeRouteLeave,
} from "vue-router";

// route 是当前路由。router 是整个路由实例
const route = useRoute();
const router = useRouter();

// "/home" "/home" "meta" ，route 和 router.currentRoute 不是同一个对象，但信息相同
console.log(route.path, router.currentRoute.value.path, route.meta.msg);

/**编程式导航，路由跳转是异步任务，所以若有多条跳转语句，则只执行最后一个 --------------------------
 * push：跳转后可以返回
 * replace：跳转后不可以返回
 */
const toProfile = () => {
  // 简写，只能用 path
  // router.push("/profile123?a=msg");

  // 完整写法，可以更方便传参；推荐用 name ，后期更好维护，如改动 path 就不需要改其他代码了
  router.push({
    // path: "/profile123",
    // query: { a: "msg" },

    name: "profile",
    params: { id: 123 },
    query: { a: "msg" },
  });
};

// 组件内守卫，都是前置守卫 ----------------------------------------------------------------
defineOptions({
  beforeRouteEnter(to, from) {
    return;
  },
});

/**params 或 query 改变时回调，用于页面自己跳转自己的场景
 * 注意，仅在参数变化时回调，若 path 都改变了就不会回调
 * 若只有 params 、query 的变化：
   - 不会重新渲染组件，也不会触发独享守卫和其他 2 个组件内守卫，但会触发全局前置、全局后置
   - 因此 VueRouter4 就有了这个钩子，在内部自行处理；在以前只能在全局前置守卫处理
 */
onBeforeRouteUpdate((to, from) => {
  // 方式一，推荐，重新获取数据，不重新渲染组件
  // getData();

  // 方式二，router-view 用响应式数据绑定 key ，key 变化就会重新渲染了
  // <router-view :key="xxx"></router-view>

  // 方式三，不推荐，强制刷新或先跳转中间页面再跳转回来，不符合 SP 不刷新页面的设计

  return;
});

// 离开当前路由之前回调
onBeforeRouteLeave((to, from) => {
  console.log("leave");
  return;
});
</script>

<template>
  <p>home</p>
  <p>{{ typeof $route }}</p>
  <p>{{ typeof $router }}</p>

  <!-- 声明式导航 
     * to ：跳转目标
     * replace ：boolean ，默认为 push 跳转
     * append ：boolean ，若为 true ，则 to 变为在当前 path 后追加，常用语简化跳转嵌套路由
     * active-class 、exact-active-class ：样式 class
     * tag 、event：VueRouter4 已删除，设置渲染的标签和行为，默认为 a 和默认跳转
     * custom ：VueRouter4 新增，boolean ，若为 true ，则自行控制跳转行为
  -->
  <p>
    <router-link to="/about">
      <button>to AboutA</button>
    </router-link>
  </p>
  <p>
    <router-link :to="{ name: 'aboutb' }"> to AboutB </router-link>
  </p>

  <!-- 编程式导航 -->
  <p>
    <button @click="toProfile">to Profile</button>
  </p>

  <!-- 测试 onBeforeRouteUpdate -->
  <p>
    <router-link to="/home?a=1">test</router-link>
  </p>
</template>
```

```
<script setup lang="ts">
// /src/views/About/index.vue
</script>

<template>
  <p>about</p>
  <router-view></router-view>
</template>
```

```
<script setup lang="ts">
// /src/views/Profile/index.vue ，获取路由参数、路由钩子

import { onActivated, onDeactivated } from "vue";
import { useRoute } from "vue-router";

const route = useRoute();

// path + param ，path + param + query
console.log(route.path, route.fullPath);

// 获取参数
console.log(route.params.id, route.query);

// 获取路由配置的 props ，实际上就是组件通信
const props = defineProps<{ num: number }>();
console.log(props.num);

// 路由钩子，仅在 keep-alive 内有效
onActivated(() => {});
onDeactivated(() => {});
</script>

<template>
  <p>profile</p>
</template>
```

（4）动态 CURD 路由

如权限系统中动态添加、删除路由配置，Vue2 、Vue3 用法一样，区别：

* VueRouter4 删除了 addRoutes ，批量 add 需要自己遍历

* VueRouter4 新增 removeRoute ，hasRoute ，在以前，删除或修改路由只能重新 new 一个路由实例，再吧新路由实例的 mather 赋值给正在使用的路由实例：
  
  ```
  export function resetRouter(newRoutes = []) {
    const newRouter = new VueRouter({ mode: "history", routes: newRoutes });
    router.matcher = newRouter.matcher;
  }
  ```

VUE3 :

```
// /src/test/ts

import router from "@/router";

const Manager = () => import("@/views/Manager/index.vue");
const ManagerA = () => import("@/views/Manager/children/ManagerA/index.vue");
const Goods = () => import("@/views/Goods/index.vue");

// add
router.addRoute({
  path: "/manager",
  name: "manager",
  component: Manager,
});

// add 嵌套路由
router.addRoute("manager", {
  path: "managera",
  name: "managera",
  component: ManagerA,
});

// 批量 add
const extraRoutes = [
  {
    path: "/goods",
    name: "goods",
    component: Goods,
  },
];
extraRoutes.forEach((route) => router.addRoute(route));

// remove ，嵌套路由会一并删除
// router.removeRoute("manager");

// update ，路由信息是 readonly 的，只能先 remove 再 add
const routeToUpdate = router.getRoutes().find((r) => r.name === "goods");
if (routeToUpdate) {
  router.removeRoute("profile");
  router.addRoute({
    ...routeToUpdate,
    path: "/goods",
  });
}

// 判断路由是否存在
console.log(router.hasRoute("manager"));

// 获取所有路由
console.log(router.getRoutes());
```

### 4.2 Vuex/Pinia

基本；

* 都是响应式的全局状态管理工具，状态即响应式数据，状态挂载到全局，可实现任意组件通信。

* 单一状态树：只允许有一个 store 对象，方便维护。

Vuex 、Pinia 曲边：

* Vue2 、Vue3 都可以使用（Vue3 需要 Vuex4 版本），Vue3 推荐使用 Pinia ，ts 支持更好

* Vuex 需要通过 mutations 修改状态 ，这样 VueDevTool 才能监测到；Pinia 可以直接修改状态，VueDevTool 也能监测到，因此没有 mutations 配置

* Vuex 的模块需要配置 modules ，较复杂；Pinia 直接通过函数创建模块，更清晰，因此没有 modules 配置

* 在组件使用时，Pinia 比 Vuex 更简便，也不需要 map 语法

（1）Vuex

使用：

```
// /src/store/index.js

import Vue from "vue";
import Vuex from "vuex";

// 必须在 new Vuex.Store 之前 use ，使得 vue 可以使用 $store
Vue.use(Vuex);

// 为了方便维护，也会把 state 等抽离成 js 文件，modules 抽离成文件夹
const store = new Vuex.Store({
  state: {
    count: 0,
  },

  getters: {
    doubleCount(state, getters, rootState, rootGetters) {
      return state.count * 2;
    },
  },

  /**mutations
   * 为了让 VueDevTools 能够监控到修改，任何地方对 state 的修改都必须使用 mutations
   * mutations 只能处理同步任务，异步监听不到；且逻辑应该尽量简单
   * 通过数组下标修改、对象增加、删除属性，也需要使用 Vue.$set() Vue.$delete
   * mutations 中使用别的 js 文件 export const xxx 的类型常量，需要如此使用 [xxx]
   */
  mutations: {
    setCount(state, payload = { value: 0 }) {
      console.log(payload.type);
      state.count = payload.value;
    },
  },

  /**actions
   * 同步、异步任务均可，适合对 state 做较为复杂修改
   * 内部也需要通过 mutations 修改 state
   */
  actions: {
    asyncSetCount(context, payload) {
      console.log(payload.type);

      return new Promise((resolve) => {
        // mutations 修改
        setTimeout(() => {
          context.commit({
            type: "setCount",
            value: payload.value,
          });

          resolve();
        }, 1000);
      });
    },
  },

  /**子modules
   * state 可以和 root 重复，会独立保存到 roor.moduleA 中；getters 不行，因为会挂到 root 中
   * mutations 、actions 可以重复，也会挂到 root ，这种情况会全部执行，所以最好避免重名
   * 形参中的state 、context、getters 都是本模块的
   */
  modules: {
    moduleA: {
      /**命名空间，默认 false
       * true 后子模块的getters 、mmutations 、actions 都加上了 "moduleA/" 前缀
       * true 后才能正常使用 map 语法
       */
      // namespaced: true,

      // 子模块需要函数返回独立的 state ，防止冲突；root 的 state 不用
      state() {
        return { count: 10 };
      },

      getters: {
        moduleADoubleCount: (state) => state.count * 2,
      },

      mutations: {
        moduleASetCount: (state) => (state.count = Math.random() * 100),
      },

      actions: {
        moduleAAsyncSetCount(context) {
          return new Promise((resolve) => {
            context.commit("moduleASetCount");
            setTimeout(() => {
              resolve();
            }, 100);
          });
        },
      },
    },
  },
});

// mutations 执行完后回调
store.subscribe((mutation, state) => {
  console.log(`emit ${mutation.type}`);
});

export default store;
```

```
// /src/main.js

import store from "./store";

new Vue({
  store,
})
```

```
<script>
// mapXxx 返回一个队 store 的映射对象，使用更方便
import { mapState, mapGetters, mapMutations, mapActions } from "vuex";

export default {
  computed: {
    // 起别名
    ...mapState({
      cnt: "count",
    }),

    // 不起别名
    ...mapGetters(["doubleCount"]),
    ...mapState("moduleA", ["count"]),
    ...mapGetters("moduleA", ["moduleADoubleCount"]),
  },

  methods: {
    ...mapMutations("moduleA", ["moduleASetCount"]),
    ...mapActions("moduleA", ["moduleAAsyncSetCount"]),

    // 测试未设置 namespaced
    testNoNamespaced() {
      // state
      console.log(
        this.$store.state.count,
        this.$store.state.moduleA.count,
        this.$store.getters.doubleCount,
        this.$store.getters.moduleADoubleCount
      );

      // mutations 修改状态
      this.$store.commit({
        type: "setCount",
        value: this.$store.state.count + 1,
      });

      this.$store.commit("moduleASetCount");
      console.log(this.$store.state.moduleA.count);

      // 异步修改状态
      this.$store
        .dispatch({
          type: "asyncSetCount",
          value: this.$store.state.count + 1,
        })
        .then(() => {});

      this.$store.dispatch("moduleAAsyncSetCount").then(() => {
        console.log(this.$store.state.moduleA.count);
      });
    },

    // 测试命名空间，子模块的getters 、mmutations 、actions 都加上了 "moduleA/" 前缀
    testNamaspaced() {
      console.log(
        this.cnt,
        this.count,
        this.doubleCount,
        this.moduleADoubleCount,
        this.$store.getters["moduleA/moduleADoubleCount"]
      );

      this.$store.commit("moduleA/moduleASetCount");
      this.$store.dispatch("moduleA/moduleAAsyncSetCount");
    },
  },

  created() {
    this.testNoNamespaced();
    // this.testNamaspaced();
  },
};
</script>

<template>
  <div>
    <p>{{ $store.state.count }}</p>
    <p>{{ $store.state.moduleA.count }}</p>
  </div>
</template>
```

持久化存储：

```
pnpm add vuex-persistedstate
```

```
// /src/store/index.js

import Vue from "vue";
import Vuex from "vuex";
import createPersistedstate from "vuex-persistedstate";

Vue.use(Vuex);

const store = new Vuex.Store({
  // state: { count: 0 },
  state() {
    return { count: 0 };
  },
  mutations: {
    add: (state) => (state.count = state.count + 1),
  },

  plugins: [
    // 默认 key 为 "vuex",使用 localStorage ，持久化所有 state 的状态
    // createPersistedstate(),

    // 自定义
    createPersistedstate({
      key: "vuexx",
      storage: window.localStorage,
    }),
  ],
});

export default store;
```

（2）Pinia

使用：

```
// /src/stores/counter.ts

import { ref, computed } from "vue";
import { defineStore } from "pinia";

// Composition API
export const useCounterStoreA = defineStore("counterA", () => {
  const count = ref(0);
  const doubleCount = computed(() => count.value * 2);
  const add = () => ++count.value;

  return { count, doubleCount, add };
});

// Options API
export const useCounterStoreB = defineStore("counterB", {
  // 为了防止冲突，每次都用函数返回一个独立的 state
  state() {
    return { count: 0 };
  },

  getters: {
    // store 为当前仓库
    doubleCount(store): number {
      // 无法从 this 中类型推断 count ，所以需要手动标注返回类型
      return this.count * 2;
    },
  },

  actions: {
    add() {
      ++this.count;
    },
  },
});
```



```
// /src/main.ts
import { createPinia } from "pinia";
app.use(createPinia());
```

```
<script setup lang="ts">
import { storeToRefs } from "pinia";
import { useCounterStoreA, useCounterStoreB } from "@/stores/counter";

const s1 = useCounterStoreA();
const s2 = useCounterStoreB();

// 修改 state 回调
s1.$subscribe((arg, state) => {});

// 每次触发 actions 回调
s1.$onAction((arg) => {});

//

// 使用，已经和 store 的数据关联起来了，所以 ref 、computed 才不需要 .value -----------------------
// 0 0 ，
console.log(s1.count, s2.count);

// 修改状态
++s1.count;
s1.add();

// 多状态的修改推荐使用 patch ，性能高一点
s1.$patch({ count: s1.count + 1 });

// 多数据的复杂修改
s1.$patch((state) => {
  ++state.count;
});

// 解决解构丢失响应式问题，类似 toRefs ，所以使用需要 .value
const { count } = storeToRefs(s1);
++count.value;

// 10
console.log(s1.doubleCount);
</script>

<template>
  <p>{{ s1.count }}</p>
</template>
```

持久化存储，将 state 保存到 Web Storage 中，自己操作比较繁琐，可以使用 Pinia 插件：

```
pnpm add pinia-plugin-persistedstate
```

```
// /src/main.ts
import piniaPluginPersistedstate from "pinia-plugin-persistedstate";
app.use(createPinia().use(piniaPluginPersistedstate));
```

```
// /src/stores/counter.ts

import { defineStore } from "pinia";

// Composition API
export const useCounterStoreA = defineStore(
  "counterA",
  () => {},

  {
    // 默认 key 为 storeName 即 counterA ，使用 localStorage ，持久化所有 state
    // persist: true,

    // 自定义
    persist: {
      key: "counterAA",
      storage: window.localStorage,
    },
  }
);

// Options API
export const useCounterStoreB = defineStore("counterB", {
  // persist: true,

  persist: {
    key: "counterBB",
    storage: window.localStorage,
  },
});
```

自定义 Pinia 插件：

```
import { toRaw } from "vue";
import type { PiniaPluginContext } from "pinia";

interface MyPluginOptions {
  key?: string;
}

// 不需要参数的写法
// const myPluginTest = (context: PiniaPluginContext) => {};

// 需要参数
export const myPlugin = (options: MyPluginOptions) => {
  return (context: PiniaPluginContext) => {
    const { store } = context;

    // 每次 state 修改都会回调
    store.$subscribe(() => {
      localStorage.setItem(
        options?.key ?? store.$id,
        JSON.stringify(toRaw(store.$state)),
      );
    });

    const data = JSON.parse(
      localStorage.getItem(options?.key ?? store.$id) ?? "{}",
    );

    return { ...data };
  };
};

// pinia.use(myPlugin);

// pinia.use(
//   myPlugin({
//     key: "xxx",
//   }),
// );
```

## 5 Vue 原理

Angular 使用 MVC 模式，而 Vue、React 使用 MVVM 模式：

- Model：模型、即 data、methods、生命周期等

- View：视图，即 render 出的页面

- View Model：视图模型，即 Vue 实例，包含 data binding 和 DOM listeners ，通过 Model 数据驱动 View 的显示和更新

123

### 5.1 响应式

响应式，即数据修改，依赖该数据的函数重新执行，这些函数包括 render、computed、watch、watchEffect 。

核心是建立数据和函数之间的联系，JS 中只有 Object\.defineProperty 和 Proxy 可以实现，且都只能用于对象。

#### 5.1.1 Vue2 响应式

Vue2，使用 Object\.defineProperty监听 data 对象实现：

* 先用 Object\.defineProperty 把 data 第一层代理到 this ，方便以后直接用 this 访问数据，不需要递归

* 再用 Object\.defineProperty 递归对每一个属性设置 get、set ，每个属性维护一个 Dep 对象、Dep 对象用发布\-订阅模式进行依赖收集、派发更新，每隔一依赖是一个 Watcher 对象，每一个 Watcher 对象封装有响应式的函数
  
  * 依赖收集：响应式的函数不直接执行，而是交给 Watcher 处理，Watcher 先把函数挂到全局可获取的位置（如 Dep 静态属性），再执行函数，执行函数触发函数内响应式数据的 get ，get 中即可获取挂到全局位置中的依赖
  
  * 派发更新时，会用调度器处理，调度器会把多次重复的更新过滤掉，只保留一个更新，同时会把更新放到异步队列中，所以在 Vue 开发中才需要 nextTick 、updated 拿到最新 DOM

* Object\.defineProperty 只能拦截 value 的访问和修改，无法拦截属性的增加、删除；Set、Map 等操作也无法拦截；数组下标虽然也可以拦截，但是一旦数组长度发生变化，下标和响应式的对应关系就会d打乱，push 等方法也无法拦截。
  
  * 每个引用类型的 value 增加一个 "\_\_ob\_\_" 的 key ，value 为 Observer 对象，里面维护一个 Dep 对象，这样只需要自己实现 \$set、\$delete 函数派发更新即可
  
  * 数组的 push 等函数，在 Array 原型链中插入一个自定义原型，里面重写这些函数，并派发更新

* 不同 watcher 的处理
  
  * watch 只需要 get 以下 watch 的数据即可，所以默认 watch 第一次不会执行；而 render、computed、watchEffect 里有多个响应式数据，所以必须在第一次执行一次才能收集到依赖
  
  * computed 是惰性（lazy）的，只有在用到时才进行依赖收集；只有 computed 依赖的数据修改了，computed 变为脏数据（dirty），computed 才会重新执行，数据没修改则使用缓存 value

实现：

```
// type ------------------------------------------------------------------------------------
interface Options {
  [key: string]: any;
}

interface VueOptions {
  el: string;
  data?: Options;
  watch?: { [key: string]: Function };
  computed?: { [key: string]: Function };
  render?: Function;
}

interface WatcherOptions {
  lazy?: boolean;
}
// --------------------------------------------------------------------------------------------

// tool ----------------------------------------------------------------------------------------
// 判断是否为引用类型，为了简单目前只处理 Object 和 Array
const isPointer = (data: any): boolean => {
  return ["[object Object]", "[object Array]"].includes(
    Object.prototype.toString.call(data)
  );
};

// 响应式处理
const defineReactive = (target: Options, key: string) => {
  // 闭包数据
  let value = target[key];
  const dep = new Dep();

  // 递归
  let childOb = observe(value);

  Object.defineProperty(target, key, {
    get: () => {
      dep.depend();
      (childOb as Observer)?.dep?.depend();
      return value;
    },

    set: (newValue) => {
      value = newValue;
      // 如果 newValue 时引用类型，则需要 observe
      childOb = observe(value);

      // 派发更新
      dep.noticy();
      (childOb as Observer)?.dep?.noticy();
    },
  });
};

// Vue 源码会根据环境是否支持，选择使用微任务、宏任务，这里为了方便直接用微任务
const nextTick = (callback: Function): void => {
  Promise.resolve().then(() => callback());
};

// 响应式处理的入口
const observe = (data: unknown): Observer | void => {
  if (!isPointer(data)) return;
  return data!["__ob__"] ?? new Observer(data as Options);
};

/*数组响应式*
 * Object.defineProperty 可以定义数组下标的 get、set ，但是一旦数组长度改变，下标和响应式的关系就会改变
 * 所以数组下标响应式用 Vue.$set() 实现，同 "__ob__" 的 dep 派发更新
 * push 等方法用自定义原型实现，在里面重写方法，同 "__ob__" 的 dep 派发更新
 */
const observeArray = (arr: Array<any>): void => {
  for (const value of arr) observe(value);
};

// 自定义要插入 Array 原型链中间的原型
const ArrayMethods = (() => {
  const result = Object.create(Array.prototype);

  const methods = [
    "push",
    "pop",
    "shift",
    "unshift",
    "splice",
    "sort",
    "reverse",
  ];

  for (const methodName of methods) {
    result[methodName] = function () {
      console.log(methodName);

      let inserted = Array.from(arguments);
      switch (methodName) {
        case "push":
        case "unshift":
          observeArray(inserted);
          break;
        case "splice":
          for (let i = 2; i < inserted.length; i++) observe(inserted[i]);
          break;
        default:
          break;
      }

      const arrRes = Array.prototype[methodName].apply(this, inserted);
      this["__ob__"].dep.noticy();

      return arrRes;
    };
  }

  return result;
})();
// --------------------------------------------------------------------------------------------

// class -----------------------------------------------------------------------------------------
/**
 * 每一个 watcher 就是一个依赖，有 watch、computed、render、watchEffect
 * computed 是惰性的，只有调用时才会计算；computed 会缓存
 * computed 会用在其他 computed、或 render、watch、watchEffect，所以需要创建 Dep、Watcher 多对多
   的关系，Dep 收集到 computed 的各个 Watcher 后，这些 Watcher 再让这些 Dep 区收集其他 Watcher
 */
let watcherId = 0;
class Watcher {
  public static asyncWatcherIds = new Set();

  // 有这个 watcher 的 Dep
  public deps: Set<Dep> | null = null;

  public value: any;
  public lazy: boolean;
  public dirty: boolean;

  private id: number;
  private vm: Vue;
  private exp: string | Function;
  private callback: Function;
  private getter: Function;

  constructor(
    vm: Vue,
    exp: string | Function,
    callback?: Function,
    options: WatcherOptions = {}
  ) {
    this.deps = new Set();

    this.id = watcherId++;
    this.vm = vm;
    this.exp = exp;

    this.getter = typeof exp === "string" ? this.parseExp(vm, exp) : exp;
    this.callback = typeof exp === "string" ? callback : exp;

    this.dirty = this.lazy = !!options.lazy;

    // computed 是 lazy 的
    if (!this.lazy) this.get();
  }

  // 收集 Dep，在 Dep 类中调用
  public addDep(dep: Dep) {
    this.deps.add(dep);
    dep.addSub(this);
  }

  // 如 watch "person.name"
  private parseExp(obj: Vue, exp: string) {
    const childs = exp.split(".");

    return () => {
      let value: any = obj;

      for (const key of childs) {
        try {
          value = value[key];
        } catch {
          throw new Error(`不能从 undefined 访问 ${key}`);
        }
      }
      return value;
    };
  }

  public get() {
    Dep.target = this;
    Dep.targetStack.push(this);

    this.value = this.getter.call(this.vm);

    Dep.targetStack.pop();
    Dep.target =
      Dep.targetStack.length > 0
        ? Dep.targetStack[Dep.targetStack.length - 1]
        : null;
  }

  /**异步更新
   * 用 nextTick 变成异步任务
   * 若有多次更新，则只执行一次即可
   */
  private run() {
    if (!Watcher.asyncWatcherIds.has(this.id)) {
      Watcher.asyncWatcherIds.add(this.id);
      nextTick(() => {
        this.get();
        this.callback.call(this.vm);
        Watcher.asyncWatcherIds.delete(this.id);
      });
    }
  }

  public update() {
    // computed 在 update 时只设置 dirty 为 true ，computed 的 update 由代理实现
    if (this.lazy) this.dirty = true;
    else this.run();
  }
}

// 发布-订阅模式，用于依赖收集、派发更新
class Dep {
  // 当前触发的依赖，全局可用
  public static target: Watcher | null = null;
  // 处理同时收集多个 watcher 的场景
  public static targetStack: Array<Watcher> = [];

  // 依赖
  private subs: Set<Watcher> | null = null;

  constructor() {
    this.subs = new Set<Watcher>();
  }

  // 在 Watcher 类中调用
  public addSub(watcher: Watcher) {
    this.subs?.add(watcher);
  }

  // 依赖收集
  public depend() {
    if (Dep.target) Dep.target.addDep(this);
  }

  // 派发更新
  public noticy() {
    if (!this.subs) return;

    for (const watcher of this.subs) watcher.update();
  }
}

// 响应式
class Observer {
  public dep: Dep | null = null;

  constructor(data: Options) {
    // "__ob__" 不可枚举
    Object.defineProperty(data, "__ob__", {
      value: this,
      enumerable: false,
    });

    // 给 "__ob__" 添加 dep ，处理增加、删除属性的响应式
    this.dep = new Dep();

    if (Array.isArray(data)) {
      Object.setPrototypeOf(data, ArrayMethods);
      observeArray(data);
    } else this.walk(data);
  }

  private walk(data: Options) {
    const keys = Object.keys(data);
    for (const key of keys) defineReactive(data, key);
  }
}

class Vue {
  private _data: Options | null = null;
  [key: string]: any;

  constructor(options: VueOptions) {
    this.initData(options.data);
    this.initComputed(options.computed);
    this.initWatch(options.watch);

    if (options.render) new Watcher(this, options.render);
  }

  private initData(data?: Options) {
    if (!data) return;

    // 数据代理，使得可以直接用 this 调用数据
    this._data = data;
    const keys = Object.keys(this._data);
    for (const key of keys) {
      Object.defineProperty(this, key, {
        get: () => this._data![key],
        set: (newValue) => (this._data![key] = newValue),
      });
    }

    // 开始响应式处理
    observe(this._data);
  }

  private initComputed(computed: { [key: string]: Function }) {
    if (!computed) return;

    const keys = Object.keys(computed);
    for (const key of keys) {
      const watcher = new Watcher(this, computed[key], undefined, {
        lazy: true,
      });

      // computed 也做数据代理，方便 this 调用，也不用加括号了
      Object.defineProperty(this, key, {
        get: () => {
          // 只有 computed 依赖的数据修改了，才更新 computed，否则使用缓存
          if (watcher.dirty) {
            watcher.get();
            watcher.dirty = false;
          }

          if (Dep.target) {
            for (const dep of watcher.deps) dep.depend();
          }

          return watcher.value;
        },

        // computed 的 set 不允许修改自己，只能做其他事
        set: () => {},
      });
    }
  }

  private initWatch(watch: { [key: string]: Function }) {
    if (!watch) return;

    const keys = Object.keys(watch);
    for (const key of keys) new Watcher(this, key, watch[key]);
  }

  public static $set(target: Observer, key: string, value: any) {
    if (!target["__ob__"]) return;

    target[key] = value;
    defineReactive(target, key);
    target["__ob__"].dep.noticy();
  }

  public static $delete(target: Observer, key: string) {
    if (!target["__ob__"]) return;

    delete target[key];
    target["__ob__"].dep.noticy();
  }
}
// --------------------------------------------------------------------------------------------

const vm = new Vue({
  el: "#app",
  data: {
    a: 123,
    person: { name: "asdf" },
    item: [
      { id: 0, name: "a" },
      { id: 0, name: "b" },
    ],
  },

  computed: {
    xxx() {
      console.log("computed 1");
      return `${this.a} ${this.person.name}`;
    },
  },

  watch: {
    xxx() {
      console.log("watch");
    },
  },

  render() {
    // this.a = 1;
  },
});
```

#### 5.1.2 Vue3 响应式

使用 Proxy 实现；

* Proxy 可以拦截对象基本操作，如 obj\.key ，arr\.push\(\) 最终都会转换成基本操作 get\(\) 、set\(\)

* Proxy 的性能更高：
  
  * Vue2 在初始化就递归便利每一个 key 并使用  Object\.defineProperty ；Vue3 的 Proxy 只需要处理引用类型，且响应式是 lazy 的，只有 get 到 key 才会做响应式
  
  * Vue2 所有数据都在 datat 中，都做响应式，不过可以用冻结解决；而 Vue3 可以根据需要定义响应式数据

实现：

Vue3 的响应式模块是一个单独的包。

```
// utils.js

export function isObject(value) {
  return typeof value === "object" && value !== null;
}

export function isProxy(value) {
  return Object.prototype.toString.call(value) === "[object Proxy]";
}

// 判断两个 value 是否相
// 等，is() 相等时为 true 可以得到更具有实际意义的结果
// true false false true
// console.log(+0 === -0, Object.is(+0, -0), NaN === NaN, Object.is(NaN, NaN));
export function isChange(oldValue, newValue) {
  return !Object.is(oldValue, newValue);
}
```

```
// operate.js

export const TrackOpType = {
  GET: "get",
  HAS: "has",
  ITERATE: "iterate",
};

export const TriggerOpType = {
  SET: "set",
  ADD: "add",
  DELETE: "delete",
};
```

```
// effect.js

import { TrackOpType, TriggerOpType } from "./operate.js";

// effect 执行 fn ，fn 执行触发数据的 get ，get 中 track 收集 activeEffect
/**之所以不直接吧 fn 作为依赖而是加一层，是因为在 trigger 时，可能会改变依赖关系
 * const obj = { a: 1, b: 2, c: 3 };
   const p1 = reactive(obj);
   function run() {
     if (p1.a === 1) console.log(p1.b);
     else console.log(p1.c);
   }
   effect(run);
   p1.a = 123;
 */
let activeEffect = null;
const activeEffectStack = [];

// 默认的调度器，实现异步更新和防止多次 trigger 相同的 fn
const defaultScheduler = function () {
  Promise.resolve().then(() => {
    this();
  });
};

export function effect(fn, options = {}) {
  options.lazy = options.lazy || false;
  options.scheduler = options.scheduler || defaultScheduler;

  const effectFn = function () {
    try {
      activeEffect = effectFn;
      activeEffectStack.push(effectFn);

      activeEffect.options = options;

      // 多对多关系，deps -> fn ,fn -> deps
      activeEffect.deps = [];

      return fn();
    } finally {
      activeEffectStack.pop();
      const len = activeEffectStack.length;
      activeEffect = len ? activeEffectStack[len - 1] : null;
    }
  };

  if (!options.lazy) effectFn();
  else return effectFn;
}

function cleanFnDeps(effectFn) {
  if (!effectFn || !effectFn.deps) return;

  for (const dep of effectFn.deps) dep.delete(effectFn);
  effectFn.deps.length = 0;
}

// track --------------------------------------------------------------------
// 数据结构，Vue 中没有 TypeMap ，多了这一层在 trigger 时会比 Vue 更精确，避免不必要的 trigger ，但会多一些内存消耗
// type Deps = Set(Function);
// type TypeMap = Map<Operater, Deps>;
// type PrpsMap = Map<string | Symbol, TypeMap>;
// type TargetMap = WeakMap<Object, PropsMap>;
const targetMap = new WeakMap();

let shouldTrack = true;

export function pauseTrack() {
  shouldTrack = false;
}

export function resumeTrack() {
  shouldTrack = true;
}

const INTERATE_KEY = Symbol('iterate_key"');
export function track(target, type, key) {
  if (!shouldTrack || !activeEffect) return;

  // console.log("track " + type, key);

  let propsMap = targetMap.get(target);
  if (!propsMap) {
    propsMap = new Map();
    targetMap.set(target, propsMap);
  }

  if (!key) key = INTERATE_KEY;
  let typeMap = propsMap.get(key);
  if (!typeMap) {
    typeMap = new Map();
    propsMap.set(key, typeMap);
  }

  let deps = typeMap.get(type);
  if (!deps) {
    deps = new Set();
    typeMap.set(type, deps);
  }

  deps.add(activeEffect);
  activeEffect.deps.push(deps);
}

// trigger -------------------------------------------------------------------------
// trigger 类型对应需要的 track 类型
const triggerTypeMap = {
  [TriggerOpType.SET]: [TrackOpType.GET],
  [TriggerOpType.ADD]: [TrackOpType.GET, TrackOpType.HAS, TrackOpType.ITERATE],
  [TriggerOpType.DELETE]: [
    TrackOpType.GET,
    TrackOpType.HAS,
    TrackOpType.ITERATE,
  ],
};

function getEffectFns(target, type, key) {
  const result = new Set();
  if (!target || !type || !key) return result;

  const propsMap = targetMap.get(target);
  if (!propsMap) return result;

  /**add、delete 会影响长度，所以 iterate 也需要 trigger
   * const p1 = reactive({ a: 1 });
     function run() {
       for (const i in p1) console.log("for");
     }
     effect(run);
     console.log("\n");
     p1.newProps = 123;
   */
  const keys = [key];
  if ([TriggerOpType.ADD, TrackOpType.DELETE].includes(type))
    keys.push(INTERATE_KEY);

  for (const k of keys) {
    const typeMap = propsMap.get(k);
    if (!typeMap) continue;

    const trackTypes = triggerTypeMap[type];
    for (const t of trackTypes) {
      const deps = typeMap.get(t);
      if (!deps) continue;

      for (const dep of deps) result.add(dep);
    }
  }

  return result;
}

export function trigger(target, type, key) {
  // console.log("trigget " + type, key);

  const effectFns = getEffectFns(target, type, key);
  for (const fn of effectFns) {
    // 防止在 trigger 时 track 相同的依赖，导致栈溢出，如 state.a = state.a + 1
    if (fn === activeEffect) continue;

    // 先在所有 deps 中 clean 这个依赖，避免多余的依赖关系，执行 fn 后会再次建立依赖关系
    // cleanFnDeps 配合 defaultScheduler 异步更新，能实现多个数据同时 trigger 同一个依赖时，只执行最后一次
    cleanFnDeps(fn);

    // 使用调度器执行 fn
    fn.options.scheduler.call(fn);
  }
}
```

```
// handlers.js

import { track, pauseTrack, resumeTrack, trigger } from "./effect.js";
import { reactive } from "./reactive.js";
import { isObject, isChange } from "./utils.js";
import { TrackOpType, TriggerOpType } from "./operate.js";

const RAW = Symbol('raw"');
const arrayInstcumentation = {};

/**数组使用查找方法时若查找的是引用，如：
 * const obj = { a: 1 };
   const arr = reactive([ 1, 2, obj] );
   console.log(arr.includes(obj));
 * 输出 false ，正确应该输出 true
 * 原因是 obj 是原始对象，而 arr 中的 obj 变成了 Proxy 对象，引用不同
 */
["includes", "其他查找方法"].forEach((method) => {
  arrayInstcumentation[method] = function (...args) {
    // 方法一：查找时吧原始对象转化成 Proxy
    // ...

    // 方法二：Vue 采用的方式，先再代理中找一遍，找不到再去原始对象找，优点是适用性强=，缺点是需要多余的便利
    const result = Array.prototype[method].apply(this, args);
    if (result < 0 || result === false) {
      // this[RAW] 得到原始对象
      return Array.prototype[method].apply(this[RAW], args);
    }
    return result;
  };
});

// 数组使用这些方法时，会 get length 并 track，但框架应该避免这种意外的 track
["push", "pop", "unshfit", "shift", "split"].forEach((method) => {
  arrayInstcumentation[method] = function (...args) {
    pauseTrack();
    Array.prototype[method].apply(this, args);
    resumeTrack();
  };
});

// 拦截基本操作 .get
function get(target, key, receiver) {
  if (key === Symbol.toStringTag) return "Proxy";
  if (key === RAW) return target;

  track(target, TrackOpType.GET, key);

  // 数组方法处理
  if (Array.isArray(target) && arrayInstcumentation.hasOwnProperty(key)) {
    return arrayInstcumentation[key];
  }

  const result = Reflect.get(target, key, receiver);
  if (isObject(result)) return reactive(result);
  return result;
}

// 拦截基本操作 .hasProperty ，如使用 in
function has(target, key) {
  track(target, TrackOpType.HAS, key);

  return Reflect.has(target, key);
}

// 拦截基本操作 .ownKeys，如使用 for...in
function ownKeys(target) {
  track(target, TrackOpType.ITERATE);

  return Reflect.ownKeys(target);
}

// 拦截基本操作 .set ，如修改、添加
function set(target, key, value, receiver) {
  const oldValue = target[key];
  const oldLenth = Array.isArray(target) ? target.length : undefined;
  const type = target.hasOwnProperty(key)
    ? TriggerOpType.SET
    : TriggerOpType.ADD;

  const result = Reflect.set(target, key, value, receiver);
  if (!result) return result;

  // 只有 add 或新旧数据不同的 set 才需要 trigger
  if (type === "add" || isChange(oldValue, value)) {
    trigger(target, type, key);

    /**数组特殊情况一：当设置数组元素超过原本的 length 时，或者类似这种隐式修改 length 的情况
     * const arr = reactive([ 1, 2 ]);
       arr[10] = 123;
     * 只 track add 10 ，length 变长但并没有 track set length
       原因是 JS 源码中对数组的这种操作会调用：
       Object.defineProperty(arr, "10", { value: 123 });
       但这种方式本身就不会触发 Proxy 的 set
     */
    const newLenth = Array.isArray(target) ? target.length : undefined;
    if (Array.isArray(target) && newLenth !== oldLenth) {
      if (key !== "length") trigger(target, TriggerOpType.SET, "length");
      else {
        /**数组特殊情况二：当主动变小 length 事，删除的元素不会触发 delete
         * const arr = reactive([ 1, 2, 3 ]);
         arr.length = 1;
         */
        for (let i = newLenth; i < oldLenth; i++)
          trigger(target, TriggerOpType.DELETE, i.toString());
      }
    }
  }

  return result;
}

// 拦截基本操作 delete
function deleteProperty(target, key) {
  const hasKey = target.hasOwnProperty(key);
  if (!hasKey) return true;

  const result = Reflect.deleteProperty(target, key);
  if (result) trigger(target, TriggerOpType.DELETE, key);

  return result;
}

export const handlers = {
  get,
  has,
  ownKeys,
  set,
  deleteProperty,
};
```

```
// reactive.js

import { isObject, isProxy } from "./utils.js";
import { handlers } from "./handlers.js";

// 防止同一个原始对象重复使用 Proxy，提高效率
export const targetMap = new WeakMap();

export function reactive(target) {
  // 如果不是引用类型，或者已经是 Proxy 了，就直接 return
  if (!isObject(target) || isProxy(target)) return target;
  // 如果源引用 target 已经被 Proxy 代理过了，就直接 return
  if (targetMap.has(target)) return targetMap.get(target);

  const proxy = new Proxy(target, handlers);
  targetMap.set(target, proxy);

  return proxy;
}
```

```
// ref.js

import { reactive } from "./reactive.js";
import { track, trigger } from "./effect.js";
import { TrackOpType, TriggerOpType } from "./operate.js";
import { isObject, isChange } from "./utils.js";

export function ref(value) {
  return {
    get value() {
      track(this, TrackOpType.GET, "value");

      if (isObject(value)) value = reactive(value);
      return value;
    },

    set value(newValue) {
      if (!isChange(value, newValue)) return;
      if (isObject(newValue)) newValue = reactive(newValue);

      value = newValue;
      trigger(this, TriggerOpType.SET, "value");
    },
  };
}
```

```
// computed.js

import { effect } from "./effect.js";
import { track, trigger } from "./effect.js";
import { TrackOpType, TriggerOpType } from "./operate.js";

function normalizeParamece(options) {
  let getter, setter;

  if (typeof options === "function") {
    getter = options;
    setter = () => {};
  } else {
    getter = options.get;
    setter = options.set;
  }

  return { getter, setter };
}

export function computed(options) {
  const { getter, setter } = normalizeParamece(options);

  // lazy 执行，只有 .value 才执行 computed
  const effectFn = effect(getter, {
    lazy: true,
    scheduler: () => {
      /**依赖数据变化时，只需要修改 dirty
       * computed 依赖的数据变化时会重新执行，但如果 computed 都没有 .value 的话，
         不管依赖数据是否变化，computed都不会执行
       */
      dirty = true;

      trigger(result, TriggerOpType.SET, "value");
    },
  });

  // 必报数据
  let oldValue,
    dirty = true;

  const result = {
    get value() {
      // computed 自身也是数据，也需要 track
      track(result, TrackOpType.GET, "value");

      // 缓存，只有 computed 依赖的数据变化，才重新执行 computed
      if (dirty) {
        oldValue = effectFn();
        dirty = false;
      }

      return oldValue;
    },

    set value(newValue) {
      setter(newValue);
    },
  };

  return result;
}
```

### 5.2 虚拟 DOM、diff 算法

template 的本质是 render 函数的语法糖，template 最终会编译为 render 函数。render 是一个 Watcher ，每次数据更新都再次 render 。

如果 render 函数直接生成真实 DOM ，性能会很低，所以 render 函数只生成虚拟 DOM （Virtual DOM，VDOM），和上次更新的 VDOM 比较，找到变化的部分，进行最小量更新：

- 框架的性能永远比不上原生 JS ，VDOM 只是因为 render 直接渲染真实 DOM 性能低才出现的

- VDOM 还可以实现跨平台，根据平台生成对应的真实 DOM

过程：

* Vue 吃石化时，模板编译得到 render （若写了 render 则直接用 render）

* 把 reder 放到 Watch 中，每次数据更新就会重新执行 render 

* 比较新旧 VNode ，为了提高性能以及结合实际应用场景，只会比较同一层级，若 tag 和 key 相同则是同一个节点

* 相同节点根据 child 的类型进行更新，若新旧 child 等候室子节点数组，则用 diff 算法比较，找到 tag 和 key 相同的节点，相同就只移动和 patch，新增新节点，删除旧节点

代码，Vue 的 VDOM 和 diff 基于第三方库 snabbdom ：

```
class VNode {
  public diffFlag = false;

  constructor(
    public tag: string,
    public attr: { [key: string]: any },
    public child: string | Array<VNode>,
    public elm?: Element,
  ) {}
}

// ----------------------------------------------------------------------------------------------
// to VDOM
const h = (
  tag: string,
  attr: { [key: string]: any },
  child: string | Array<VNode>,
) => new VNode(tag, attr, child);

// VODM to DOM
const createElement = (vnode: VNode): Element => {
  const elm = document.createElement(vnode.tag);
  vnode.elm = elm;

  if (typeof vnode.child === "string") elm.innerText = vnode.child;
  else for (const child of vnode.child) elm.append(createElement(child));

  return elm;
};
// ----------------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------------
const isSameNode = (oldNode: VNode, newNode: VNode): boolean => {
  return oldNode.tag === newNode.tag && oldNode.attr.key === newNode.attr.key;
};

/**Vue2 diff
 * 使用双端指针，按照 os-ns，oe-ne，os-ne，oe-ns 4 中策略依次找到相同节点，patch，其中后 2 个策略需要 move
 * 若 4 种策略都找不到，则遍历 oldChild 寻找（可用 map 缓存）：
   - 若找到，则 move，patch，并标记为已处理
   - 若找不到，则新增
 * 最后根据双端指针的位置，新增、删除节点
 */
const diff_Vue2 = (oldChild: Array<VNode>, newChild: Array<VNode>): void => {
  let oldStart = 0;
  let newStart = 0;
  let oldEnd = oldChild.length - 1;
  let newEnd = newChild.length - 1;

  const parent = oldChild[0].elm!.parentNode as Element;

  const keyToOldIndexMap: Map<string, number> = new Map();

  // 4 种策略依次对比对比
  while (oldStart <= oldEnd && newStart <= newEnd) {
    // 跳过
    if (oldChild[oldStart].diffFlag) {
      ++oldStart;
      continue;
    } else if (oldChild[oldEnd].diffFlag) {
      --oldEnd;
      continue;
    }

    // 4 种策略
    if (isSameNode(oldChild[oldStart], newChild[newStart])) {
      patchVNode(oldChild[oldStart++], newChild[newStart++]);
      continue;
    } else if (isSameNode(oldChild[oldEnd], newChild[newEnd])) {
      patchVNode(oldChild[oldEnd--], newChild[newEnd--]);
      continue;
    } else if (isSameNode(oldChild[oldStart], newChild[newEnd])) {
      // 移动
      parent.insertBefore(
        oldChild[oldStart].elm!,
        oldChild[oldEnd].elm!.nextSibling,
      );

      patchVNode(oldChild[oldStart++], newChild[newEnd--]);
      continue;
    } else if (isSameNode(oldChild[oldEnd], newChild[newStart])) {
      // 移动
      parent.insertBefore(oldChild[oldEnd].elm!, oldChild[oldStart].elm!);

      patchVNode(oldChild[oldEnd--], newChild[newStart++]);
      continue;
    }
    // 若 4 种策略都没有找到相同节点，则需再次遍历一次 oldChild 未处理节点
    else {
      // 用 map 缓存起来，以后就能快速查询
      if (keyToOldIndexMap.size === 0) {
        for (let oldIndex = oldStart; oldIndex <= oldEnd; oldIndex++) {
          keyToOldIndexMap.set(oldChild[oldIndex].attr.key || "", oldIndex);
        }
      }

      const oldIndex = keyToOldIndexMap.get(newChild[newStart].attr.key);

      if (
        oldIndex !== undefined &&
        isSameNode(oldChild[oldIndex], newChild[newStart])
      ) {
        oldChild[oldIndex].diffFlag = true;
        parent.insertBefore(oldChild[oldIndex].elm!, oldChild[oldStart].elm!);
        patchVNode(oldChild[oldIndex], newChild[newStart]);
      }
      // 如果没找到，说明是新的节点
      else {
        parent.insertBefore(
          createElement(newChild[newStart]),
          oldChild[oldStart].elm!,
        );
      }

      ++newStart;
    }
  }

  /**收尾
   * 如果 oldNode 先遍历完，说明 newNode 有需要新增的节点
   * 如果 newNode 先遍历完，说明 oldNode 有需要删除的节点
   * 如果同时遍历完，就不需要处理
   */
  if (oldStart > oldEnd && newStart <= newEnd) {
    const before = oldChild[oldEnd].elm!.nextSibling
      ? oldChild[oldStart].elm!
      : null;

    for (let i = newStart; i <= newEnd; i++) {
      parent.insertBefore(createElement(newChild[i]), before);
    }
  } else if (oldStart <= oldEnd && newStart > newEnd) {
    for (let i = oldStart; i <= oldEnd; i++) {
      if (!oldChild[i].diffFlag) parent.removeChild(oldChild[i].elm!);
    }
  }
};

// 最长递增子序列
function longestIncreasingSubsequence(nums: number[]): number[] {
  if (nums.length === 0) return [];

  // res 存储 index ，pre 存储前驱 index
  const res: number[] = [];
  const pre: number[] = new Array(nums.length).fill(-1);

  // 这里只处理 >= 0 的数字
  let start = 0;
  for (start = 0; start < nums.length; start++) {
    if (nums[start] >= 0) {
      res[0] = start;
      break;
    }
  }

  // 开始
  for (let i = start + 1; i < nums.length; i++) {
    if (nums[i] < 0) continue;

    const resLastIndex = res[res.length - 1];

    if (nums[i] > nums[res[resLastIndex]]) {
      res.push(i);
      pre[i] = res[resLastIndex];
    }
    // 否则就用二分，找到第一个大于 nums[i] 的数字，用谈心思想，替换得到当前最优解
    else {
      let left: number = 0;
      let right = resLastIndex;
      let mid = Math.floor((left + right) / 2);

      for (; left < right; mid = Math.floor((left + right) / 2)) {
        if (nums[res[mid]] < nums[i]) left = mid + 1;
        else right = mid;
      }

      res[left] = i;
      if (left > 0) pre[i] = res[left - 1];
    }
  }

  // 反向检查
  for (let i = res.length - 1; i > 0; i--) res[i - 1] = pre[res[i]];

  return res;
}

/**Vue3 diff
 * 先用双端指针找到两边相同节点，patch
 * 若上一步结束后，仅有新增、删除节点，直接新增、删除，结束 diff
 * 若 old、new 都还有节点：
   - 删除 new 没有的节点
   - 找出最长递增子序列 sub ，sub 中的节点相对位置在 new 中是不变的，不需要移动，只需要 patch ；
     move，patch 不再 sub 的节点，新增 old 没有的节点
 */
const quickDiff_Vue3 = (
  oldChild: Array<VNode>,
  newChild: Array<VNode>,
): void => {
  let i = 0;
  let oldEnd = oldChild.length - 1;
  let newEnd = newChild.length - 1;

  // 双端指针先找到前后不需要移动的节点
  while (i <= oldEnd && i <= newEnd) {
    if (isSameNode(oldChild[i], newChild[i])) {
      patchVNode(oldChild[i], newChild[i]);
      ++i;
    } else break;
  }
  while (i <= oldEnd && i <= newEnd) {
    if (isSameNode(oldChild[oldEnd], newChild[newEnd])) {
      patchVNode(oldChild[oldEnd--], newChild[newEnd--]);
    } else break;
  }

  // 如果还有未处理的节点
  if (i <= oldEnd || i <= newEnd) {
    const parent = oldChild[0].elm!.parentNode as Element;

    // 全部是要删除的节点i
    if (i <= oldEnd && i > newEnd) {
      for (; i <= oldEnd; i++) parent.removeChild(oldChild[i].elm!);
    }
    // 全部是要新增的节点
    else if (i > oldEnd && i <= newEnd) {
      for (; i <= newEnd; i++) {
        const before = oldChild[oldEnd + 1]?.elm || null;
        parent.insertBefore(createElement(newChild[i]), before);
      }
    }
    // 复杂情况
    else {
      let oldStart = i;
      let newStart = i;

      // map 缓存 newChild
      const keyToNewIndexMap: Map<string, number> = new Map();
      for (; newStart <= newEnd; newStart++) {
        keyToNewIndexMap.set(newChild[newStart].attr.key, newStart);
      }

      // newNode 在 oldChild 中的 index
      const toBePatch = newEnd - i + 1;
      const newNodeInOldIndexMap = Array(toBePatch).fill(-1);

      // 遍历 oldChild
      let needMove = false;
      let newIndexSoFar = -1;
      for (; oldStart <= oldEnd; oldStart++) {
        const newIndex: number | undefined = keyToNewIndexMap.get(
          oldChild[oldStart].attr.key,
        );

        // 如果在 newChild 中找不到，说明要删除
        if (
          newIndex === undefined ||
          !isSameNode(oldChild[oldStart], newChild[newIndex])
        ) {
          parent.removeChild(oldChild[oldStart].elm!);
        }
        // 找到了就记录下来
        else {
          newNodeInOldIndexMap[newIndex - i] = oldStart;

          // 确定后续是否需要移动，一旦不是连续递增就需要移动
          if (!needMove) {
            if (newIndex > newIndexSoFar) newIndexSoFar = newIndex;
            else needMove = true;
          }
        }
      }

      // 处理 newNodeInOldIndexMap ，新增、踢动节点
      const subsequence = needMove
        ? longestIncreasingSubsequence(newNodeInOldIndexMap)
        : [];

      let last = subsequence.length - 1;
      for (let j = newNodeInOldIndexMap.length - 1; j >= 0; j--) {
        const oldIndex = newNodeInOldIndexMap[j];
        const before = newChild[j + i + 1]?.elm || null;

        // 新增
        if (oldIndex === -1) {
          parent.insertBefore(createElement(newChild[j + i]), before);
        }
        // 移动或跳过
        else {
          // 只有不再最长递增子序列中，才需要移动
          if (
            needMove &&
            (last < 0 || oldIndex !== newNodeInOldIndexMap[subsequence[last]])
          ) {
            parent.insertBefore(oldChild[oldIndex].elm!, before);
          } else --last;

          patchVNode(oldChild[oldIndex], newChild[j + i]);
        }
      }
    }
  }
};
// ----------------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------------
const patchVNode = (oldNode: VNode, newNode: VNode): void => {
  const oldNodeElm = oldNode.elm as Element;
  newNode.elm = oldNodeElm;

  // 若 newNode 是文本，直接覆盖
  if (typeof newNode.child === "string") {
    oldNodeElm.innerHTML = newNode.child;
  }
  // 若 newNode 有子节点，oldNode 是文本或空数组
  else if (typeof oldNode.child === "string" || oldNode.child.length === 0) {
    oldNodeElm.innerHTML = "";
    for (const child of newNode.child) {
      oldNodeElm.appendChild(createElement(child));
    }
  }
  // 若 newNode、oldNode 都有子节点，则适应 diff
  // else diff_Vue2(oldNode.child, newNode.child);
  else quickDiff_Vue3(oldNode.child, newNode.child);
};

const patch = (oldNode: Element | VNode, newNode: VNode): void => {
  if (oldNode === newNode) return;

  // 如果是第一次 render ，传入的 oldNode 是 Element ，就直接渲染 newNode
  if ((oldNode as Element).nodeType) {
    const elm = oldNode as Element;
    elm.appendChild(createElement(newNode));
  }
  // 否则，就比较新旧 vnode
  else {
    oldNode = oldNode as VNode;

    // 只比较同一层级，若 tag 和 key 相同，就认为 2 个 vnode 是相同的
    if (isSameNode(oldNode, newNode)) patchVNode(oldNode, newNode);
    else {
      const oldNodeElm = oldNode.elm as Element;

      const parent = oldNodeElm.parentNode;
      parent!.insertBefore(createElement(newNode), oldNodeElm);
      parent?.removeChild(oldNodeElm);
    }
  }
};
// ----------------------------------------------------------------------------------------------

class Vue {
  public _vnode: Element | VNode | null = null;
  public _data: any;
  public _render: (h: Function) => VNode;

  constructor(options: { [key: string]: any }) {
    this._data = options.data();
    this._render = options.render;

    if (options.el) this.$mount(options.el as string);
  }

  public _update() {
    const newNode = this._render.call(this, h);
    patch(this._vnode!, newNode);
    this._vnode = newNode;
  }

  public $mount(sel: string) {
    const app = document.querySelector(sel);
    if (!app) return;

    this._vnode = app;
    this._update();

    // new Watch(this, () => this._update());
  }
}

const vm = new Vue({
  data: function () {
    return {
      arr: [
        { id: "1", value: "item 1" },
        { id: "2", value: "item 2" },
        { id: "3", value: "item 3" },
        { id: "4", value: "item 4" },
        { id: "5", value: "item 5" },
      ],
    };
  },

  render(h: Function): VNode {
    return h(
      "ul",
      {},
      this._data.arr.map((item: any) => {
        if (typeof item.value === "string")
          return h("li", { key: item.id }, item.value);
        else {
          return h(
            "p",
            { key: item.id },
            item.value.map((i: any) => h("li", { key: i.id }, i.value)),
          );
        }
      }),
    );
  },
});

vm.$mount("#app");

vm._data?.arr?.splice(2, 1, {
  id: "3",
  value: [
    { id: "3-1", value: "item 31" },
    { id: "3-2", value: "item 32" },
  ],
});
vm._update();
```

从 diff 中可以看出，v-for 加了唯一 key 就可以找出新旧 VNode 相同节点，提高性能：

```
<script>
export default {
  data: function () {
    return {
      list: [
        { id: "1", value: "1" },
        { id: "2", value: "2" },
        { id: "3", value: "3" },
      ],

      formChangeTag: true,
    };
  },

  methods: {
    insertListItem() {
      this.list.unshift({ id: "0", value: "0" });
    },
  },
};
</script>

<template>
  <div>
    <button @click="insertListItem">insert list</button>

    <!-- 
      key 默认会传入 index ，但是这样修改数据后会打乱 key 和节点的对应关系，
      把原本不同的节点判断为相同节点，使得进行了很多不必要的 patch ，浪费性能
    -->
    <ul>
      <li v-for="i in list">{{ i.value }}</li>
    </ul>
    <br />

    <!-- 使用唯一的 key 后，数据修改后能快速找到相同节点并 patch ，性能提高，因为相同节点内部的变化通常是很小的 -->
    <ul>
      <li v-for="i in list" :key="i.id">{{ i.value }}</li>
    </ul>
    <br />

    <!-- input 测试可以更明显，加唯一 key 就能解决 -->
    <ul>
      <li v-for="i in list"><input type="text" /></li>
      <!-- <li v-for="i in list" :key="i.id"><input type="text" /></li> -->
    </ul>
  </div>
</template>
```

### 5.3 模板编译

template 本质就是 string ，是 render 的语法糖，template 最终会编译为 render 。

render 函数需要一个根节点，所以 template 才需要根节点，Vue3 会默认加上 Fragment 作为根节点。

# 二、React
