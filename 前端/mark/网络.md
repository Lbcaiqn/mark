# 一、基本

chrome 调试工具 \- network 中调试。

## 1 URL

（1）基本

统一资源定位符，用于在互联网上获取资源。

格式：

| 组成          | 示例              |
| ----------- | --------------- |
| 协议（scheme）  | http://         |
| 域名（domain）  | localhost       |
| 端口（port）    | :80             |
| 路径（path）    | /data           |
| 查询参数（query） | ?page=1&size=30 |
| 哈希（hash）    | #123456         |

细节：

- 其中，协议、域名、路径为必须向，若只输入了域名，呢浏览器会自动加协议和根路径 /
  
  - 在 \<a\>、\<img\> 等中的绝对路径 URL，若只有 path ，则其他的部分会根据当前网站 URL 补全其他部分
  
  - 在 \<a\>、\<img\> 等谨慎使用相对路径的 URL，如 Vue 打包后路径会变化

- 端口默认值：http 协议为 80 ，https 协议为 43

- 哈希的内容不会被传输

URL 对应服务器中的某个程序，由程序提供服务，如：

- 后端服务器，由后端程序提供各种服务的接口

- 静态资源服务器，由 nginx 等提供访问静态资源的服务

（2）域名

* 127\.0\.0\.1 为本机，域名为 localhost

* 从右往左解析，不区分大小写

* 构成：
  
  * 次级域名\.顶级域名，如 www.example.com ，分别是三级、二级、顶级域名
  
  * 次级域名\.公共后缀，如 www.example.github.io ，分别是四级 \~ 顶级域名，其中 github\.op 是公共后缀：
    
    * 公共后缀是一个标准，如 \.com ，.github\.io ，具体可查阅 https://publicsuffix.org/list/
    
    * 顶级域名一定是公共后缀，反之则不然

* 站点域：次级域名\.公共后缀，可以不断划分子域，如 sub\.example\.com 是 example\.com 的子域

（3）域名映射

有时在开发环境需要把 localhost 映射为其他域名，这里使用 whistle \+ Prosy Switch Omega 。

```
npm install -g whistle
w2 start
```

管理员权限修改 hosts 文件：

```
# windows 在 C:\Windows\System32\drivers\etc\hosts
# Linux 、mac 在 /etc/hosts

127.0.0.1 a.test
127.0.0.1 b.test
```

终端 ping 测试是否配置成功：

```
ping a.test
ping b.test
```

浏览器输入 localhost\:8899 进入 whistle 配置页面，在 Rules 中配置：

```
a.test 127.0.0.1
b.test 127.0.0.1
```

chrome 安装插件 Proxy Switch Omega \-\> 点击插件 \-\> 选项 \-\> 进入配置页面 \-\> 左侧栏的添加情景模式 \-> 输入代理名并配置为 http\://127.0.0.1\:8899 \-\> 左侧栏的应用选项。

当需要进入 a\.test 和 b\.test 时，把 Switch Omega 的代理设置为刚才配置的代理即可，访问 localhost 依然有效，也不用代理。

这样，localhost ，a\.test ，b\.test 就是三个不同的站点域。 

## 2 http 协议

协议规定了数据传输的模式和格式。

协议模式：请求响应，单工或半双工，客户端 request 服务器 response ，如：

- 浏览器和服务器，单工

- 两个服务器，半双工，客户端和服务器之间可以互相转换

（1）request 格式

如在 request.http 文件中；

```
GET /data?page=1 HTTP/1.1
HOST: localhost
Content-Type: application/json


{
  "size": "30"
}
```

- 请求行：requestMethod pathAndQuery scheme、
  
  - requestMethod 只是语义化，具体的功能由客户端和服务器规定，但一般都会用常规的 method ，如 POST、GET、PUT、DELETE ，分别对应 CRUD
  
  - path、query、requestHead、requestBody 都可以传递参数，一般 GET 无法使用 body ，所以 GET、POST 的区别大部分都在参数方面：
    
    - GET 参数一般在 query， POST 参数一般在 body，因此 GET 的参数就会受到 URL 长度的限制、参数也会显示在 URL 中，但也不是说 POST 参数更加安全，是否安全由协议决定，http 都是铭文、https 则会假面
    
    - 由于 GET 保存了完整的参数，所以浏览器会保留 GET 请求的历史记录，刷新也能完整复现请求，POST 则缺少参数

- 请求头：
  
  - HOST: domian
  
  - Content\-Type: 请求体格式

- 请求体：即使没有请求体，与请求头之间必须由两个换行符

（2）response 格式

```
HTTP/1.1 200 OK
Server: localhost
Content-Type: text/html

html
```

- 响应头：scheme responseCode responseMessage
  
  - responseCode 和 responseMessage 由后端决定，但 responseCode 一般都会用常规的 code ，如：
    
    | code | 描述                                       |
    | ---- | ---------------------------------------- |
    | 1xx  | 表示还需要进一步 request ，如断点下载                  |
    | 2xx  | 表示成功，最常见是 200                            |
    | 3xx  | 表示成功，但有额外情况，如 301 永久重定向、302 临时重定向、304 缓存 |
    | 4xx  | 表示客户端错误，如                                |
    | 5xx  | 表示服务器错误，如                                |

## 3 JSON

早期在网络传输中的数据格式是 XML ，现代的则是 JSON 格式，类似 JS 的对象：

- key 必须用双引号，string 的 value 也必须双引号

- 最后一个属性不能加逗号

（1）形式

JSON 文件，通常作为配置文件，文件内容必须是严格的 JSON 格式：

* 必须是一个对象

* 不能写注释（tsconfig\.json 除外）

```
{
  "option1": "value"
}
```

JSON 字符串，通常用于网络传输，可以不仅是对象：

* string 必须用双引号

* 若是数组，最后一个元素不能加逗号

```
const json1 = `{"a":"asdf"}`;
const json2 = `[1,"2"]`;
const json3 = `123`;
const json4 = `"asdf"`;
```

（2）JSON API

将数据序列化为严格的 JSON 字符串：

```
const obj1 = { a: 1, b: "b", c: true };
const obj2 = {};
const arr1 = [1, "a"];
const arr2 = [];

// `{"a":1,"b":"b","c":true}` `{}`
console.log(JSON.stringify(obj1), JSON.stringify(obj2), "\n");
// `[1,"a"]` `[]`
console.log(JSON.stringify(arr1), JSON.stringify(arr2), "\n");

// 基本数据类型
console.log(
  JSON.stringify(123),
  JSON.stringify("asdf"),
  JSON.stringify(true),
  JSON.stringify(null),
  "\n"
);

// 缺点 -------------------------------------------------------------------------------------
const testProtoObj = {};
testProtoObj.__proto__.a = 1;

/**
 * NaN 转为 null ；Date 转为时间的字符串
 * RegExp 、字面量正则  、Set 、Map 等转为 "{] ；正则可以先转为 string 、其他可以先转为数组再序列化解决"
 * 无法序列化到圆形上
 * 这些类型作为对象 value ，数组元素时，序列化规则也一样
 */
console.log(
  JSON.stringify(NaN),
  JSON.stringify(new Date()),
  JSON.stringify(new RegExp(/a1/)),
  JSON.stringify(/a1/),
  JSON.stringify(new Map([["a", 1]])),
  JSON.stringify(new WeakSet([Symbol(), { a: 1 }])),
  JSON.stringify(testProtoObj)
);

console.log(
  JSON.stringify({
    a: null,
    b: new Date(),
    c: new RegExp(/a1/),
    d: /a1/,
    e: new Map([["a", 1]]),
    f: new WeakSet([Symbol(), { a: 1 }]),
    g: testProtoObj,
  }),

  JSON.stringify([
    null,
    new Date(),
    new RegExp(/a1/),
    /a1/,
    new Map([["a", 1]]),
    new WeakSet([Symbol(), { a: 1 }]),
    testProtoObj,
  ]),

  "\n"
);

/**
 * undefined ，function ，Symbol 转为 undefined ，且 typeof 类型就是 undefined ，不是 string
 * 其实就是在 stringify 内部忽略了这些类型，直接 return undefined ，等价于无参数的 stringify
 * 这些类型作为对象 value 时会直接忽略；作为数组元素则转为 null
 */
console.log(
  JSON.stringify(undefined),
  JSON.stringify(function () {}),
  JSON.stringify(Symbol()),
  JSON.stringify()
);

console.log(
  JSON.stringify({
    a: undefined,
    b: function () {},
    c: Symbol(),
    [Symbol()]: 123,
  }),

  JSON.stringify([undefined, function () {}, Symbol()]),

  "\n"
);

/**数据代理，规则其实也符合上面的
 * Object.defineProperty ：
  - 对象的属性：必须可枚举，且 return 非 undefined 才会序列化
  - 数组的元素：不必须可枚举，undefined 会转为 null
 * Proxy 代理对象同理;代理数组特殊，设置 get 时 undefined 不会转为 null ，不设置 get 则可以转为 null
 */
const define1 = {};
const define2 = [];

Object.defineProperty(define1, "a", {
  get: () => 1,
  enumerable: true,
});

Object.defineProperty(define2, "0", { get: () => undefined });

const ref = {
  get value() {
    return 1;
  },
};
const reactiveObj = new Proxy({ a: 1 }, { get: () => 1 });
const reactiveArr1 = new Proxy([undefined], {});
const reactiveArr2 = new Proxy([undefined], { get: () => undefined });

console.log(
  JSON.stringify(define1),
  JSON.stringify(define2),
  JSON.stringify(ref),
  JSON.stringify(reactiveObj),
  JSON.stringify(reactiveArr1),
  JSON.stringify(reactiveArr2),
  "\n"
);

/**err
 * BigInt ，循环引用直接 err
 */
const o = {};
o.obj = o;

try {
  console.log(
    JSON.stringify(123n),
    JSON.stringify(o),
    JSON.stringify({ a: 123n, obj: o }),
    JSON.stringify([123n, o])
  );
} catch {
  console.log("err");
}
```

将 JSON 字符串还原为原始数据：

```
const obj1 = `{ "a": 1, "b": "b" }`;
const arr1 = `[ 1, "a" ]`;
const num = "123";
const str = `"asdf"`;

// 正常还原，空格无所谓
console.log(
  JSON.parse(obj1),
  JSON.parse(arr1),

  JSON.parse(num),
  JSON.parse(str),
  JSON.parse("null")
);

const obj2 = "a:1";
const obj3 = `"a":1,`;
const arr2 = `'a',`;

// err ，必须是严格的 JSON 格式 ，"undefined" 、"NaN" 也 err
try {
  console.log(
    JSON.parse(obj2),
    JSON.parse(obj3),
    JSON.parse(arr2),

    JSON.parse(""),
    JSON.parse("'a'"),
    JSON.parse("undefined"),
    JSON.parse("NaN")
  );
} catch {
  console.log("err");
}
```

## 4 浏览器网络

浏览器具备用户代理（user agent）的行为，意思是浏览器可以自动发送请求、自动接收响应并进行渲染。

（1）自动发送请求

- 浏览器输入 url 并 enter 会发送 GET 请求；刷新会复现请求，requestMethod 也会复现

- \<a\> 的 href

- \<form\> 中 type 为 submit 的 \<button\>
  
  - 虽然现在很少用原生 \<form\> 发请求，但是在处理交互时使用 \<form\> 会更加方便，可以避免在自己处理时考虑很多情况；
    
    ```
    <body>
      <div>
        <form id="search">
          <input type="text">
          <button type="submit">search</button>
        </form>
      </div>
    </body>
    <script>
      const form = document.querySelector("#search");
      form.onsubmit = function(e) {
          e.preventDefault();
          // ...
      }
    </script>
    ```

- \<script\>、\<link\> 、\<img\>、\<audio\> 等会自动请求资源

（2）自动接收响应

- 根据 responseCode 做对应的操作，如重定向

- 根据 Content\-Type 决定如何处理响应体，如 text/html 才会渲染 html

（3）浏览器输入 URL 后，在网络层面的步骤

1. 检查 URL 是否错误，并补全 URL ，然后进行 encode 编码非 ASCL 字符

2. DNS 解析得到 I[P 地址

3. 与目标服务器建立 TCP 连接，直到关闭页面时才断开

4. 解析响应，根据 code 进行对应处理；根据 Content\-Type 处理响应体，若是 text/html 则进行 html 的渲染

# 二、ajax

ajax（async javascript and xml），浏览器提供给 JS 的网络请求能力，包含 xhr 和 fetch 。

## 1 xhr 、fetch

（1）xhr

xhr（xml http requeszt），回调风格的 api ：

```
<!DOCTYPE html>
<html lang="en">
  <body></body>

  <script>
    const api = "http://localhost:4000/data";

    // window.XMLHttpRequest
    const xhr = new XMLHttpRequest();

    // 第三个参数为是否异步，默认为 true
    xhr.open("POST", api, true);

    // 默认为 'text/plain;charset=UTF-8'
    xhr.setRequestHeader("Content-Type", "application/json");

    /**接收响应体的格式
     * "" ：默认值，和 "text" 一样
     * "text" ：string
     * “json” ：自动调用 JSON.parse
     * "blob" ：二进制 blob ，适合文件下载
     * "arraybuffer" ：原始二进制缓冲区
     * "document" ：html 或 xml ，需要配合 "Content-type"
     */
    xhr.responseType = "json";

    // xhr.readyState 改变就触发
    xhr.onreadystatechange = function () {
      /**xhr.readystate ：
       * 0 : new XMLHttpRequest()
       * 1 : open 调用完毕 ,，可以调用 setRequestHeader 了
       * 2 : send 调用，响应头接收完毕
       * 3 : 正在接收响应体，可能调用多次
       * 4 : 响应完全接收
       */
      console.log(xhr.readyState);
      if (xhr.readyState !== 4) return;

      if (xhr.status >= 200 && xhr.status <= 300) {
        console.log(xhr.status, xhr.statusText);
        console.log(xhr.getAllResponseHeaders());

        // 始终为 string ，仅在 xhr.responseType 为 "" 、"text" 时可用"
        // console.log(xhr.responseText);

        // 根据自己设置的 xhr.responseType 决定
        console.log(xhr.response);
      } else {
        // 超时、取消请求的 status 没有改变，是默认的 0 ，可以直接 return ，在外部的超时、取消事件处理
        console.log("请求失败、超时或被取消：" + xhr.status);
      }
    };

    // 请求因网络错误时触发，如 DNS 无法解析，无法跨域等，不包括 4xx 、5xx
    xhr.onerror = function (e) {};

    // 请求开始时触发
    xhr.onloadstart = function (e) {};

    // 调用 abort() 取消请求时触发
    xhr.onabort = function (e) {};

    // 请求期间触发，用于进度监控
    xhr.onprogress = function (e) {};

    // 请求成功时触发，即 xhr.readyState 为 4 且状态码为 2xx
    xhr.onload = function () {};
    // 请求完成时触发，无论成功失败
    xhr.onloadend = function (e) {};

    // 请求超时触发，默认值为 0 ，规定 <= 0 即没有超时限制
    xhr.timeout = 5000;
    xhr.ontimeout = function (e) {};

    // 发送请求
    xhr.send(JSON.stringify({ a: 1, b: undefined }));

    // 取消请求
    // xhr.abort();
  </script>
</html>
```

jQuery 的 xhr ：

```
<!DOCTYPE html>
<html lang="en">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script>
    const api = "http://localhost:4000/data";

    $.ajax({
      url: api,
      method: "POST",
      dataType: "json",

      contentType: "application/json",
      data: JSON.stringify({
        a: 1,
        b: undefined,
      }),

      success: function (data) {
        console.log(data);
      },

      error: function (jqXHR, textStatus, errorThrown) {},
    });
  </script>
</html>
```

（2）fetch

HTML5 新特性，目前除了进度监控外，fetch 具备 xhr 的所有能力，功能也更丰富，是 Promise 风格 的 api ：

```
<!DOCTYPE html>
<html lang="en">
  <body></body>

  <script>
    const api = "http://localhost:4000/data";

    // window.fetch
    fetch(api, {
      // 默认为 "GET"
      method: "POST",

      headers: {
        // 默认为 'text/plain;charset=UTF-8'
        "Content-Type": "application/json",
      },

      body: JSON.stringify({
        a: 1,
        b: undefined,
      }),
    })
      .then((res) => {
        // fetch 将获取响应数据流氛围两个阶段，在响应体过大时可以先得到响应头

        // 响应头
        console.log(res);

        // 获取响应体，返回 Promise ，使用的函数表示以什么格式读取
        // return res.json();
        return res.text();
      })
      .then((resBody) => console.log(JSON.parse(resBody)))
      .catch((error) => console.log("请求失败"));

    // 超时，取消请求 -------------------------------------------------------------------
    const controller = new AbortController();

    // 默认没有超时时间
    const timeoutId = setTimeout(() => controller.abort(), 5000);

    fetch(api, {
      method: "POST",
      signal: controller.signal,
    })
      .then((res) => {
        // 请求成功，清除超时
        clearTimeout(timeoutId);

        return res.json();
      })
      .then((resBody) => console.log(resBody))
      .catch((err) => {
        if (err.name === "AbortError") console.log("请求超时或被取消");
        else console.log("请求失败");
      });
  </script>
</html>
```

（3）axios

对 xhr 的封装：

```
npm install --save axios
```

```
<!DOCTYPE html>
<html lang="en">
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script>
    const api = "http://localhost:4000/data";

    // 用于取消请求
    const controller = new AbortController();

    /**axios
     * 只有 url 必选，method 默认 “GET” ，“Content-Type”在有请求体时默认为 "application/json"
     * 会自动 JSON.stringify 和 JSON.parse
     * 也可以是 axios(url, options) 或 axios.get(url, options)
     */
    axios({
      // 最终为 baseURL + url ，baseURL 默认为 ""
      url: api,
      baseURL: "",

      method: "POST",
      headers: {},

      // 可以把 get 请求的 search 写在里面，简化 url
      params: {},
      // 请求体
      data: { a: 1, b: undefined },

      // 超时时间，默认值为 0 ，<= 0 规定为没有超时限制
      timeout: 5000,

      // 用于取消请求
      signal: controller.signal,
    }).then(
      (res) => console.log(res.data),
      (err) => {
        if (axios.isCancel(err)) console.log("请求被取消");
        else if (err.code === "ECONNABORTED") console.log("请求超时");
        else console.log("请求失败");
      }
    );

    // 取消请求
    // controller.abort();

    // 取消请求的就方式，已被弃用
    // const CancelToken = axios.CancelToken;
    // const source = CancelToken.source();
    // axios({
    //   url: api,
    //   method: "POST",
    //   cancelToken: source.token,
    // })
    //   .then((res) => console.log(res.data))
    //   .catch((error) => {
    //     if (axios.isCancel(error)) console.log("请求被取消");
    //   });
    // source.cancel("取消");

    // axios.all ，即数组元素是 axios 的 Promise.all -----------------------------------------
    axios
      .all([axios(api, { method: "POST" }), axios(api, { method: "POST" })])
      // .then((resArr) => console.log(resArr));
      .then(axios.spread((resOne) => console.log(resOne)));
  </script>
</html>
```

简单实现 axios ：

```
<!DOCTYPE html>
<html lang="en">
  <script>
    // 序列化 params 对象
    function serializeParams(params) {
      const str = Object.entries(params)
        .filter(([_, value]) => value !== undefined && value !== null)
        .map(
          ([key, value]) =>
            encodeURIComponent(key) + "=" + encodeURIComponent(value)
        )
        .join("&");
      return str;
    }

    // 解析响应头
    function parseHeaders(rawHeaders) {
      const headers = {};

      rawHeaders
        .trim()
        .split(/[\r\n]+/)
        .forEach((line) => {
          const parts = line.split(": ");
          const key = parts.shift();
          const value = parts.join(": ");
          headers[key.toLowerCase()] = value;
        });
      return headers;
    }

    function myAxios(config) {
      const { promise, resolve, reject } = Promise.withResolvers(
        (resolve, reject) => {}
      );

      let { url } = config;
      const {
        baseURL = "",
        method = "GET",
        headers = {},
        params = {},
        data = null,
        timeout = 0,
        signal,
      } = config;

      // 拼接 baseURL
      url = baseURL + url;

      console.log(headers);

      // 拼接 params 参数到 URL
      const queryString = serializeParams(params);
      if (queryString) {
        const hasQuery = url.includes("?");
        url += hasQuery ? "&" + queryString : "?" + queryString;
      }

      const xhr = new XMLHttpRequest();
      xhr.open(method.toUpperCase(), url);

      // 设置超时时间
      if (timeout) xhr.timeout = timeout;

      // 默认请求头
      if (data) xhr.setRequestHeader("Content-Type", "application/json");
      // 设置请求头
      for (const key in headers) {
        xhr.setRequestHeader(key, headers[key]);
      }

      // 响应处理
      xhr.onreadystatechange = () => {
        if (xhr.readyState !== 4) return;
        if (xhr.status === 0) return;

        if (xhr.status < 200 || xhr.status >= 300) {
          reject(new Error(`Request failed with status ${xhr.status}`));
          return;
        }

        try {
          const contentType = xhr.getResponseHeader("Content-Type");

          const isJSON =
            contentType && contentType.includes("application/json");

          const responseData = isJSON
            ? JSON.parse(xhr.responseText)
            : xhr.responseText;

          resolve({
            data: responseData,
            status: xhr.status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders()),
            config,
            request: xhr,
          });
        } catch (err) {
          reject(err);
        }
      };

      // 错误处理
      xhr.onerror = () => reject(new Error("Network Error"));
      xhr.ontimeout = () => {
        const error = new Error("Request Timeout");
        error.code = "ECONNABORTED";
        reject(error);
      };

      // 取消支持
      if (signal) {
        // 调用 controller.abort() 触发
        signal.addEventListener("abort", () => {
          xhr.abort();
          const error = new Error("Request was aborted");
          error.code = "ERR_CANCELED";
          error.__CANCEL__ = true;
          reject(error);
        });
      }

      // 发送请求体
      if (data && typeof data === "object" && !(data instanceof FormData)) {
        xhr.send(JSON.stringify(data));
      } else {
        xhr.send(data);
      }

      return promise;
    }

    myAxios.__proto__.isCancel = function (err) {
      return err?.__CANCEL__;
    };
  </script>

  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script>
    const api = "http://localhost:4000/data";

    const controller = new AbortController();

    myAxios({
      // url: "http://localhost:4000/get",
      url: api,
      method: "POST",
      data: {
        a: 1,
        b: undefined,
      },
      timeout: 5000,
      signal: controller.signal,
    }).then(
      (res) => console.log(res.data),
      (err) => {
        if (myAxios.isCancel(err)) console.log("请求被取消");
        else if (err.code === "ECONNABORTED") console.log("请求超时");
        else console.log("请求失败");
      }
    );

    // controller.abort();
  </script>
</html>
```

二次封装 axios ：

```
//1.  /src/network/index.js  第一层封装
import axios from 'axios'
export function request1(config){
  //对该实例进行全局配置
  const instance1=axios.create({
    baseURL:'http://123.207.32.32:8000'
  })
  /*拦截器：
  分为请求拦截（拦截配置信息）和相应拦截（拦截请求结果），拦截成功后注意需要返回config和res，主要作用是对配置信息和请求结果进行一些处理，或其它特殊用途。
  */
  //拦截请求的配置信息
  instance1.interceptors.request.use(config => {
    //用处1 增删改查配置信息
    //用处2 请求状态时，给页面增加爱一些动画效果
    //用处3 请求需要token时(如登录)，提交登录信息
    return config
  },err => { console.log(err) })
  //拦截请求结果
  instance1.interceptors.response.use(res => {
    //用途1，根据状态码进行操作
    console.log(res.status)
    //用途2，对请求结果进行过滤，去掉浏览器给的无用信息
    return res.data
  },err => { console.log(err) })

  //instance是axios，会返回一个promise，通过return再将此promise返回到外部
  return instance1(config)
}

//2. /network/home.js  第二层封装
import instance from './index'

export function HomeRequestMultidata(){
  return instance({
    url: '/Home/multidata'
  })
}

export function HomeRequestGoods(type, page){
  return instance({
    url: '/Home/data',
    params: {
      type,
      page
    }
  })
}

//3. 用到的组件中
Import {HomeRequestMultidata} from '...'
HomeRequestMultidata().then().catch()
```

ts：

```
//1. /src/network/request.ts  第一层封装
import axios,{AxiosInstance,InternalAxiosRequestConfig,AxiosResponse} from 'axios'

let instance: AxiosInstance = axios.create({
  baseURL: 'http://152.136.185.210:7878/api/hy66',
  timeout: 1000 * 60
})
instance.interceptors.request.use((config: InternalAxiosRequestConfig) => {
  return config
})
instance.interceptors.response.use((res: AxiosResponse) => {
  return res
})
export default instance

//2. /src/network/index.ts  第二层封装
import {InternalAxiosRequestConfig,AxiosResponse} from 'axios'
import instance from './request'

export function HomeRequestMultidata(): Promise<AxiosResponse>{
  return instance({
    url: '/Home/multidata'
  })
}

export function HomeRequestGoods(type: string, page: number){
  return instance({
    url: '/Home/data',
    params: {
      type,
      page
    }
  })
}

//3. 用到的组件中
Import {HomeRequestMultidata} from '...'
HomeRequestMultidata().then().catch()
```

ts，请求拦截器中添加请求头需要注意：

可能会报错说headers可能为undefined，解决方法：

- config.headers = {...config.headers,xxx:'xxx'}

- config.headers!.xxx = 'xxx'

（4）mock

用于模拟后端接口：

```
npm install --save mockjs
npm install -D @types/mockjs
```

```
// mock.js

import Mock from "mockjs";
import xxx from "./xxx.json";

Mock.mock("/abc", { code: 200, data: xxx });
```

```
// /src/main.js
import "@/mock/mockServer";
```

## 2 应用

（2）流式传输

fetch 提供了流式传输的功能，若请求数据量很大，且后端接口支持流式传输，就可以用 fetch 流式读取，接收到多少数据就读取多少：

```
async function streamRequest(url) {
  const res = await fetch(url);

  // 流式读取
  const reader = res.body.getReader();
  const decoder = new TextDecoder();
  while(1) {
    /**
     * doen: 是否完成
     * value: 二进制数据
     */
    const [doen, value] = await reader.read();
    const text = decoder.decode(value);
    console.log(text);
    if(done) break;
  }
}
```

（3）流量控制

控制并发两，只允许同时发送 n 个请求，缓解后端服务器压力：

```
/**可控制并发量的 Promise
 * taskList: 任务数组，每个元素是返回 Promise 的 function
 * maxMaxConcurrent: 最大并发量
 * needRestart: reject 时需要重新运行的次数
 */
function myAllSettle(taskList, maxConcurrent = 1, needRestart = 0) {
  return new Promise((resolve) => {
    if (!Array.isArray(taskList) || taskList.length === 0) return resolve([]);

    maxCpncurrent = Number.parseInt(maxConcurrent);
    needRestart = Number.parseInt(needRestart);
    if (maxConcurrent <= 0 || Number.isNaN(maxConcurrent)) maxConcurrent = 1;
    if (needRestart < 0 || Number.isNaN(needRestart)) needRestart = 0;

    const result = [];
    let index = 0, isFinally = 0;

    const run = async (
      nowindex,
      isRestart = false,
      remainRestart = needRestart
    ) => {
      try {
        const nowindexRes = {
          status: "fullfilled",
          value: await taskList[nowindex](),
        };

        if (isRestart) result[nowindex].push(nowindexRes);
        else result[nowindex] = nowindexRes;
      } catch (err) {
        const nowindexErr = {
          status: "rejected",
          reson: err,
        };

        if (isRestart) result[nowindex].push(nowindexErr);
        else result[nowindex] = [nowindexErr];
      } finally {
        if (
          remainRestart > 0 &&
          result[nowindex]?.at?.(-1)?.status === "rejected"
        ) {
          run(nowindex, true, remainRestart - 1);
        } else {
          ++isFinally;

          if (isFinally >= taskList.length) resolve(result);
          else if (index < taskList.length) run(index++);
        }
      }
    };

    for (let i = 0; i < Math.min(maxConcurrent, taskList.length); i++)
      run(index++);
  });
}

// 测试 ——------------------------------------------------------------------------------
function delayTask(fn, ms) {
  return new Promise((resolve, reject) => {
    setTimeout(() => fn(resolve, reject), ms);
  });
}

const taskList = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map((item) => {
  return () => {
    return delayTask((resolve, reject) => {
      if (item % 3 === 0) reject(`err ${item}`);
      else resolve(item);
    }, Number.parseInt(Math.random() * 1000));
  };
});

myAllSettle(taskList, 3, 2).then((res) => {
  console.log(res);
});
```

# 三、cookie、安全 、同源策略

## 1 cookie

（1）基本

http 是无状态的协议，也就意味着后端服务器无法判断请求是由谁发起的，于是早期的 Web 应用就使用浏览器的 cookie 来保存登录状态。

可以在浏览器调试工具 \- application 中查看 cookie 。

cookie 的缺陷：

* 隐私泄露：对于用户来说，cookie 是非常容易泄露个人隐私的，因为 cookie 可以在不登录的情况下就能被请求携带。

* 较不安全：cookie 可以被跨站的请求携带，所以需要设置 samesite

cookie 的好处：

* 后台具有强控制性，可以随时把 cookie 设置为过期，而 jwt 不行

cookie 特性：

* 每条 cookie 的存储空间为 4KB ：
  
  * 本地打开 html 文件无法读写 cookie ，只有通过网络 url 访问的 html 才行
  
  * 前端可以 document\.cookie 读写 cookie ；后端可以在响应头中设置 cookie ，浏览器收到响应且允许后就会设置 cookie
  
  * 同一个浏览器中，cookie 在同提个站点域共享，不在一个站点域就是跨站，跨站没有跨域严格

* cookie 会再请求中携带：
  
  * 若是同一个站点域且不跨域的页面，发起的 ajax ，会自动携带
  
  * 若是跨域的页面，ajax 需要添加 credential 选项才会携带，同时后端在跨域的情况下还需要再设置允许 cookie 跨域；若是跨站的 ajax ，还需要把 samesite 设为 "none"
  
  * 具有请求属性的标签，如 img 、a 、iframe 、form 等，无论是否跨站，在早期的 Web 都会自动携带 cookie ，包括浏览器中其他站点域的 cookie ；但在 cookie 增加了 samesite 属性后，就由 samesite 决定，samesite 只能后端设置：
    
    * sameSite: "lax" ，默认值，跨站时，只允许 \<a\> 和 get 的 \<form\> 自动携带 cookie
    
    * sameSite\: "none" ，只有在 srcure\: true 才有效，否则视为 "lax"，无论是否跨站这些标签都会自动携带 cookie
    
    * sameSite: "strict" ，只有处于同一个站点域的页面，这些标签才会携带 cookie ，防止 CSRF 攻击
  
  * 除了 samesite 外，还有 2 个只有后端才能设置的 coolkie 属性，默认值为 false ：
    
    * HttpOnly ：不允许前端 JS 读写 cookie ，只允许在请求中携带，防止 XSS 攻击，不过调试工具 aplication 还能看到
    
    * srcure ：只允许在 https 协议中传输 cookie
- 前后端都能设置的 cookie 属性：
  
  * 作用域：
    
    * path ：默认值为根路径 "/" ，path 表示 cookie 在静态文件夹中的哪些路径可以使用
    
    * domain ：默认值（前端：当前域名；后端：请求来源的域名），表示 cookie 能在哪个站点域以及它的子域使用，若设置为其他站点域，cookie 就无法使用了，若设置为子域，则父域无法使用
  
  * 过期时间：
    
    * expires ：绝对过期时间，格式必须是 GMT 时间
    
    * max-age ：相对过期时间，优先级高于 expires ，以秒为单位
    
    * 若没有设置 expirs 和 max-age ，则 expires 默认值为 session，表示为一个会画 cookie ，关闭浏览器后清除（刷新、要转、关闭页面都不会清除）

（2）前端读写 cookie 

```
// 静态资源服务器，3000 、4000 都弄提个，用于测试

const express = require("express");
const path = require("path");

const app = express();
const PORT = 3000;

app.use(express.static(path.join(__dirname, "public")));

app.listen(PORT, () => {
  console.log(`Server is running at http://localhost:${PORT}`);
});
```

```
<!DOCTYPE html>
<html lang="en">
  <body>
    localhost:3000
  </body>

  <script>
    /**设置 cookie ---------------------------------------------------------------------
     * 不是普通的字符串赋值，浏览器内部会拦截处理
     * 一次只能设置一个 cookie
     * 由于 cookie 会在每个请求中携带，所以 cookie 最好只用于存储登录态，不存储大量数据，以免影响请求的速度
     */
    console.log("过期测试", document.cookie);

    document.cookie = "a=0;";
    document.cookie = "a=1;";
    document.cookie = `b=${encodeURIComponent(JSON.stringify({ b: 2 }))};`;

    // // 5s 后过期
    document.cookie = `c=3; expires=${new Date(
      Date.now() + 5000
    ).toUTCString()}`;

    // // 5s 后过期 ，优先级高于 expires ，若同时设置只有 max-age 有效
    document.cookie = "d=4; max-age=5;";

    console.log("seted", document.cookie, document.cookie.split(";"));

    /**删除 ---------------------------------------------------------------------------
     * 需要把过期时间修改为已经过去的时间
     * document.cookie = "" 是无效的
     */
    // Thu, 01 Jan 1970 00:00:00 GMT
    const expiredTime = new Date(0).toUTCString();

    document.cookie = `a=; expires=${expiredTime}`;
    document.cookie = "b=; max-age=-1;";

    console.log("deleted", document.cookie);

    // expires 、path 、domain 这里的默认值
    document.cookie = "e=5; expiress=session; path=/; domain=localhost";
  </script>

  <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"></script>
  <script>
    // 第三方库更方便读写 cookie ，有浏览器端的 js-cookie 和 node 的 cookie ，以 js-cookie 为例

    // 1 天后过期
    Cookies.set("name", "value", { expires: 1 });
    console.log(Cookies.get("name"));
    Cookies.remove("name");
  </script>
</html>
```

```
<!DOCTYPE html>
<html lang="en">
  <body>
    localhost:4000
  </body>

  <script>
    // 同提个站点域共享 cookie
    console.log(document.cookie);
  </script>
</html>
```

（3）请求携带 cookie 以及 cookie 跨域

```
// 后端， localhost:3333

const express = require("express");
const cors = require("cors");
const cookieParser = require("cookie-parser");

const app = express();
app.use(cookieParser());

// 跨域
app.use(
  cors({
    // cookie 跨域的 origin 不能设置为 "*"
    origin: "http://localhost:3000",
    credentials: true,
  })
);

app.get("/login", (req, res) => {
  // 响应头中设置 cookie
  res.cookie("token", "abc123", {
    // 只有后端才能设置 samesite 、HttpOnly 、srcure

    // 默认值都是 false
    httpOnly: false,
    secure: false,

    // 默认值 "lax" ，若 srcure 为 false 则 sameSite 设为 "none" 无效，视为 "lax"
    sameSite: "lax",
  });

  res.send("Cookie 已设置");
});

app.get("/data", (req, res) => {
  console.log(req.cookies);
  res.send("123");
});

const port = 3333;
app.listen(port, () => {
  console.log(`localhost:${port}`);
});
```

```
<!DOCTYPE html>
<html lang="en">
  <body>
    localhost:3000

    <!-- 处于同一个站点域，自动携带 cookie -->
    <img src="http://localhost:3333/data" />
  </body>

  <script>
    console.log(document.cookie);

    // // 请求后端设置一个 cookie
    fetch("http://localhost:3333/login", {
      method: "GET",

      // 跨域时若没有设置 credential ，即使后端响应头携带了 cookie ，前端也不会设置这个 cookie ；同源则不用
      credentials: "include",
    })
      .then((res) => res.text())
      .then((data) => {
        console.log(data, document.cookie);

        // 请求数据接口，携带 cookie 到后端
        fetch("http://localhost:3333/data", {
          method: "GET",

          // 跨域必须设置 credential ，才会携带 cookie ；同源则会自动携带
          credentials: "include",
        })
          .then((res) => res.text())
          .then((data) => console.log(data, document.cookie));
      });
  </script>
</html>
```

## 2 前端安全

（1）XSS 攻击

跨站脚本攻击：

* 模拟：

* 解决方法：
  
  * 前端避免使用 innerHTML 等注入 html ；后端防止 SQL 注入
  
  * 尽量不使用 JSONP
  
  * 若是 cookie 则 HttpOnly 设为 true
  
  * 前端使用 postMessage 时做好防范处理

（2）CSRF 攻击

跨站请求伪造，针对 session \+ cookie 的登录模式，原理是利用跨站的 img 、a 等元素请求也能携带 cookie 的特性

* 模拟：
  
  ```
  // 后端， localhost:3333
  
  const express = require("express");
  const cors = require("cors");
  const cookieParser = require("cookie-parser");
  
  const app = express();
  app.use(cookieParser());
  
  app.use(
    cors({
      origin: "http://localhost:3000",
      credentials: true,
    })
  );
  
  app.get("/login", (req, res) => {
    res.cookie("token", "abc123");
    res.send("Cookie 已设置");
  });
  
  app.get("/data", (req, res) => {
    console.log(req.cookies);
    res.send("123");
  });
  
  const port = 3333;
  app.listen(port, () => {
    console.log(`localhost:${port}`);
  });
  ```
  
  ```
  <!DOCTYPE html>
  <html lang="en">
    <body>
      localhost:3000
    </body>
  
    <script>
      // 登录
      fetch("http://localhost:3333/login", {
        method: "GET",
        credentials: "include",
      })
        .then((res) => res.text())
        .then((data) => console.log("登录成功"));
    </script>
  </html>
  ```
  
  ```
  /**模拟 CSRF
   * 访问 http://example.com ，调试工具中运行下面的 JS ，点击生成的 <a>（<form> 会自动 submit），就攻击成功了，已经拿到跨站的 cookie 并伪造了一个有权限的请求
   * 由于后端是 http 协议，所以只能在 http 的页面中攻击
   * http 协议，secure 为 false ，samesite 为 "lax" ，所以只能用 <a> 和 get 的 <form> 模拟
   */
  
  // a 标签
  (function () {
    const a = document.createElement("a");
    a.href = "http://localhost:3333/data";
    a.textContent = "CSRF";
    a.style.fontSize = "100px";
    document.body.appendChild(a);
  })();
  
  // 设置 get 请求的 form
  (function () {
    const form = document.createElement("form");
    form.method = "get";
    form.action = "http://localhost:3333/data";
    document.body.appendChild(form);
    form.submit();
  })();
  ```

* 解决方法：
  
  * 后端接口遵循 Restful 规范，需要增删改的接口使用 POST 、PUT 、DELETE 请求，把参数放到请求体；但防不了 form 的 POST 请求
  
  * cookie 的 samesite 设为 '"strict' 

## 3 同源策略、跨域

同源策略：

* 浏览器的安全策略，源由协议、域名、端口组成，三者搜相同就是同一个源，反之其中任何一个不同就是不同的源，形成跨域。

* 同源策略只有浏览器环境存在，服务器、桌面应用、小程序、app 等不存在

* ajax 、html 标签、iframe 、Web Storage 、Web Worker 等都有同源策略，ajax 的跨域最常见也是最严格的，storage 和 worker 限制也大，\<script\> 等标签限制较小

* 跨域的请求后端服务器也能收到，只是在浏览器处理响应时不允许页面得到响应

这里只解决 ajax 的跨域问题，解决方案需要根据生产环境：

* 若静态资源服务器、后端服务器是用 nginx 反向代理，形成同源的，就不需要处理跨域，但是在开发时，前端需要跨域，就用代理解决
  
  * vite 、cli 配置的本地代理仅在开发环境有效，若生产环境需要跨域一个非自己控制的后端服务器，则需要 node 真正实现一个代理服务器进行转发

* 若静态资源服务器、后端服务器是在不同的源，就使用 cors 或 JSONP

（1）CORS

CORS （跨域资源共享）是最正统的跨域解决方案，需要后端服务器配合。原理是后端设置 CORS 的响应头，浏览器收到后看到就会允许页面得到响应。

ajax 请求分为两类：

- 简单请求（Symple Request），只需要后端设置响应头即可：
  
  ```
  // 指定源，推荐
  // 注意：设置这个响应头，域名和 IP 在浏览器处理响应时是分开判断的，如这里 127.0.0.1:5173 就不能跨域
  Access-Control-Allow-Origin: http://localhost:5173
  
  // 允许所有源，不推荐
  Access-Control-Allow-Origin: *
  ```
  
  简单请求需要满足以下全部条件：

- GET、POST、HEAD 之一

- 请求头字段必须符合安全规范（默认的请求头字段都符合）

- Content\-Type 必须是以下之一：
  
  - text\plain （默认值，但一些第三方库如 axios 不同，axios 在传入 data 时，Content\-Type 就变成 application/json ）
  
  - multipart/form\-data
  
  - application/x\-www\-form-urlencoded

- 预检请求（PreFlight Request）：除了简单请求外都是此类，在正式发出请求前，浏览器会向服务器先自动发送一个 OPTIONS 请求，无请求体、带有三个请求头字段：
  
  ```
  Origin: 源
  Access-Control-Request-Method: 第二次请求的 method
  Access-Control-Request-Headers: 改动了哪些头字段导致变成 preflight
  ```
  
  若后端允许，会设置响应头，并响应 OPTIONS 请求：
  
  ```
  Access-Control-Allow-Origin: 源
  Access-Control-Allow-Method: 允许的 method
  Access-Control-Allow-Headers: 允许头字段的改动，需要包含之前所有改动的字段
  Access-Control-Max-Age: 缓存时间(s)。此时间内不再 preflight 此请求
  ```
  
  随后浏览器会真正发送原先请求，后端只需要设置响应头：
  
  ```
  Access-Control-Allow-Origin: 源
  ```

不管是 simple 还是 preflight ，需要注意两个细节：

- 若请求带有 cookie ，前后端还需要额外设置：
  
  ```
  // 前端
  
  // xhr
  const xhr = new XmlHttpRequest();
  xhr.withCredentiols = true;
  
  // fetch
  fetch("url",{
    credentiols: "include"
  });
  
  // axios
  axios.get("url", {
    withCredentials: true,
  });
  ```
  
  ```
  // 后端，设置响应头
  Access-Control-Allow-Origin: 不能设置为 *
  Access-Control-Allow-Credentiol: true
  ```

- 跨域时，浏览器 network 可以看到响应头，但是前端代码拿不到，此时需要后端设置响应头才行：
  
  ```
  Access-Control-Expose-Headers: 允许哪些头字段可以被前端获取
  ```

以 express 为例：

```
app.use((req, res, next) => {
  // 允许跨域的源
  res.setHeader("Access-Control-Allow-Origin", "http://localhost:3000");

  // cookie 跨域
  res.setHeader("Access-Control-Allow-Credentials", "true");

  // 允许跨域的自定义请求头
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");

  // 允许前端获取的响应头
  res.setHeader("Access-Control-Expose-Headers", "aaa,bbb");

  // 默认情况只允许简单请求，即 GET 、POST 、HEAD
  res.setHeader(
    "Access-Control-Allow-Methods",
    "GET, POST, PUT, DELETE, OPTIONS"
    // "*"
  );

  // 处理预检请求
  if (req.method === "OPTIONS") return res.sendStatus(204);
  else next();
});
```

（2）JSONP

JSONP 是最古老的跨域方法，适合老版本浏览器，需要后端服务器配合。

* 原理是利用 \<script\> 受到同源策略限制较小的特性，代替 ajax 请求，前端定义一个 function 等待调用，用 \<script\> 发送 get 请求并携带函数名，后端获得函数名后返回一个 js ，js 里面调用函数并传入后端数据：

* 缺点就是有受到 XSS 攻击的风险，且由于没有请求体，就只能发送 GET 请求。

```
const express = require("express");
const cookieParser = require("cookie-parser");

const app = express();
app.use(cookieParser());

app.get("/jsonp", (req, res) => {
  console.log(req.cookies);

  // 函数名和后端数据
  const { jsonp } = req.query;
  const data = JSON.stringify({ a: 1 });
  const js = `${jsonp}(${data})`;

  res.setHeader("Content-Type", "application/javascript");
  res.send(js);
});

app.listen(4000, () => {
  console.log("Server running on http://localhost:3000");
});
```

```
<!DOCTYPE html>
<html lang="en">
  <body></body>

  <script>
    // 清空已调用的 jsonp 函数
    function clearJsonp(cbName, script) {
      delete window[cbName];
      document.body.removeChild(script);
    }

    // jsonp 不是 ajax 了
    function jsonp(url, resFn, errFn) {
      const script = document.createElement("script");

      // 防止冲突，每个函数名都不一样
      const cbName = `jsonp_cb_${Date.now()}`;
      url += (url.includes("?") ? "&" : "?") + `jsonp=${cbName}`;

      // 请求成功，自动执行 <script> 的得到的 js ，里面就是这个函数
      window[cbName] = function (data) {
        resFn(data);
        clearJsonp(cbName, script);
      };

      // 请求失败
      script.src = url;
      script.onerror = function (err) {
        errFn(err);
        clearJsonp(cbName, script);
      };

      document.body.appendChild(script);
    }

    // 使用
    jsonp(
      "http://localhost:4000/jsonp",

      function (data) {
        console.log("收到数据：", data);
      },

      function (err) {
        console.log("请求失败", err);
      }
    );
  </script>
</html>
```

（3）本地代理服务器

同源策略只存在于浏览器中，所以只需要在本地用一个代理服务器转发请求即可，只需要前端即可实现。

注意：仅在开发环境有效。

vite\.config\.ts ：

```
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

export default defineConfig({
  plugins: [vue()],

  server: {
    proxy: {
      // 请求时 url 可以简写为 "/api/data"
      "/api": {
        // 请求本地服务器 "http://localhost:5173/api/data" ，代理会转发到 "http://localhost:4000/api/data"
        target: "http://localhost:4000",

        // 默认 false ，此时请求头 "Host" 为 "localhost:5173" ，true 则修改为 "localhost:4000"（但请求头 "Origin" 不会被修改）
        changeOrigin: true,

        // 去掉 url path 头部的单个 "/api" ，使得最终访问的是 "http://localhost:4000/data"
        rewrite: (path) => path.replace(/^\/api/, ""),
      },
    },
  },
});
```

```
// 最终访问 "http://localhost:4000/data"
fetch("/api/data");
```

vue\.config\.js ：

```
// vue.config.js （cli < @3 ，webpack.config.js）

const { defineConfig } = require("@vue/cli-service");

module.exports = defineConfig({
  transpileDependencies: true,

  devServer: {
    proxy: {
      "/api": {
        target: "http://localhost:4000",
        changeOrigin: true,
        pathRewrite: {
          "^/api": "",
        },
      },
    },
  },
});
```



create\-react\-app 中必须写一个单独的文件：

```
npm install -D  http-proxy-middleware@2
```

```
// /src/setupProxy.js

const { createProxyMiddleware } = require("http-proxy-middleware");

module.exports = function (app) {
  app.use(
    createProxyMiddleware("/api", {
      target: "http://localhost:4000",
      changeOrigin: true,
      pathRewrite: {
        "^/api": "",
      },
    })
  );
};
```

## 4 代理服务器

（1）跨域

请求非自己控制的服务器时，跨域需要自己搭建一个代理服务器：

```
pnpm add express nodemon cors http-proxy-middleware
```

```
const express = require("express");
const { createProxyMiddleware } = require("http-proxy-middleware");
const cors = require("cors");

const app = express();
const PORT = 3333;

// 前端：localhost:3000
app.use(
  cors({
    origin: "http://localhost:3000",
  })
);

// 后端：localhost:4000
app.use(
  "/api",

  createProxyMiddleware({
    target: "http://localhost:4000",
    changeOrigin: true,
    pathRewrite: { "^/api": "" },
  })
);

app.listen(PORT, () => {
  console.log(`Proxy server is running on http://localhost:${PORT}`);
});
```

（2）重定向

若一个 url 需要对应多个页面（如 PC 端、移动端），这些页面分别在不同的静态资源服务器，可以先请求代理服务器，再根据条件重定向到对应的静态资源服务器：

```
const express = require("express");

const app = express();
const PORT = 3333;

/**
 * 输入 url ：localhost:3333 ，根据请求头 "user-agent" 进行重定向
 * PC 端：localhost:7000/index.html
 * 移动端：localhost:8000/index.html
 */
app.get("/", (req, res) => {
  // "user-agent" 保存了用户的设备信息
  const ua = req.headers["user-agent"] || "";

  const isMobile = /mobile|android|iphone|ipad/i.test(ua);

  const targetUrl = isMobile
    ? "http://localhost:8000"
    : "http://localhost:7000";

  // 302 临时重定向
  res.redirect(302, targetUrl);
});

app.listen(PORT, () => {
  console.log(`代理服务器运行在 http://localhost:${PORT}`);
});
```

也可以用响应式布局实现一个 url 对应多个页面的需求，但缺点是开发维护成本高，打包体积也会变大。

123
