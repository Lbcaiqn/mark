# 一、项目开发规范

## 1 开发工具

编辑器：vscode，微信开发者工具，HBuildX，代码缩进2个空格

vscode快捷键

```
！+  tab：生成基本骨架
ctrl + + ctrl + -：放大缩小字体
标签名 + tab或者回车：生成双标签
标签名*n + tab或者回车：生成n个相同双标签
鼠标定到某行可以只复制一行
鼠标定到某行，ctrl  +  /：注释和取消注释当前行
标签>标签 + tab：生成包含     标签+标签 + tab：生成并列
标签名.类名 + tab：生成该类名的标签，不加标签默认为div
标签名#id名 + tab：生成该id名的标签，不加标签默认为div
.类名$*n：生成连续类名      标签名{文本}：生成包含文本的标签，文本为$则生成连续数字
CSS可以缩写+tab生成                shift+alt+F：格式化代码
```

其他：浏览器，snipaster，phontoshop，cmder，marktext

操作系统：

目前大量的库，js语法等，在win7支持的最高node版本13.14.0已经不支持，需要更高版本的系统。

vue谷歌浏览器调试工具：vue.js devtools，vue2和vue3使用的版本不一样，为了避免冲突，使用时只保留一个，禁用另一个。

vscode插件：

（1）代码格式化：prettier

能够格式化html，css，js，ts，vue等代码

（2）vue语法、代码提示插件

vetur：vue2使用

volar：vue3使用

为了避免冲突，使用时只保留一个，禁用另一个。

## 2 HTML/CSS/JS规范：

代码缩进：2

Web标准：结构（HTML），表现（CSS），行为（Javascript）

- HTML尽量用语义化标签替代div，属性使用双引号，若属性很多可以换行
  
  ```
  <div 
    aaa="xx" 
    bbb="xxx"
  > 
  </div>
  ```

- css属性按规范的顺序书写，css3中属性值小数0.5可写.5，css属性顺序：display=定位-盒子-文本-文
  
  字-背景-C3

- js字符串使用双引号，每个语句结尾加分号（加了分号避免不必要的错误，尤其是ts）

## 3 各种命名规范

HTML本身没有驼峰标识（标签名、属性无法识别大写，但是属性的值可以），脚手架才会有

css，js，ts都有驼峰标识

* 无驼峰标识的情况下，HTML属性，组件名组件标签，以xxx-yyy命名，有驼峰标识了也尽量使用 xxx-yyy的形式，css类名id名也常用xxx-yyy命名

* js，ts驼峰命名法：变量/函数/对象小驼峰，构造函数/类/接口/组件/大驼峰

* js、ts变量只能用数字、字母、下划线、$命名，且不能数字开头，也不能用-命名，组件标签以xxx-yyy命名时，注意js不能用-命名。

* 子组件以views组件名开头（如HomeMain.vue），hook函数useXXX

## 4 运算符、符号规范

运算符左右两边空一格：

```
let a = 5 + 7;
```

逗号，冒号后空一格：

```
let a = [123, 456];
let b = {a: 123};
```

## 5 Vue最佳实践

- 风格指南：https://vuejs.org/style-guide/

- 导航栏-文档-深度指南-最佳实践

## 6 Vue目录结构规范：

```
src
  assets
    img
    css
  common        本项目公用的js文件
    components  公共组件
    common    可以在别的项目用的组件
    content   只能在本项目用的组件
  views       各个页面独立的组件
  router
  store
  network
  App.vue
  main.js
...
package.json
vue.config.js
tsconfig.json
```

## 7 开发前准备

（1）拿到.editorconfig文件，配置代码风格
（2）创建vue.config.js，配置路径别名，当成绝对路径用

```
module.export = {
  configurewebpack:{
    resolve:{
      extension:[], //配置后倒入路径可不加后缀，默认已配载就hi，可不写。
      alias:{
        '@':'src',  //默认已配置，可不写
        'assets':'@/assets',
        'components':'@/components',
        'common':'@/common',
        'network':'@/network',
        'views':'@/views'
      }
    }
  }
}
```

（3）初始化CSS

Github下载normalize.css，统一不同浏览器的html标签模样
②创建base.css，@import “assets/css/normalize”; 并初始化css
然后在App.vue中的script，@import “assets/css/base.css”;

# 二、常用布局和业务逻辑

## 1 整体布局

（1）PC端：

- 普通页面，header+居中版心+footer，header和footer与浏览器同宽

- 后台管理系统，居中版心（左（aside）+右（header+content））

（2）移动端：

手机和电脑连一个wifi，手机进入 电脑ip:端口

- 限制屏幕缩放的最大与最小宽度

- 顶部导航+滚动（单滚动或左分类+有内容）+tabBar，开发时页面分类tabBar页面和非tabBar页面，导航栏和tabBar可以根据路由动态显示隐藏荐vw

（3）根据页面v-if，v-show动态显示对应内容

如登录页和404页隐藏全局的一些模块

如移动端的导航栏和tabbar可以根据判断路由来动态显示

- 必须做适配，推

## 2 常用模块

（1）轮播图：

（2）移动端搜索框：

点击假的搜索盒子进入搜索页面，进入时候自动获得焦点

## 3 常用布局

（1）圣杯布局

（2）分栏布局

（3）水平滑动切换/点击切换布局

切换回来时，高度可以保持也可以到最开始

（4）瀑布布局

## 4 常用业务逻辑

（1）上拉加载更多

正在加载时，应该用一个if阀口来判断是否正在加载中，只有在非加载状态时才发送请求

不能用防抖节流

上拉加载最后一页的判断，服务器返回一般两种：
①状态码，根据状态码判断就行
②返回总数，此时可以用 页码*每页数量>=总数来判断，也可以当前总数>=总数来判断

（2）注册/登录/权限管理

详见node笔记

（3）支付

（4）后台管理

管理员拥有全部权限，用户不是注册来的而是管理员添加的，用户可修改密码。
管理员主要有对用户、角色、权限、菜单的管理，用户具备角色的权限+管理员单独给的权限=该用户权限列表。

一般初始不需要默认路由，初始只需要配置登录页面，404页面等基本页面的路由，其他路由和默认路由都根据权限动态添加。

# 三、异常处理

为了项目稳定，在出现错误时不停止服务，在可能出错的代码做异常处理。

（1）错误类型

主要分为接口异常和代码逻辑异常

接口异常是在请求后端接口时出现的异常，可能是请求失败、也可能是请求得到状态码表示错误。一般的处理办法是在相应拦截器中统一处理请求失败和根据状态码做相应的处理。

代码逻辑错误是前端逻辑上的错误发生的异常，js代码通过try...catch...处理，而Vue最常见的方法是使用全局错误处理函数app.config.errorHandler收集错误。

（2）错误上报给后端

收集到错误后需要处理异常，分析错误信息。

如果是接口错误，需要上报接口信息、参数、状态码等。

如果是前端代码异常，收集错误信息即可。

还可以收集项目名称、版本、环境、用户信息、所在页面等，这些在vuex获取即可。

收集完错误就上报给后端。

# 四、常用第三方库

## 动画库

animate.css

动画库

```
npm install --save animate.css
```

使用：

只需要修改enter-active和leave-active类名即可，如动画fadeIn，fadeOut

```
<template>
  <div>
    <transition 
      enter-active-class="animate__animated animate__fadeIn"
      leave-active-class="animate__animated animate__fadeOut"
    >
    </transition>
  </div>    
</template>
<script>
import 'animate.css'
...
</script>
```

若是animate3，则不需要加animate__animated
animate4以上版本需要加上animate__animated
其他动画类名详见官网

动画库gsap

Vue官方推荐的动画库

npm install --save gsap

import gsap from 'gsap'

```
//@before-enter="enterFrom"
enterFrom(el){
 gsap.set(el,{
 width: 0,
 height: 0
 })
},
//@enter="enterActive"
enterActive(el,done){
 gsap.to(el,{
 width: 100,
 height: 100,
 onComplete: done
 })
}
```

## 数据可视化

echarts

安装：

```
npm install --save echarts
```

引入

```
//import echarts from 'echarts'       //4及以下版本
import * as echarts from 'echarts'  //5及以上版本
```

基本使用：

首先需要准备可视化区域的盒子，必须具有宽和高，盒子里面不需要有任何内容。

由于echarts需要基于这个盒子进行渲染，所以需要在DOM加载完之后，也就是mounted中写echarts代码。

## 组件库

Vue的template和uniapp的block，由于只作包裹作用而不渲染，无论是否使用组件库，在某些情况（如需要一个不渲染的盒子来用v-if，v-for等）都可以使用。

elementui和elementplus

ant-design

vant

组件库修改样式：

F12找到组件库DOM对应的类名

- App.vue全局修改，缺点是会影响所有组件

- 样式穿透，详见Vue，Vue2使用 /deep/ 选择器，Vue3推荐使用 :deep(选择器)

# 五、前端性能优化

（1）概念

前端性能指的就是各个方面的快不快、流不流畅。按照官方的说法，性能就是网站或应用的客观度量和可感知的用用户体验。

客观度量：加载快不快，DOM元素是否可用（比如表单有时候因为加载慢导致不可用），平滑交互（动画、滚动等留不流畅）。

可感知的用户体验：在性能已经做到极致了，无法继续优化的时候，需要提供感知表现给用户，如loading，进度条等。

（2）知识体系结构

前端性能优化总体需要了解四个部分，性能指标、性能检测工具、前端生命周期和具体的优化方案。

熟悉各种性能指标后，才能看懂性能检测工具的报告、然后法根据报告分析前端生命周期的各个部分，使用具体的优化方案。

（3）迭代优化

性能优化不是一锤子买卖，而是持续性的过程，因为项目是会不断更新的，更新可能会使性能有不同程度的变化。

迭代优化可以做一个性能监测来持续监测性能。

# 1 性能指标

性能指标可以清晰地评估性能多快算快，多慢算慢。性能指标不是单一的，而是有很多的指标。Google总结开发者需要重点关注的几个指标：

## 1.1 RAIL性能模型

R（Response响应）：网站应当尽可能块地响应用户，通常要在100ms以内。响应指的是各种交互的回馈，在需要较长时间才能响应时需要提供给用户感知体验（进度条，loading等）。

A（Animation动画）：动画要求在每秒60帧以上（16ms以内）

I（Idle空闲）：js是单线程的，如果某个js执行片段执行过久（如百万次的for循环），就会占用js主线程导致下面的代码很久后才会执行。所以要求每个任务需要在50ms内完成，超过50ms的就是长任务，需要把长任务划分到50ms以内的片段中，

L（Load加载）：就可能在1s内完成网站的加载并且用户能搞开始交互，若网络条件和计算机硬件比较差，也需要在5s内。

## 1.2 基于用户体验的性能指标

（1）FCP（First Contentful Paint 首次内容绘制）

指的是从空白到浏览器首次绘制DOM内容的时间（也叫白屏时间），内容包括文本、图片、非白色的canvas/svg等这些有意义的内容。

指标：

| 2s以内  | 较好        |
| ----- | --------- |
| 2s-4s | 中等，要开始优化了 |
| 超过4s  | 差         |

（2）LCP（Largest Contentful Paint 最大内容绘制）

指的是当前屏幕中，最大的内容加载的时间，最大内容通常情况下图片居多。

最大内容会随着屏幕滚动而变化，由于屏幕的滚动不断出现新内容，所以最大内容也不一定是最后加载完的。

指标：

| 2.5s以内  | 较好        |
| ------- | --------- |
| 2.5s-4s | 中等，要开始优化了 |
| 超过4s    | 差         |

（3）FID（First Input Delay 首次输入延迟）

有时候DOM已经渲染出来了，但是用户并不能马上去交互，需要等一段时间，这就是首次输入延迟。造成的原因是浏览器的主线程忙于做其他事情（如百万次for循环），不能及时响应用户。

主要是表单受首次输入延迟影响。

指标：

| 100ms以内     | 较好        |
| ----------- | --------- |
| 100ms-300ms | 中等，要开始优化了 |
| 超过300ms     | 差         |

（4）TTI（Time to Interactive 网页第一次完全达到可交互状态的时间点）

从空白到第一次能流畅完全交互的时间。具体衡量的标准是最后一个长任务完成且随后的5s内网络和主线程是空闲的（超过50ms的就是长任务）。

指标：

| 3.8s以内    | 较好        |
| --------- | --------- |
| 3.8s-7.3s | 中等，要开始优化了 |
| 超过7.3s    | 差         |

（5）TBT（Total Block Time 总阻塞时间）

度量FCP到TTI的总时间，即每个长任务造成的阻塞时间（长任务完成时间-50ms）之和。

指标：

| 300ms以内     | 较好        |
| ----------- | --------- |
| 300ms-600ms | 中等，要开始优化了 |
| 超过600ms     | 差         |

（6）CLS（Cumulative Layout Shift 累计布局偏移）

测量珍整个生命周期中发生的每个意外的布局偏移位的所有单独布局移位分数的总和，也就是页面视觉稳定性提升的指标。

比如，页面有两个盒子A，B，B在A上面。A渲染完毕并可交互，B未渲染，当B渲染完时，会把A定到下面去，这就是布局偏移，也叫布局抖动。

指标衡量抖动时间总和

指标：

| 100ms以内     | 较好        |
| ----------- | --------- |
| 100ms-200ms | 中等，要开始优化了 |
| 超过200ms     | 差         |

（7）Speed Index

## 1.3 Web Vitals和Core Web Vitals

Google在2020年推出的为了降低学习成本，为网站提供了统一的性能衡量标准Core Web Vitas。就是对基于用户体验的呢几个性能指标的简化，简化成了三个指标：LCP、FID和CLS。

## 2 性能检测工具

各个性能指标都是三个级别，较好（绿色），中等（橙色），差（红色）。

## 3 前端生命周期

需要具备操作系统和计算机网络的相关知识。

### 3.1 浏览器

早期的浏览器是单进程+多进程，网络、渲染等都是一个线程。由于进程中的某个线程出现错误会导致整个进程当机，所以早期的浏览器非常容易崩，如一个页面崩溃整个浏览器都会崩溃。

2008年推出的chrome及以后的浏览器是多进程+多线程，有一个主进程负责浏览器菜单栏，前进后退，管理子进程等，网络、渲染等都变成了一个个子进程，每个tab标签都会开启一个独立的渲染进程，进程间通过IPC通信。chrome中，shift+esc 可以打开浏览器的任务管理器，查看各个进程。

### 3.2 前端生命周期

就是从输入url到页面展示的整个过程：

（1）输入url

url：统一资源定位符，用于定位互联网上的资源，又称网址。

输入时，会根据历史记录和书签来只能提示。

输入完成按下回车后，首先检查是否是合法的url：

- 若合法，判断url是否完整，若不完整会自动补全前缀/后缀

- 若不合法，将输入内容作为搜索条件适宜用户默认的搜索引擎进行搜索

（2）开启网络请求进程，DNS解析

上一步若url合法，则会开启网络请求进程。

浏览器无法通过url直接找到ip地址，所以需要进行DNS解析。

DNS解析过程：

1. 操作系统检查缓存和本地的hosts文件，看该url是否有记录ip地址，有的话就完成解析；否则就继续下一步。

2. 使用TCP/IP参数中设置的DNS服务器进行查询，如果查找的域名包含在本地配置区域资源中，则返回解析结果完成解析；否则继续下一步。

3. 检查本地DNS服务器是否缓存该url记录，有就完成解析；否则继续下一步。

4. 本地DNS服务器发送查询报文到根DNS服务器，根DNS服务器收到后，返回顶级根DNS服务器地址，随后本地DNS服务器发送查询报文到顶级根DNS服务器，顶级根DNS服务器返回权威DNS服务器的地址，随后本地DNS服务器再发送请求报文到权威DNS服务器，权威DNS服务器收到后就会返回最终的ip地址，完成解析。

（3）浏览器开启网络请求线程，与服务器建立TCP连接

根据ip地址，浏览器会用一个随机的端口和服务器的80端口发起TCP连接请求。请求到达服务器后，通过三次握手建立TCP连接。

（4）发送http请求或https请求

发送一个初始的get请求，通常是请求html文件。请求进入无武器之前一般会进入反向代理服务器（反向代理服务器的功能主要是负载均衡、安全防火墙、数据压缩等），再转发到对应的应用服务器。

如果使用的是https请求则会在TCP和http之间多添加一层协议作为加密以及认证的服务。https使用SSL和TLS协议保证信息的安全。

SSL协议：认证客户端和服务器，确保数据发送到正确的客户端和服务器，加密数据并维护数据的完整性。

TSL协议：用于在两个通信应用程序之间，提供保密性和数据完整性。TSL由TSL记录协议和TSL握手协议组成。

（5）服务器响应请求

服务器返回http响应报文，内容包含响应头和html正文。

（6）浏览器解析、渲染页面

不同的浏览器引擎渲染过程是不同的，以谷歌浏览器为例：

1. 处理HTML标记构建DOM树，处理CSS标记构建CSS OM树

2. 将DOM树和CSS OM树合并为一颗渲染树（Render Tree），渲染树不会包含隐藏（如display: none）的元素。因此渲染树和DOM树的节点数可能不一样。

3. 根据渲染树来布局，以计算每个节点的几何信息，最终将各个节点渲染到页面上，此阶段可能会发生回流或重绘

（7）请求结束，断开TCP连接

现在的浏览器为了优化请求耗时，默认都会开启持久链接，只有在页面关闭时才会四次挥手断开TCP连接。

## 4 具体的优化方案

### 4.1 请求与响应优化

（1）DNS优化

一个项目为了提高请求的并发量，通常会有多个域名（一般2-4个）。

DNS的优化主要有几个方面：

* dns-prefetch（dns预取），利用空白时间来预解析DNS
  
  ```
  <!--
  设现在网站有亮哥哥域名，a.com和b.com
  html是从上到下解析，解析到<body>时才会开始NDS解析去请求资源，那<body>之前花费时间
  都是空白时间，可以利用这段空白时间先进行DNS的预解析
  dns-prefetch是异步的，不用担心阻塞
  -->
  <head>
    <link rel="dns-prefetch" href="//a.com" />
    <link rel="dns-prefetch" href="//b.com" />
  </head>
  <body>
  </body>
  ```

* 使用CDN加速域名，自己搭建DNS服务，尽可能使用A或AAAA标记代替CNAME，增加DNS的缓存时间以此减少DNS查找次数。这几个都是在后端优化的。

在测试DNS优化的时候，需要清除DNS缓存来测试优化效果。

（2）http长连接和管道机制

目前，请求默认都是长连接并有管道机制，不需要代码处理，此处制作了解即可。

早期的http都是短连接，一次请求一次相应，所以每次请求都要反复建立断开连接，非常消耗性能。在1997年http1.1发布之后加入了长连接，只需要建立一次连接在里面进行多次的请求响应，不需要重复建立断开连接，提升了数据传输的效率。

此外，http1.1还退出了管道机制，在一个连接中可以并发发送多个请求，但是响应不是并发的。http2后响应也是并发的。

长连接有两个缺陷：

* 由于http2之前长连接的响应不是并非噶的，虽然请求并发，但是服务器也只能处理完一个响应后再处理下一个，因此响应会出现对头堵塞。解决方案是尽可能减少请求，或多开TCP连接（使用一个项目使用多个域名），或使用http2

* 请求并发的数量也是有限制的，解决方案是多开TCP连接。

（3）尽可能减少非必要的请求

除了解决对头堵塞外，还能较少服务器的压力。

* 项目打包后，会自动合并文件，减少请求次数。这个了解即可。

* 业务逻辑中使用防抖和节流，详见JavaScript笔记。

（4）http缓存

### 4.2 渲染优化

end

减少DOM操作

预加载

精灵图：整合了小图标，较少服务器请求次数
代码压缩（打包）：将代码丑化，去除空格和换行

1 按需引入

在使用任何东西时，若果能够按需引入就一定要按需引入，会提升很多性能，如Vue3的CompositionsAPI，组件库/字体图标/echarts等等的按需引入。

Vue3和一些第三方库都有自动按需引入的插件，自动按需引入就是不需要自己手动import {} 来引入，当代码写到的时候就会自动引入。

2 第三方库的开发时和运行时

npm装包时，默认是安装运行时依赖，只有加上参数-dev时才会安装开发时依赖。

在装包的时候需要考虑该包是否需要在项目运行时使用，弱不需要就安装开发时依赖，这也是提升性能的一个点。

3 SEO优化

TDK：都放在head标签中

```
<title>网站名(产品名)-介绍(不要超过30个汉字)</title>
<meta name=”description” content=”网站详细说明，服务，特色，电话等”>
<meta name=”keywords” content=”英文逗号隔开的6-8个关键词，方便搜索引擎搜索”>
```

2 懒加载

图片懒加载（必用）

```
# 在图片需要在屏幕上显示时，才加载图片，优化性能。
npm install --save vue-lazyload 

//main.js
impoet VueLavyLoad from 'vue-lazyload'
Vue.use(VueLazyLoad,{
  //此对象可写可不写，用来设置加载时显示的图片，加载失败时的图片等
})
```

路由懒加载（必用）

第三方库或组件懒加载（可选）

3 精灵图，字体图标

4 防抖与节流

5 logo

```
logo优化规范：h1提高重要性，a返回首页
<div class=”logo”>
    <h1><a href=”index.html” title=”网站名称” >网站title</a></h1>
</div>
a的背景图片设置为logo，a里面的文字是为了被搜索引擎收录，但是为了美观需要隐藏：
font-size: 0; 或 text-indent: -99999px;  overflow: hidden;
```

6 favicon图标

```
favicon图标：
一般作为缩略的网站标志，显示在浏览器的地址栏或标签上。
将png的图片转换成.ico格式的图片并放到项目根目录中 https://www.bitbug.net/
引入：必须在放在head标签
<link rel=”shortcar icon” href=”xx.ico” type=”image/x-icon”>
```

# 六、兼容性与跨平台

# 七、项目部署到Linux服务器

node开发的后端启动后就行

vue项目需要先打包，打包得到的所有文件放到了另一个express项目的public文件夹中，并修改访问端口为80，然后npm start

## 1 环境搭建

购买云服务器，修改密码，开放端口，连接ssh

windows上的cmd：

```
ssh root@服务器ip
```

windows的cmd非常不好用，推荐自行下载cmder

连接到服务器后，配置Linux服务器的系统环境

```
//1.更新yum，并且安装常用软件
yum update
yum install -y gcc gcc-c++ cmake ncurses ncurses-devel bison

//2.node，通过编译源代码安装，
cd /usr/src 这里专门存放源代码
wget https://nodejs.org/dist/v9.3.0/node-v9.3.0.tar.gz
tar -xf node-v9.3.0.tar.gz
cd node-v9.3.0
./configure
make && make install
//编译完成，程序放在 /usr/local

//3.更新node到最新版本，n也可以款速切换node版本
npm install -g n
//不要用n latest安装最新版本，最新版本node17不稳定
n 14 安装node14
n的使用：https://segmentfault.com/a/1190000015302680

//4.python装包：
pip3 install --upgrade pip
pip3 install numpy==1.19.3
pip3 install pandas==0.23.4
pip3 install matplotlib

//5.创建公钥，并安装git：
cd ~/.ssh
ssh-keygen -t rsa -C "邮箱" 回车执行，再回车三次
cat ~/.ssh/id_rsa.pub 复制输出得到内容到github
//安装git：
yum install git
git config --global user.name "xxx"
git config --global user.email "xxx"
```

## 2 后台运行服务，开机自启

为了同时启动vue和node，且断开ssh连接不结束服务，需要将他们挂到后台中

```
yum -y install screen

screen -ls    #查看当前已创建的会话 数字.会话名 是-r 的xxx
screen -S xxx #创建xxx会话并进入，在里面 ctrl+a+d 离开当前会话并挂载后台， 输入exit则删除该会话并退出
screen -r xxx #进入xxx会话
```

## 3 Linux可能遇到的问题

（1）解决刷新后找不到网页的问题：

```
npm install --save connect-history-api-fallback
```

```
const history = require('connect-history-api-fallback')
...
app.use(history())
```

（2）windows和Linux回车符不同的问题

（3）若想用Linux命令行执行某个程序时传递参数

命令行的参数有个数和长度限制，所以参数多可以将参数保存到txt文件，读写这个文件获取参数

（4）编码问题
在上传/创建/读取/写入文件时，一定要首先考虑编码，否则遇到中文出现bug非常难发现

（5）linux中没有中文字体SimHei

所以 plt.rcParams['font.sans-serif'] = ['SimHei'] 无效，以下python代码查看现有字体

```
from matplotlib import font_manager
a = sorted([f.name for f in font_manager.fontManager.ttflist])
for i in a:
 print(i)
```

解决方法：

将win系统的 c:/windows/fonts 下的字体copy到linux，放到linux系统并情空系统字体缓存，放到matploylib文件中并修改配置文件，清空matplotlib字体缓存。

（6）python程序相关

node用exec调用python程序的问题：

exec的er回调中，服务器会停在这里，需要 return next(err)  或直接return  来继续运行服务器。

中文问题：

linux中py代码注释若有中文会报错（即使是注释也会），解决：最前面加上 #coding=utf-8
