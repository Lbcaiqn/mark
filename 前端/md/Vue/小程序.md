# 一、介绍

1 技术

微信小程序由于是运行在微信中而不是浏览器，所以无法使用DOM和BOM，但是可以调用微信环境的api（扫码，支付，定位等），也可以使用js的api

页面布局使用wxml，wxss，javascript

2 开发工具

申请小程序开发账号   https://mp.weixin.qq.com/    注册小程序

（个人开发者只能注册个人主体，功能受限，微信认证，支付以及高级接口都无法使用）

开发管理-开发设置 可以看到APPID，开发时会用到

安装微信开发者工具  https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html)

黑色   设置-外观

代理  设置-代理-不适用代理    防止vpn冲突

3 编译运行

修改代码时，模拟器会相应变化，但有时不会且数据有时也需要重置，此时就可以进行编译。模拟器有些效果出不来，预览可以在手机上看效果，但前提是得编译通过。

有些效果只有在预览才能看见，预览必须配置appid才能用，每次重新修改都要重新编译并重新点击预览生成新的二维码。手机扫码后，右上角三点的设置里开启开发调试模式，否则网络请求失效。

4 配置文件：

小程序整体由顶部导航条，背景区和tabBar组成（注意背景是页面底下的，不是页面本身）

4.1 app.json全局配置文件

4.1.1 page配置项放要展示的页面，第一个为首页

4.1.2 window配置项用来配置窗口的样式（顶部导航条，背景区）

| navigationBarTitleText                       | string      |
| -------------------------------------------- | ----------- |
| navigationBarTextStyle                       | light,dark  |
| navigationBarBackgroundColor                 | #16         |
| backgroundColor                              | #16         |
| backgroundTextStyle                          | white,black |
| enablePullDownRefresh (是否开启下拉刷新，默认关)         | boolean     |
| onReachBottomDistance (上拉距底部多少距离触发对应事件，单位px) | number      |

4.1.3 tabBar配置项配置tabbar的样式：

可以放顶部和底部，2<=item数<=5，顶部只显示文本，底部显示icon和text

tabBar配置项属性（只有list数组的text和pagePath是必填项）：

pagePath必须是pages目录

```
"tabBar":{
  "list": [
    {
      "text":"首页",
      "pagePath":"pages/index/index",
      "iconPath":"static/...",
      "selectedIconPath":"..."
    },
    {"text":"分类","pagePath":"..."}
  ],
  "position":"bottom",
  "backgroundColor": "#000000",
  "borderStyle": "white",
  "color":"#000",
  "selectedColor":"#f00"
}
```

```
//自定义tabBar
1. app.json 的 tabBar配置项中，增加 "custom": true,这样就会使用自定义tabBar
注意，虽然默认的tabBar会失效，list的内容依然要写，一是为了区分tabBar页面和非tarbBar
A面，二是为了兼容低版本的客户端，在不能使用自定义的情况下能使用默认。
2.miniprogram文件夹下建立 custom-tab-bar 文件夹，存放tabBar组件，内容包括，wxml，
xss，js，json
3.wxml，wxss布局，js通过与 wx.switchTab()跳转tabBar
```

，4.1.4 style配置项配置杨样式版本，目前最新版本v2

4.1.5 跟随微信设置的暗色模式

页面的暗色模式、在全局设置样式

```
page {
  background: #fff;
  color: #000;
}
/* 若微信设置为暗黑模式，应用的样式 */
@media (prefers-color-scheme: dark) {
  page{
    background: #000;
    color: #fff;
  }
}
```

导航栏和tabbar的暗色模式

```
//根目录下新建 theme.json，light和dark都要写，里面的属性名字自定义(但light和dark的属性名要保持一致)
{
  "light": {
    "navBgc": "#ffffff",
    "navC": "black"
  },
  "dark": {
    "navBgc": "#000000",
    "navC": "white"
  }
}

//app.json中，用@使用theme.json的变量
{
  ...
  "window": {
    "navigationBarTitleText": "123",
    "navigationBarBackgroundColor": "@navBgc",
    "navigationBarTextStyle": "@navC"
  },
  "tabBar": {...},
  "darkmode": true,
  "themeLocation": "theme.json"
}
```

4.2 页面各自的json配置文件

用于配置各页面特有的窗口样式，会覆盖全局的窗口配置，配置项与app.json不太一样，如：

```
{
  "navigationBarTitleText": "",
  "enablePullDownRefresh": false,
  "usingComponents": {}
}
```

# 二、wxml的标签（组件）

有自己的标签和属性，属性若为布尔值，true时可以省略值

app.json中的pages编写路径就会这届在page下生成页面文件

1 视图容器

1.1 <view>和<block>
<view>类似于<div>

<block>相当于vue的<template>，只作包裹代码作用，不渲染不占内存，适合于if控制多个组件显示时使用

1.2 <scroll-view>

实现滚动，属性scroll-y或scroll-x控制垂直/水平滚动，对应的必须设置高度/宽度

有时可能要重置滚动到顶部，实现：

```
...
<view @click="activeChange"></view>
...
<scroll-vie scroll-y :scroll-top="scrollTop"><scroll-view>
...
data: {
  return {
    scrollTop: 0
  }
},
methods: {
  activeChange(){
    //scroll-top无法重复赋值，所以需要0.01和0来回赋值
    this.scrollTop = this.scrollTop == 0 ? 0.01 : 0  
  }
}
```

如分类页面的左右两边都有滚动

```
<view class="ScrollArea" style="display: flex;">
  <scroll-view class="ScrollLeft" scroll-y style="height: 100vh; width: 25%;">
    <view v-for="i in 100">{{i}}</view>
  </scroll-view>
  <scroll-view class="ScrollRight" scroll-y style="height: 100vh; width: 75%;">
    <view v-for="i in 100">1000000</view>
  </scroll-view>
</view>
```

1.3 <swiper>和<swiper-items>

轮播图

swiper属性

| 功能     | 属性                     | 类型      | 默认值            |
| ------ | ---------------------- | ------- | -------------- |
| 点是否显示  | indicator-dots         | boolean | flase          |
| 未激活点色  | indicator-color        | color   | rgba(0,0,0,.3) |
| 激活的点色  | indicator-active-color | color   | #000           |
| 是否切换   | autoplay               | boolean | false          |
| 切换间隔   | interval               | ms      | 5000           |
| 是否衔接滚动 | circular               | boolean | false          |

2 基础内容

2.1 <text>

类似于<span>，属性selectable实现长按复制（注意模拟器无效，真机才有效爱哦）

2.2 <rich-text>

通过nodes属性将html的标签渲染为wxml结构

```
<rich-text nodes="<h1 style='color:red'>123</h1>"></rich-text>
```

2.3 <button>

```
<!-- 基本使用，其他属性和值详见文档 -->
<!-- 独占一行 -->
<button>普通按钮</button>
<button type="primary">主色调按钮</button>
<button type="warn">警告按钮</button>
<!-- 共享一行 -->
<button size="mini" type="primary">小按钮</button>
<button size="mini" type="primary">小按钮</button>
<button size="mini" type="primary">小按钮</button>
<button size="mini" type="primary">小按钮</button>
<!-- 带边框 -->
<button size="mini" plain>123</button>
```

2.4 <image>

类似于img标签，但他是双标签

注意，不像img，image若设置width为100%，高度是不会自适应的

图片必须放在项目的miniprogram文件夹下的images文件夹  src="/images/..."

通过mode属性决定图片的裁剪和缩放模式，值：

| scaleToFile(默认) | 不保持比例，直接将宽高拉伸到与image一样的宽高           |
| --------------- | ----------------------------------- |
| aspectFit       | 保持比例，缩放直到宽高长的那个与image宽高一致，所以可能会造成留白 |
| aspectFile      | 保持比例，缩放直到填充满image，所以可能会裁剪图片         |
| widthFix        | 宽度不变，高度自保持比例适应                      |
| heightFix       | 高度不变，宽度保持比例自适应                      |

3 表单组件

<input />，与H5差不多，新增了一些东西

事件confirm用于监听回车按下

<radio checked="true" color="red">  选中√，颜色为红色的radio

4 导航组件

分为声明式导航和编程式导航：

```
<!-- 声明式导航，注意url最前面加/ -->

<!-- 跳转到tabBar页面 -->
<navigator url="/pages/index/index" open-type="switchTab">跳转到tabBar页面</navigator
>
<!-- 跳转到非tabBar页面，导航条会有返回键后退一级，此时open-type="navigate"可以省略 -->
<navigator url="/pages/logs/logs" open-type="navigate">跳转到非tabBar页面</navigat
or>
<!-- 后退导航，点击后退，deita定义后退层级 -->
<navigator url="/pages/logs/logs" open-type="navigateBack" deita="1">返回</navigator>
```

```
//编程式导航
//tabBar跳转
wx.switchTab({
  url: '/pages/index/index',  //只有url是必填项
  success: () => {//成功回调},
  fail: () => {//失败回调},
  complete: () => {//结束时回调，成功失败都会回调}
})

//非tabBar跳转
wx.navigateTo({
  url: '/pages/logs/logs',  //只有url是必填项
  success: () => {//成功回调},
  fail: () => {//失败回调},
  complete: () => {//结束时回调，成功失败都会回调}
})

//后退
wx.navigateBack({
  deita: 1,  //若补给，默认1
  success: () => {//成功回调},
  fail: () => {//失败回调},
  complete: () => {//结束时回调，成功失败都会回调}
})
```

传参一般都是非tabBar才需要，通过在url后面拼接 ?aaa=1&bbb=2 传参

```
//在生命周期钩子onLoad的参数options可以获取传递的参数
onLoad(options){
  console.log(options)
}
```

()6 map地图组件

7 canvas画布组件

8 开放能力

9 无障碍访问

# 三、wxss

1 基本区别

大部分的css的功能都能使用，只有小部分不能用，如id选择器，通配符选择器无法使用，可以用 page {}  代替 * {}

此外，wxss还有自己的特性，有rpx和import导入css

rpx是适配单位，将宽度分为750rpx，会根据不同屏幕来自动转化px

@import '/xxx.wxss';    //导入miniprogram目录下的xxx.wxss

2 全局样式与局部样式

全局样式在app.wxss中定义，使得所有页面都有效果

局部样式在各自页面的wxss文件，若局部样式权重大会覆盖全局样式

# 四、模板语法

在相应的js或ts文件中定义数据，wxml就可以使用了，可用与vue一样的mustache语法

```
// pages/aaa/aaa.ts
Page({
  //页面的初始数据 
  data: {},
  //与data同级可以写函数和声明周期钩子
})
```

若data中定义了数据 a:0 则sxml中通过{{a}}获取，在js中通过this.data.a获取

通过this.xxx()  调用方法（但是wxml无法调用，需要wxs）

数据直接修改不是响应式的，需要this.setData修改才是响应式：

```
this.setData({
  a:this.data.a+1
})
```

1 数据绑定

与vue不同

```
//css写.big的样式
//js
data:{
  className: 'big'
}
<!--wxml-->
<button class="{{className}}"></button>
```

2 事件绑定

```
<!--另一种形式是 bind:tap="..." ..>
<text bindtap="fun">123</text>

<!--常用事件
tap   相当于click
input  表单输入
change  任何状态的改变
-->
```

```
//事件函数写在js中的与data同级的区域
btnTapFun(e){
  //e是事件对象
}
```

传参与vue很大不同

```
<button bind:tap="btnTapFun" data-xxx="{{2}}" data-yyy="{{3}}">001</button>
```

```
btnTapFun(e){
  console.log(e.target.dataset.xxx)
  console.log(e.target.dataset.yyy)  
}
```

双向绑定

```
<input type="text" value="{{a}}" bindinput="inp" />
<text>{{a}}</text>
```

```
inp(e){
  this.setData({
    a: e.detail.value
  })
}
```

下拉刷新

```
//下拉刷新可在app.json全局配置或各自页面的json文件配置，
"enablePullDownRefresh":true 
//此自定义下拉行为，在data同级编写，可以做一些数据重置的操作
onPullDownRefresh(){
  //自定义行为，默认是不重新渲染页面的，下拉也不会自动弹回，所以必须要：
  wx.stopPullDownRefresh()  //弹回
}
```

上拉到底部的处理

通常是上拉加载更多，请求下一页的数据

```
//data同级
onReachBottom(){
  //这里可以网络请求更多数据，并且应作防抖处理
}
//可在配置文件配置上拉处理的距离，但是一般默认的50px就行了
```

点击右上角分享

```
onShareAppMessage() {}
```

3 条件渲染

wx:if和hidden的区别与vue的v-if和v-show一样，唯一的区别就是v-show是“显示”，hidden是“隐藏”

```
<text wx:if="{{a == 0}}">0</text>
<text wx:elif="{{a == 1}}">1</text>
<text wx:else>2</text>
```

```
<text hidden="{{false}}">123</text>
```

4 列表渲染

```
<view wx:for="{{arr}}">索引是{{index}}，值是{{item}}</view>
<view wx:for="{{obj}}">key是{{index}}，value是{{item}}</view>
<view wx:for="123456">我是第{{index+1}}个数字{{item}}</view>
```

```
<!--可以修改index和item的变量名-->
<view wx:for="{{arr}}" wx:for-index="ind" wx:for-item="i">
  {{ind}},{{i}}
</view>
```

5 生命周期钩子

分为应用生命周期和页面生命周期，应用包含页面

应用生命周期函数，在app.js中声明，与globalData同级

| onLaunch | 小程序初始化完成时回调，只触发一次 |
| -------- | ----------------- |
| onShow   | 小程序启动，或从后台进入前台触发  |
| onHide   | 小程序从前台到后台时触发      |

页面声明周期函数，在各自页面的js文件中声明，与data同级

| onLoad   | 页面加载完成，只触发一次，相当于vue的created                   |
| -------- | --------------------------------------------- |
| onReady  | 页面渲染完成，只触发一次，相当于vue的mounted                   |
| onShow   | 页面显示时触发                                       |
| onHide   | 页面隐藏时触发                                       |
| onUnload | 页面卸载时触发，只触发一次，相当于vue2的destroyed，vue3的unloaded |

# 五、wxs

weixin script，类似于js，区别：

1. 不支持es6及更高级的语法

2. 模块使用CommonJS规范

3. ios端性能比js块2-20倍，安卓则差不多

4. wxs的函数不能作为事件函数，只能使用{{}}调用wxs的变量、函数

5. wxs不能调wx和js，js不能调wxs，js的数据可通过{{}}传给wxs

页面的js文件的data数据可以在wxml中使用，但是函数却不行，而wxs定义的函数则可以在wxml中使用，一般wxs里面都是定义过滤器

```
<!-- 内嵌exs，卸载wxml中 -->


{{m1.fun('123')}}

<wxs module="m1">
  var fun = function(str){
    return str + '456'
  }
  module.exports = {
    fun:fun
  }
</wxs>
```

```
//外联wxs，如写在utils目录下的filters.wxs
var fun = function(str){
  return str + '456'
}
module.exports = {
  fun:fun
}

----------------------------------------------------

<!-- wxml中引入，src必须是相对路径 -->
{{m1.fun('123')}}

<wxs module="m1" src="..//../utils/filters.wxs"></wxs>
```

# 六 组件

1 自定义组件

1.1 创建、引入与使用

在根目录中建立components文件夹存放组件，里面新建a文件夹再右键新建component就能自动生成json，wxml，wxss，js

局部引入在各页面的json写，只能在该页面使用；全局引入在app.json写，全部页面都能用

```
"usingComponents": {
  "cpn":"/components/cpn/cpn"
}
```

使用：wxml中   <cpn></cpn>

区别：

1. 组件的json中要  "component": true

2. 页面的js使用Page(config)，组件的js使用Component(config)

3. 页面的事件函数与data同级，组件的事件函数写在与data同级的methods中

2 组件样式

组件与页面的样式是互相隔离的（包括全局样式），但是仅限于类选择器

若想自定义是否隔离，可以：

```
//方式一、组件js文件中
Component({
  options:{
    styleIsolation: 'isolated'  
  }
})
//方式二、组件的json文件中
{
  "styleIsolation": "isolated"
}

/*
isolated     默认
apply-shared 页面样式能影响组件，反之不行
shared       页面，组件样式能互相影响，该组件也能影响其它apply-shared或shared的组件
*/
```

3 父子组件通信

3.1 父传子

```
//组件js中
Component({
  propteries:{
    xxx: Number  //简写
    bbb: {       //可指定默认值
      type: Number,
      value: 10
    }  
  }
})
//js中通过this.propertise.xxx调用

<!-- wxml -->
<cpn xxx="100" bbb="50"></cpn>
```

与vue一样能在{{}}中使用，与vue区别：

1. vue的data和props是不同对象，data可读可写，props只读

2. 小程序的data和properties是一个对象，都是可读可写

3.2 子传父

```
//子的事件函数中
this.trigerEvent('xxx',{aaa:...})
//父的wxml中
<cpn bind:xxx="faXxx"></cpn>   bind:xxx可以写成bindxxx
//父的faXxx函数中
e.detail.aaa 获取参数
```

3.3 let cpn = this.selectComponent('类/id选择器')

相当于vue的refs，得到的cpn是子组件实例对象，cpn.方法  cpn.data.属性  cpn.setData()

3.4 

4 数据监听器

```
Component({
  //可监听单个、多个属性的变化
  observer: {
    'aaa'(newVal){},
    'bbb,cccc'(bbbNewVal,cccNewVal){}  
  }
})
```

5 纯数据字段

指的是只在js内部使用，不需要到wxml渲染的数据

小程序的数据默认是非响应式的，需要setData修改才能响应式，这样是为了提高性能。我们可以更进一步，将不需要渲染的数据定义为纯数据字段，再提高性能

```
Component({
  options: {
    pureDataPattern: /正则/   //复合正则的属性名将变成纯数据字段  
  }
})
```

由此，官方推荐在组件js内部使用的属性、方法的名字以_开头

1.6 组件生命周期

分为组件生命周期和组件所在页面的生命周期

5.1 组件生命周期

与data同级

| created  | 组件创建完成，此时无法使用this.setData() |
| -------- | --------------------------- |
| attached | 组件放入页面结点树中，此时可以网络请求数据       |
| reqdy    | 组件渲染完成                      |
| moved    | 组件在节点树中移动                   |
| detached | 组件销毁                        |
| error    | 组件内的函数异常时回调                 |

5.2 组件所在页面的生命周期

写在与data同级的pageLifetime中

| show         | 页面显示    |
| ------------ | ------- |
| hide         | 页面隐藏    |
| resize(size) | 页面大小有变化 |

6 插槽

有默认插槽和具名插槽，使用多个<slot>时如具名插槽，需要在组件的options中添加：

multipleSlot: true

7 behaviors

相当于vue的混入

```
//定义一个js文件
module.exports = Behaviors({  
  //属性方法生命周期
})
//用到的组件中
const xxx = require('...')
Component({
  behaviors: [xxx]
})
```

# 七、分包

1 介绍

未分包时，所有的页面和资源在打开小程序时会同时加载，速度会很慢。

分包后，就会俺需加载。

分包：分为一个主包和多个分包，主包包含tabBar页面和公共资源，分包则包含非tabBar页面和私有资源。在首次打开小程序时，只会加载主包的内容，只有在需要分包的页面和资源时，才会加载分包。

主包不能访问跟分包的私有资源，分包可以访问主包的公共资源，分包之间不能相互引用私有资源。

分包限制：主包和分包总大小不大于16M，主包和分包单个大小不超过2M

2 使用

目录结构：pages文件夹放主包的页面，在pages的同级建立xxx分包文件夹作为一个分包，xxx下建立pages文件夹放页面，分包不能嵌套分包

/pages/主包页面

/xxx1/pages/分包1页面

/xxx2/pages/分包2页面

在app.json中作如下配置，其中name是分包别名，可不写

```
{
  "pages":["pages/...","..."]  //主包页面
  "subpackages": [
    {"root":"xxx1","name":"p1", pages:["pages/...","..."]},
    {"root":"xxx2","name":"p2", pages:["pages/...","..."]}
  ]
}
```

此外，若没有自己新建目录结构，配置文件编译后也会自动生成

查看主包分包大小：详情-基本信息-本地代码

3 独立分包

独立分包是分包的一种，可以有多个

一般情况下，打开小程序先下载主包，才能下载对应的分包。但是独立分包不一样，打开小程序时不下载主包而是直接下载独立分包并展示。即独立分包不依赖于主包。

注意，独立分包不能引用主包的公共资源。

只需要在app.json的分包配置项中添加 "independent": true 即是独立分包。碎

4 分包预下载

在进入某个页面时，可能会有需求提前预下载需要的分包，使得节省访问该分包时的下载事件，甚至不用再下载。

app.json中

```
{
  "preloadRule": {
    “pages/...”:{
      "network": "all"   //所有网络都可预下载；另一个值是“wifi”，只有在wifi下才预下载
      "paakages": [“..."]  //需要预下载的分包数组，值为分包的root或name
    }
  }
}
```

注意，同一个分包中，分包大小+预下载大小不能超过2M

# 七、网络请求

官方为了安全，对网络请求做了限制：

1. 只能请求https协议的接口

2. 必须将接口的域名添加到信任列表（查：工具右上角-详情-项目配置-request合法域名）

1 添加域名到信任列表

登录微信小程序管理后台-开发-开发管理-开发设置-服务器域名，注意无法添加ip地址和localhost，且该域名需要后端做icp备案，且修改域名一个月做多修改5次

2 发送请求

```
wx.request({
  url:'...',
  method:'...',
  data:{},  //get,post都是data
  succes:res => {
    console.log(res.datas)    
  }
})
```

3 关闭域名验证

在开发时，为了方便可以关闭域名验证，此时就不需要https协议和添加信任列表

详情-本地设置-不检验合法域名......

但是项目上线时就一定要开启域名验证

4 跨域和ajax

只有浏览器环境才存在跨域问题，小程序没有跨域问题

ajax是基于浏览器的xhr对象，小程序是没有的，所以小程序不能使用ajax，小程序用的是自己封装的网络数据请求

# 七、API

1 官方API

分为事件监听API，同步API，异步API

H5的DOM、BOM的api无法使用，localStorage无法使用

保留了定时器

常用api，具体详见官方文档

```
//展示、关闭loading
wx.showLoading({title:'正在加载...'})
wx.hideLoading()
//显示弹窗
wx.showToast({
  title: '连接失败',
  duration: 2000,  //弹窗持续时间
  icon: 'none',    //使用的icon，none为不使用，默认为√,
  mask: true       //防止点击事件穿透
})

//给tabbar设置小标
wx.setTabBarBadge({
  index: 2, //要显示小标tabbar的索引
  text: ''  //必须是字符串，''为不显示任何内容
})
//图片放大预览
wx.previewImage({
  current: 0,    //预览图片的索引
  urls: [...]    //图片们的url地址
})

//选择收获地址，若本地没有收获地址，则会进入填写页面（新版不再需要授权）
wx.chooseAddress().then(res => {
  console.log(res)
))
/*一调用就会进入选择地址页面
res是一个对象，数据有：
{
  userName,     //姓名
  telNumber,    //电话
  provinceName, //省
  cityName,     //市
  countyName,   //区，县
  detailInfo,   //详细地址
  errMeg,       //锁雾信息，若没有错，则值为"chooseAddress:ok"
  postalCode,
  nationalCode
}
*/
//获取用户信息（头像/昵称等）
uni.getUserInfo().then(res => {}) //必须配合 <button open-type="getUserInfo" bindgetuserinfo="xxx"></button> （已失效）
uni.getUserProfile({desc: '随便但必传'}).then(res => {})  //获取的结果一样，比起上面区别在于不用buuton、open-type和
/*
getuserinfo事件，每次获取用户信息都会弹出授权窗口（取消了以后也会弹出）  (2022/10 失效)
2022/10 以后以上两个都失效，但是还可使用，获取的均是 用户名为 '微信用户' , 头像为默认头像，若需要获取用户信息，需要提供用户自
己填写上传的模块 （详见文档-api-开放接口）
*/

//登录：
uni.login().then(res => console.log(res.code))  //将这个code发给自己的后端，后端返回token即可
//支付
/*
1.创建订单：给自己的后端发请求，发过去商品信息、价格、收货地址等信息，返回订单编号
2.预支付：给自己的后端发请求，发过去订单编号，返回微信支付需要的参数
3.微信支付：wx.requestPayment({参数}) 参数为2得到的
4.查看订单是否支付成功：给自己的后端发请求
*/

//本地存储
wx.setStorageSync('xxx',a)  //a必须是字符串，若不是，需要JSON.stringify()
wx.setStorageSync('xxx','') //清空
wx.getStorageSync('xxx')    //若不存在，返回空字符串，若存在，返回JSON字符串，需要JSON.parse
```

有些api需要授权，有些点击取消后还能再次授权，有些则不会，需要解决。

异步api的使用方式分两种：

```
//1.callback  
wx.xxx({
  ...
  sucess(){},
  fail(){},
  complete(){}
})
//2.promise ,需要api支持promise风格
//若参数不包含sucess/fail/complete，则返回一个promise，否则不返回promise
```

2 npm安装第三方包

2.1 限制：

1. 不支持依赖于nodeJS模块（如fs，path）的包

2. 不支持依赖于浏览器的DOM,BOM的包，如jQuery

3. 不支持依赖C++的包（如一些加密的包）

2.2 npm使用：

在项目的miniprogram目录下安装npm包，先npm init再装包

装包成功后，在开发者工具-工具-构建npm，构建成功后会多出miniprogram_npm文件夹

若构建npm时，若miniprogram_npm文件夹已存在，建议先删除再构建，防止不必要的错误。

2.3 常用npm包

2.3.1 组件库vant

为了防止样式冲突，建议将 app.json 的 "style":"v2" 删除

使用vant的组件时，需要在json的usingComponents引入

2.3.2 小程序异步API转Promise

```
import {promisifyAll} from 'miniprogram-api-promise'

const wxp = wx.p = {}
promisifyAll(wx,wxp)  //wxp得到了转化为promise的wx异步api，通过wxp.xxx()调用
//如 await resData = wxp.request(...)
```

2.3.3 状态管理工具

相当于vuex，需要安装mobx-miniprogram和mobx-miniprogram-bindings，作用分别是创建store和在各页面中绑定store

注意：页面js和组件js的绑定store语法是不一样的

miniprogram下新建store文件夹存放store.js

```
import {observable,action} from 'mobx-miniprogram'
const store = observable({
  //属性
  data1:123,
  data2:456,
  //计算属性
  get data3(){
    return this.data1 + this.data2
  },
  //修改属性值
  updateData1: action(function(newVal){
    this.data1 = newVal
  }),
})
export default store
```

在需要使用的页面中的js中

```
import {createStoreBindings} from 'mobx-miniprogram-bindings'
import store from '../../store/store'
Page({
  onLoad() {
    this.storeBindings = createStoreBindings(this,{
      store,
      fields: ['data1','data2','data3'], //导入属性和计算属性
      actions:['updateData1']  //导入修改store数据的方法
    })
    //在需要修改store数据的时候，this.updateData1(678910)
  },
  //离开页面时，解除该页面对store的绑定
  onUnload() {
    this.storeBindings.destroyStoreBindings()
  }
})
```

或在需要的组件的js中

```
import {storeBindingsBehavior} from 'mobx-miniprogram-bindings'
import store from '../../store/store'
Component({
  behaviors:[storeBindingsBehavior],
  storeBindings:{
    store,
    //导入属性和计算属性有三种方式
    fields:{
      data1: () => store.data1,      //方式1
      data2: (store) => store.data2, //方式2
      data3: 'data3'                 //方式3
    },
    //导入修改数据的方法只有一种方式
    actions:{
      updateData1: 'updateData1'
      //需要修改store数据时，this.updateData1(123456)
    }
  }
})
```

最后在相应的wxml中

```
<!-- 直接用{{}}使用store的属性和计算属性 -->

<view>{{data1}}</view>
<view>{{data2}}</view>
<view>{{data3}}</view>
```

# 八、协同工作与发布

# 九、公众号

需要另外注册一个公众号的账号，公众号分为订阅号和服务号，服务号需要企业才能申请，功能比订阅号多一些，个人只能申请订阅号。
