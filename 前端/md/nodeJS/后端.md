# 一、express基本，跨域，静态文件夹\

先建立一个存放服务器的文件夹，在该目录下：
npm init
npm install express --save
启动服务器：
node xxx.js
自动重启服务器：
调试：
127.0.0.1:8000/url  可以调试

通过nodemon启动服务器，当代码修改时会自动重启（但有时不会，就需要自己重启）

npm install --save nodemon

npx nodemon xxx.js  

```
const express=require('express')
const bodyParser = require('body-parser')

const app = express()
//将public作为静态文件夹，通过 域名:端口/文件名.后缀 就可以访问，注意路径没有public
//若有多级文件夹，就 域名:端口/文件夹/文件名.后缀
app.use(express.static('./public')) 

//请求体解析的中间件
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: false }))

//所有请求类型，所有url都设置可跨域
//注意，node的路由是从上至下看是否有要执行的路由，所以跨域的路由代码要放到最前面
app.all("*", (req, res, next) => {
  //解决跨域
  res.header("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Headers","content-type,Authorization")
  //解决axios的post请求会先发送options请求的问题（post请求但不传数据或formdata则不会有这种问题）
  if (req.method == 'OPTIONS')  res.send(200);  
  else  next();
})

//中间件------------------------
//自定义中间件用函数来定义，在路由中可以使用中间件，中间件代码执行完后才执行路由的代码
function myMid(){
  console.log('我是一个中间件')
}
//-----------------------------

//路由--------------------------
app.post('/url',myMid,(req,res) => {
  //req.query和req.body分别是get和post请求的参数
  res.send('请求结束')
})
//------------------------------
app.listen('8000',() => {
  console.log('服务器已启动')
})
```

# 二、注册/登录/鉴权

1. 注册
   
   后端需要定义用户的表，账号限制唯一u，密码需要bcrypt加密
   
   ```//
   //用户表定义
   
   const mongoose = require('mongoose')
   mongoose.connect('mongodb://localhost:27017/vnpDB',{
     useNewUrlParser: true
   })
   
   const Users = mongoose.model('users',new mongoose.Schema({
     username: {
       type: String,
       unique: true  //限制账号唯一，若重复会报错
     },
     password: {
       type: String,
       set(val){
         return require('bcryptjs').hashSync(val,10)  //加密
       }
     }
   }))
   
   module.exports = {
     Users
   }
   ```
   
   注册的接口，当账号已存在时需捕获异常
   
   ```
   import {Users} = require('./db/Users.js')
   app.post('/logup',async (request,response,next) => {
     try {
       await Users.create({
         username: request.body.username,
         password: request.body.password
       })
       response.send('注册成功')
     }
     catch(err) {
       response.send('注册失败')
     }
   })
   ```

2. 登录
   
   先判断账号是否存在，再匹配密码，匹配成功返回jwt（jsonwebtoken），用于鉴权
   
   ```
   //私钥为了安全一般是不可见的，保存在本地文件中，不存放于git，这里为了方便就直接定义为了变量
   const SECRCT = 'asf34g35s1g56erssa'
   
   app.post('/login',async (request,response) => {
     let user = await Users.findOne({
       "username": request.body.username
     })
     if(!user) return response.send('用户名不存在')
     let passwordValid = require('bcryptjs').compareSync(request.body.password,user.password)
     if(!passwordValid)  return response.send('密码错误')
     //jwt用users表的id和私钥签名
     let token = require('jsonwebtoken').sign({
       id: String(user._id)
     },SECRCT)
     response.send({
       user,
       token
     })
   })
   ```

3. 鉴权
   
   登录成功用户会得到jwt，一般保存在local storage中，在用户每次访问需要登录的页面时，需要将jwt发送给后端，后端进行鉴权，鉴权成功后前端才能访问。
   
   前端请求代码，将storage中的jwt放到请求头中传输
   
   ```
   //以组件内守卫为例
   beforeRouteEnter(to,from,next){
     if(sessionStorage.getItem('token') != null) next()
     else  next({path: '/Login'})
   }
   //
   /*
   路由守卫中，nest({path: '/Login'})跳转到登录页时，可以正常跳转，但是报错 ...via a navigation...
   解决：
   路由文件中：
   const originalPush = VueRouter.prototype.push
   VueRouter.prototype.push = function push(location, onResolve, onReject){
     if (onResolve || onReject) return originalPush.call(this, location, onResolve, onReject)
     return originalPush.call(this, location).catch(err => err)
   }
   其本质是跳转报错时，catch捕获异常，所以还是没有解决根本的问题，只是没有报错了
   */
   ```
   
   //拿数据
   axios({
     url: '/getProfile',
     method: 'get',
     headers: {
   
       Authorization: sessionStorage.getItem('token'),
   
     }
   }).then(res => {
     console.log(res.data)      
   })

```
后端响应头需要加上Authorization

为了简化代码，将鉴权逻辑定义为express中间件，每个需要鉴权的url调用这个中间件即可。
```

   async function auth(req,res,next){
     let token = req.headers.authorization
     //解析jwt中的user的id
     let {id} = require('jsonwebtoken').verify(token,SECRCT)
     let user = await Users.findById(id)
     res.user = user
     next()
   }

```

```

   //在执行回调之前，会先执行auth中间件
   app.get('/getProfile',auth,(req,res) => {
     res.send(res.user)
   })

```
# 三、文件上传

在文件上传时，有可能会在前端读取文件
```

file表单读取文件
  //选择是获取文本内容，注意先清空自己变量的数据
  if(event.target.files.length != 0){
    let file = event.target.files[0]
    const fileReader=new FileReader()
    fileReader.readAsText(file,'utf8') //编码要与csv文件的编码一致，否则中文乱码
    fileReader.onload=()=>{            //读取完成时回调
      let res = fileReader.result,str=''  //读取结果保存在result
      //已经得到文本内容res，接下来取出首行并转成数组，赋值给变量展示select
    }
  }

```
1. 后端文件存储形式

   1. 将整个文件以二进制形式存入数据库（不推荐）

   2. 存在后端服务器某个目录，数据库存放文件的路径

   3. 存放到另一个服务器（文件服务器）或第三方服务器，数据库存放网络url

2. 文件上传需具备的功能：

   - 样式：

     1. file表单隐藏，通过自定义按钮来触发file表单的点击

     2. 文件选择和文件上传可以分开，也可以合并

     3. 选择文件的方式也可以是拖拽，事件dragenter,dragleave,dragover,drop分别是拖拽移入，拖拽移开，拖拽在框里移动，拖拽放入触发，拖拽放入时，浏览器会触发默认行为（打开新页面并显示文件内容），自己需要关闭默认行为。

        drapenter，drapleave可以用来设置样式，drapover和drop需要e.preventDefault()关闭默认行为（根据需要也可以关闭整个浏览器的这个行为），drop里面用e.dataTransfer.files获得文件对象。

     4. 上传时，通过css修改样式，js修改按钮描述内容和禁用按钮

   - 限制：

     1. 文件类型限制：

        ```
        //两种方法任选一个
        //这样限制，文件选择框变成只有这些格式的文件
        <input type="file" accept=".jpg,.png">
        //这样限制，文件选择框还有其他类型文件
        if(!/(jpg|png)/i.test(file.type)){
          console.log('不支持的格式')
          return
        }
        ```

        ```

        ```

     2. 文件大小限制：

        ```
        if(file.size > 2*1024*1024){
          console.log('文件超过2M，无法上传')
          return
        }
        ```
- 已选文件列表

  单文件直接显示就行

  多文件可以实现删除功能，利用li事件委托到ul实现

- 已选文件预览/缩略图：

  图片，先将图片转化为base64码，再将base64码赋值给img的src即能实现缩略图
```

  function fileToBase64(file){
    return new Promise((resolve,reject) => {
      let fileReader = new FileReader()
      fileReader.readAsDataURL(file) //这是异步的，需要下面事件监听处理完成
      fileReader.onload = e => {
        resolve(e.target.result)
      }
    })
  }

```
文本，可以用FileReader实现预览

其他类型的文件，为了美观可以用图标表示缩略图

- 进度，axios的配置项onUploadProgress可以实时监听，至于上传速度可以用已上传大小和已花费时间计算，剩余时间可以用上传速度和剩余大小计算
```

  onUploadProgress: progress => {
    console.log('当前已上传:',progress.loaded,'字节')
    console.log('文件总大小:',progress.total,'字节')
    console.log('当前百分比:',Math.round((progress.loaded*100)/progress.total) + '%')  
  }

```
- HASH命名文件：

后端为了避免上传的文件与服务器中原有文件重名，会根据上传的文件弄出一个HASH值来对文件命名（如multer中间件），但有的后端不处理，则需要前端自己处理。使用SparkMD5，根据buffer格式的文件生成HASH值
```

  iamport SparkMD5 from 'spark-md5'

  //先将文件对象转为buffer
  function fileToBuffer(file){
    return new Promise((resolve,reject) => {
      let fileReader = new FileReader()
      fileReader.readAsArrayBuffer(file)
      fileReader.onload = e => {
        resolve(e.target.result)
      }
    })
  }
  //生成HASHa
  asnyc function(file){
    let buffer = await fileToBuffer(file)
    let sparkmd5 = new SparkMD5.ArrayBuffer()
    sparkmd5.append(buffer)
    let HASH = sparkmd5.end()
    //HASH的值只跟文件内容有关(与文件名无关)，文件内容完全一样HASH就一样
    //下面根据需要可以将文件命名为 HASH.后缀名，有时也直接命名为HASH
  }

```
3. 文件上传类型

 1. 单文件上传（FormData

    前端：

    post请求，请求体放FormData，设置请求头

    headers: {"Content-Type": "multipart/form-data"}

    但是这样设置有时候会报错，说找不到边界，可以换成：headers: false

    ```
    //前端--------------------------------------------
    <template>
      <div id="upload">
        <input ref="inp" type="file" style="display: none;" @change="upload">
        <button @click="clickUpload">点击上传</button>
      </div>
    </template>

    <script>
    import {request} from '../network/index.js'

    export default {
      methods: {
        clickUpload(){
          this.$refs.inp.click()
        },
        upload(e){
          const file = e.target.files[0]
          const formData = new FormData()
          //append的第一/二个参数分别是键和值，键可以根据需要自定义名，方便后端处理
          //如append('fileName',file.name) append('HASH',hash值)
          formData.append('file',file)
          request({
            url: '/upload',
            method: "post",
            data: formData,
            headers: false,
          }).then(res => {
            console.log(res.data)
          })
        }
      }
    }
    </script>
    ```

    //---------------------------------------------------------

    //后端--------------------------------------------------------
    const express = require('express')
      const fs = require('fs')
      const multer = require('multer')
      const app = express()

      //解析FormData并放到对应目录的中间件
      const UploadMiddle = multer({

        dest: './upload/'

      })

      //multer为了防止重名覆盖原有文件，会将文件名命名为随机序列并且没有后缀名，需要自己重新命名
      app.post('/upload',UploadMiddle.any(),(req,res) => {

        const newName = './upload/' + req.files[0].originalname
        fs.rename(req.files[0].path, newName, (err) => {
          if(err) res.send("上传失败")
          else    res.send('上传成功')
        })

      })

    ```

    ```

4. 单文件上传（base64）

 适合图片，音频，视频，图片居多

 post请求，请求体base64

 请求头 headers:{'Content-Type':'application/x-www-dorm-urlencoded'}

5. 多文件上传

 选择文件，一是file表单增加属性multiple，一次选多个，在change事件中将files数组的元素全append到FormData，二是不加multiple，一次选一个，每次change将files[0]的文件append到已声明的FormData，最终都是得到含有多个file对象的FormData

 上传文件也有两种方式，一是一次性上传全部file（但无法获得进度），后端通过req.files得到各个file信息并改名。二是每个file单独上传（能获得每个file的进度），都断与单文件上传一样。

6. 大文件上传（切片与断点续传）
```

//前端---------------------------------------------------------------
async function upload(e){
  const file = e.target.files[0]
  //1.为了标识切片，需要给每个切片命名为 HASH_数字.后缀
  //1.1 后缀名
  let fileName = file.name.split('.')
  let suffix = fileName[fileName.length-1]
  //1.2 HASH
  let buffer = await this.fileToBuffer(file)
  let sparkmd5 = new SparkMD5.ArrayBuffer()
  sparkmd5.append(buffer)
  let HASH = sparkmd5.end()

  //2.切片可以固定数量或固定大小，但切片不要太多建议设置最大切片数量，推荐先固定大小，看有多少切片，若切片数量多于最大数量，则就切最大数量的切片
  //2.1 确定切片数
  let chunkSize = 1024 * 100, maxSum = 100
  let chunkSum = Math.ceil(file.size / chunkSize)
  if(chunkSum > maxSum){
    chunkSum = maxSum
    chunkSize = 
  }

  let chunks = []
  //2.2 先看后端是否有已上传的切片
  let alreadyList = await request({
                            url: '/already',
                            method: 'get',
                            params: {
                              HASH
                            }
                          })
  alreadyList = alreadyList.data.map(i => parseInt(i))
  //2.3 确定未上传的切片index
  let chunkIndex = []
  for(let i=0;i<chunkSum;i++) chunkIndex.push(i)
  chunkIndex = [...new Set([...chunkIndex])].filter( i => !new Set([...alreadyList]).has(i))

  //3 开始切片，file.slice(a,b)切片，左闭右开,chunks存放每个切片的名字和值
  //3.1 若此时切片都已上传，但未合并
  if(chunkSum == alreadyList.length){
    request({
      url: '/merge',
      method: 'post',
      data: {
        HASH: HASH,
        fileName: file.name,
        chunkSum
      }
    }).then(r => {
         console.log(r.data)
       })
  }
  //3.2 切片从未上传过，或上传了部分切片
  else {
    for(let i of chunkIndex){
      let chunk = null
      if(i == chunkSum - 1) chunk = file.slice(i * chunkSize,file.size)
      else  chunk = file.slice(i * chunkSize,i * chunkSize + chunkSize)
      chunks.push({
        name: `${HASH}_${i}.${suffix}`,
        chunk
      }) 
    }
    //4.发送请求，进度可以用已上传的切片数来确定
    //4.1 上传切片
    let res = await Promise.all(chunks.map(c => {
          let formData = new FormData()
          formData.append('chunk',c.chunk)
          formData.append('name',c.name)
          return request({
            url: '/upload',
            method: 'post',
            data: formData,
            headers: false
          })
        }))
    console.log(res)
    res = await request({
                  url: '/merge',
                  method: 'post',
                  data: {
                    HASH: HASH,
                    fileName: file.name,
                    chunkSum,
                  }
                })
    console.log(res)
  }
}

//后端--------------------------------------------------------------

const express = require('express')
const fs = require('fs')
const bodyParser = require('body-parser')
const multiparty = require('multiparty')

const app = express()
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: false }))

app.all("*", (request, response, next) => {
  response.header("Access-Control-Allow-Origin", "*");
  response.setHeader("Access-Control-Allow-Headers","content-type,Authorization")
  if (request.method == 'OPTIONS')  response.send(200);  
  else  next();
})

//获取已上传的切片
app.get('/already',(req,res) => {
  const {HASH} = req.query
  let nameList = []
  if(fs.existsSync( './upload/'+HASH))
    nameList = fs.readdirSync('./upload/'+HASH).sort((a,b) => a-b)
  res.send(nameList)
})

//上传切片
app.post('/upload',async (req,res) => {
  let form = new multiparty.Form({uploadDir: './upload'})
  //form.parse()会将文件保存到设置的路径
  form.parse(req,async (err,fields,files) => {
    //fields是前端formData.append()的非FormData类型数据
    //files是文件的路径等信息,
    const index = fields.name[0].match(/(?<=_)\d+(?=.)/)['0']
    const dir = fields.name[0].match(/.+(?=_\d+)/)['0']
    //创建存放切片的目录
    if(!fs.existsSync( './upload/'+dir))  fs.mkdirSync('./upload/'+dir,err => {})
    //将切片移动到创建的目录
    //用常规的移动文件也可以，但有大小限制，推荐用流写入
    const buffer = fs.readFileSync(files.chunk[0].path)
    let ws = fs.createWriteStream(`./upload/${dir}/${index}`)
    ws.write(buffer)
    ws.close()
    //删除留在外面的切片文件
    fs.unlinkSync(files.chunk[0].path,err => {})
    res.send(index)
  })
})

//合并切片
const Buffer = require('buffer').Buffer
app.post('/merge',(req,res) => {
  const {HASH,fileName,chunkSum} = req.body
  //得到所有切片的名字
  const nameList = fs.readdirSync('./upload/'+HASH)
  if(nameList.length < chunkSum){
    res.send('上传失败')
    return
  }
  //排序切片名
  nameList.sort((a,b) => a-b)
  //合并切片需要buffer格式的切片的数组，和所有切片的总字节
  let Byte = 0, bufferList = []
  for(let name of nameList){
    let buffer = fs.readFileSync(`./upload/${HASH}/${name}`)
    bufferList.push(buffer)
    Byte += buffer.length
  }
  let mergeBuffer = Buffer.concat(bufferList,Byte)
  //以流的形式写入文件，没有大小限制
  let ws = fs.createWriteStream('./upload/'+fileName)
  ws.write(mergeBuffer)
  ws.close()
  //合并完成，删除存放切片的临时文件夹
  fs.readdirSync(`./upload/${HASH}`).forEach(name => {
    fs.unlinkSync(`./upload/${HASH}/${name}`)
  })
  fs.rmdirSync(`./upload/${HASH}`)
  res.send('上传成功')
})

app.listen(8000,()=>[
  console.log('服务已启动') 
])

```
# 四、文件下载

正常情况下，部署到静态文件夹的文件，浏览器输入或a标签的href是这个文件的url，若文件是浏览器无法解析的，如exe，csv等，则会进行下载；若是浏览器可以解析的，如html，图片等，则不进行下载，而是预览。

H5的a标签增加了新属性download，加上之后，html、图片等等也会进行下载，但是只在同源下有效（即使前端、后端设置了允许跨域也不行），跨域需要另外的解决方案。

前端发送下载请求，后端一般会返回url或文件流。

1. 返回url

   解决方案；

   1. 直接把url放a标签里，a标签默认且只能get请求，所以url有长度限制，且download是H5特性IE有兼容问题。

   2. form表单下载，最传统无兼容性问题，form可以get或post请求，但无法下载浏览器可解析的文件，如html，图片等等。

   3. window.open()  或 location.href = url， 简单一行代码，缺点是url长度限制和编码限制，无法下载html，图片等。

   4. iframe，优缺点基本与直接用a标签一样，但兼容性和性能差。

   5. ajax请求获取下载url，再生成a标签下载。

   除了ajax的方案都有无法监听返回是否成功和进度，无法携带token的问题。

   以下是ajax请求uri生成a标签的方案：
```

   //前端-------------------------------------------------------
   axios({
     url: 'localhost:8000/download',
     method: 'get',
     params: {
       ...  
     },
   }).then(res => {
        let url = res.data.url, fileName = res.data.fileNmae      
        let ele = document.createElement("a")          
        ele.style.display = 'none'          
        ele.href = url       
        ele.download = fileName                   
        document.querySelectorAll("body")[0].appendChild(ele)          
        ele.click()                   
        ele.remove()
      })

   //后端--------------------------------------------------------
   app.post('/download',(req,res) => {
     //根据req的参数得到要下载的文件url
     res.send(...) 
   }）

```
2. 返回文件流

url下载最大的问题就是跨域情况下无法下载浏览器可预览的html，图片等文件，文件流式一种解决方案，一般返回blob或base64。

流程是ajax获得文件流后，转化成本地url再用a标签进行下载，可以看出，虽然解决了跨域问题，但是它相当于先下载完成后再出现文件保存框，用户体验性不好，若果文件太大，等待时间更久。

以下是文件流为blob的代码。
```

   //前端----------------------------------------------------------
   axios({
     url: 'localhost:8000/download',
     method: 'get',
     responseType: 'blob',
     params: {
       ...
     }
   }).then(res => {
        if(!res) {
          console.log('下载失败')
          return
        }
        let blob = new Blob([res.data],{
          type: 'image/png' //可以查阅blob.type
        })
        let url = window.URL.createObjectURL(blob)        
        let ele = document.createElement("a")          
        ele.style.display = 'none'          
        ele.href = url       
        ele.download = '123' //有了blob的type后缀会自己加上                   
        document.querySelectorAll("body")[0].appendChild(ele)          
        ele.click()                   
        ele.remove()
     })
   //后端----------------------------------------------------------
   app.get('/download',(req,res) => {
     res.download('./public/a.png')
   })

```
# 五 资源访问

1 数据，直接以JSON格式返回数据库的数据

2 图片保存在静态资源文件夹，返回网络URL，若多次请求传的数据不同，且后端由这些数据产生的图片命名相同覆盖，则浏览器会缓存第一次返回的托片而无法获得新图片，解决：返回图片url时，   给url加上时间戳或随机数，使得每次返回的url都不同，就不会缓存了

# 六、Linux部署项目

1 环境搭建

1.1 购买云服务器，修改密码，开放端口，连接ssh

1.2 环境
```

//1.更新yum，并且安装常用软件
yum update
yum install -y  gcc gcc-c++ cmake ncurses ncurses-devel bison

//2.node，通过编译源代码安装，
cd /usr/src  这里专门存放源代码
wget https://nodejs.org/dist/v9.3.0/node-v9.3.0.tar.gz
tar -xf node-v9.3.0.tar.gz
cd node-v9.3.0
./configure
make && make install
//编译完成，程序放在 /usr/local

//3.更新node到最新版本，n也可以款速切换node版本
npm install -g n
//不要用n latest安装最新版本，最新版本node17不稳定
n 14  安装node14
n的使用：https://segmentfault.com/a/1190000015302680

//4.python装包：
pip3 install --upgrade pip
pip3 install numpy==1.19.3
pip3 install pandas==0.23.4
pip3 install matplotlib

//5.创建公钥，并安装git：
cd ~/.ssh
ssh-keygen -t rsa -C "邮箱"  回车执行，再回车三次
cat ~/.ssh/id_rsa.pub    复制输出得到内容到github
//安装git：
yum install git
git config --global user.name "xxx"
git config --global user.email "xxx"

```
1.3 后台运行服务，开机自启

为了同时启动vue和node，且断开ssh连接不结束服务，需要将他们挂到后台中
```

yum -y install screen

screen -ls      #查看当前已创建的会话   数字.会话名 是-r 的xxx
screen -S xxx   #创建xxx会话并进入，在里面 ctrl+a+d 离开当前会话并挂载后台， 输入exit则删除该会话并退出
screen -r xxx   #进入xxx会话

```
2 其他问题：

2.1 若想用Linux命令行执行程序时传递参数

命令行的参数有个数和长度限制，所以参数多可以将参数保存到txt文件，读写这个文件获取参数
在上传/创建/读取/写入文件时，一定要首先考虑编码，否则遇到中文出现bug非常难发现

2.2 linux中没有中文字体SimHei  

所以 plt.rcParams['font.sans-serif'] = ['SimHei']  无效
以下代码查看现有字体
```

from matplotlib import font_manager
a = sorted([f.name for f in font_manager.fontManager.ttflist])
for i in a:
 print(i)

```
将win系统的 c:/windows/fonts 下的字体copy到linux，放到linux系统并情空系统字体缓存，放到matploylib文件中并修改配置

文件，清空matplotlib字体缓存

3 linux中py代码注释若有中文会报错，解决：最前面加上  #coding=utf-8
```
