# 一、JS执行机制

1. 同步，异步
   
   - JS是单线程的，分为同步任务和异步任务，同步任务即一行行执行，异步任务则是在适当的时机执行（异步任务包括定时器，事件，网络请求，回调函数等）
   
   - 执行过程：
     
     将同步任务放入执行栈，将作为异步任务放入任务队列（又叫消息队列）。先执行同步任务，遇到了异步任务就把异步任务放入任务队列中且不执行，当所有同步任务都完成后，进入事件轮循。
     
     注意定时器的规则有点不同
     
     - 是所有同步任务执行完再执行异步任务，setTimeout即使设置延时为0，也要在所有同步任务执行完后，才开始计时。
     
     - 即便同步任务全部完成，定时器也要在在延时到达后，才会进入任务队列，相同时间则按代码顺序来，每一批进入队列都是不同的事件
     
     - 循环
   
   - 事件轮循
     
     在任务队列中，循环查看是否有符合条件的异步任务，条件符合就把异步任务放到执行栈中执行。这个过程会一直重复，这就叫事件轮循
     
     异步任务又可以分为微任务(process的then)和宏任务(定时器，ajax，读取文件)
   
   - 整体执行顺序
     
     在node中，有process.nextTick(() => {})和setImmediate(() => {})两个api，这里为了简便，纪委a和b，它们的执行顺序是：
     
     同步任务-a-事件轮循第一次循环后-b-继续事件轮循  详细规则如下：
     
     1. 第一轮事件循环结束的标志是第一个或第一批相同延时定时器执行结束
     
     2. 第一轮事件轮循中异步任务的执行顺序：微任务-宏任务，其中微任务会全部执行完，后面的每一轮只有宏任务
     
     3. 若Promise有嵌套，则先执行完所有Promise的第一层，以此类推
     
     4. awit后面的代码块执行顺序相当于then，await下面还有await，相当于嵌套Promise
     
     5. 执行顺序相同的，按代码先后顺序执行
   
   - js执行顺序的例子：
     
     ```
     async function fun2(){
       console.log('d')
     }
     async function fun1(){
       console.log('c')
       await fun2()
       console.log('e')
       await fun2()
       console.log('f')
     }
     
     setTimeout(() => console.log(1)) //不给时间，默认0
     console.log(2)
     setTimeout(() => console.log(3),0)
     setTimeout(() => console.log(4),100)
     console.log(5)
     new Promise(resolve => {
       resolve()
     }).then(() => {
       console.log('a')
       new Promise(resolve => {
         resolve()
       }).then(() => {
         console.log('b')
       })
     })
     new Promise(resolve => {
       console.log(6)
       resolve()
     }).then(() => {
       console.log(7)
     })
     process.nextTick(() => {
       console.log(8)
     })
     setImmediate(() => {
       console.log(9)
     })
     fun1()
     
     //执行顺序：256cd8a7e1394
     /**�򵥽���
     2 5 6 c d  同步任务
     8          process.nextTick()
     a 7 e d    第一重事件循环的第一层微任务
     b f        第一重事件循环的第二层微任务    
     1 3        第一重事件循环的宏任务
     9          ΪsetImmediate()
     4          第二重事件循环的宏任务
     **/
     ```

2. 预编译

3. 垃圾回收机制
   
   js会对没有用的资源自动地进行回收，遵循以下规则
   
   - 全局的资源不会回收，除非关闭网页。
   
   - 函数执行完则函数内的资源会被回收。
   
   - 闭包使用的资源不会被回收。

# 二、作用域

- 简单作用域：全局作用域，函数作用域，块级作用域（let，const）

- 执行上下文：就是c语言的执行栈，代码开始执行，全局环境入栈，函数执行函数入栈，函数执行完函数出栈。

- 作用域链：函数内嵌函数，内部函数可调用外部函数变量，反之不可，调用时找最近一级有该变量的外部函数（链式查找）。全局变量是最远的一级。

# 三、闭包

## 1.闭包是什么

内部函数可访问外部函数的资源，则该内部函数就是闭包，被访问的资源不会被回收，最常见的是函数内return子函数，该子函数就是一个闭包，子函数内引用父函数的资源不会被回收，但是没引用的会回收

## 2.例子

1. 例1：
   function fun(){
     var a=0,b=0
     return function(){
   
       console.log(++a)
   
   }
   }
   var f=fun()
   f() //输出1
   f() //输出2
   闭包现象在哪：在fun函数外，可以访问到fun函数里面的变量a，
   哪个是闭包：return出的函数为闭包
   垃圾回收：a因为被用了，不会被回收，b没有用，被回收

2. 例2：
   for(var I=0;i<=3;i++){
     异步代码
   }
   由于js的执行机制，先执行完同步再进入事件循环执行异步，所以i一直是3，一种解决方法是使用let使得其有块级作用域，使得每一次i都驻留在内存中。
   另一种方法是使用闭包：
   for(var I=0;i<=3;i++){
     (function(){
   
       异步代码
   
   })(i)
   }
   使用立即执行函数将异步代码的函数包裹，使得异步代码的函数成为闭包，闭包使用i使得i驻留在内存中。

3. 例3：
   筛选出数组中[a,b]的元素
   function fun(a,b){
     return function(item){
   
       return item>= a && item<=b
   
   }
   arr.fiter(fun(a,b))
   }

## 闭包优缺点

闭包好处：*可在函数外访问函数内的资源 *可防止函数内的资源被回收
闭包坏处：函数内的资源不被回收，用不好会导致内存损耗（低版本IE更会导致内存泄漏）。解决方法是将不需要使用的闭包设置为null

# 四、this指向总结

## 1.基本

- 只有在调用函数时，this才有意义，不调用时没有意义，每个函数调用时都会产生独立的this。

- 函数外的this指向window，函数内看规则，函数内使用严格模式（加上一行代码 ’use strict’ ），可以使得指向window变成undefined 

## 2.普通函数内this四种绑定规则

优先级：new>显示>隐式>默认

1. 默认绑定规则
   
   * 全局环境下，指向window
   
   * 函数独立调用（即不通过 对象. 来调用），指向window，如立即执行函数，内嵌函数，对象的方法的内嵌函数，return的闭包，形参子函数且在父函数内被调用都是独立调用函数

2. 隐式绑定规则：
   
   * 谁调用就指向谁 a.fun() 指向a，a.b.fun() 指向b。
   
   * 对象方法赋值给全局变量，变量()执行，指向window，本质是函数独立调用，因为赋值时并没有调用，是在变量()指向时才调用，所以指向window，这样叫做隐式丢失。
   
   * 对象方法作为形参，且在父函数内被调用，本质函数独立调用，指向window

3. 显示绑定规则：
   js函数本身是一个对象，有一个调用的方法噶call()，所以函数调用 funm(形参….) 是 * *  fun.call(this指向,形参….)的语法糖。
   fun.call(this指向,形参….)
   fun.apply(this指向,形参数组)
   let f=fun.bind(this指向,形参….);   f();
   三种效果一样。

4. new绑定：
   构造函数指向new出来的对象。若构造函数内有return且不是return this 就会该边this指向为return的东西（但一般不会这么做）

## 3.箭头函数内的this

由于内嵌函数的this指向window，若想this指向父函数，可以在父函数内用 let That=this，子函数内使用That实现，或者使用显示规则改变this指向，这是在没有箭头函数之前的做法。

* 箭头函数本身没有this，它的this实际上是父级作用域的this四种规则（也可以说是定义该箭头函数的执行上下文所在的对象）（一定要主要父级作用域是哪个）

* 默认/隐式/显示规则对箭头函数都无效，箭头函数不能作为构造函数自然也没有new规则。

## 4.api的回调函数

* api的回调函数this指向由api作者决定

* 不管api内部如何实现，只要回调函数为箭头函数，就要用箭头函数this规则

* Vue的api的回调函数的this指向Vue实例。

## 5.实例

let name='window'
  let obj1={
    name:'1',
    fn1(){
      console.log(this.name)
    },
    fn2:()=>console.log(this.name),
    fn3(){
      return function(){
        console.log(this.name)
      }
    },
    fn4(){
      return ()=>console.log(this.name)
    }
  }
  let obj2={
    name:'2'
  }
  obj1.fn1()                    //1，普通函数的隐式规则
  obj1.fn1.call(obj2)     //2，普通函数的显示规则
  obj1.fn2()                   //window，箭头函数的父作用域是全局的默认规则，this执行window
  obj1.fn2.call(obj2)   /* window，箭头函数没有显示规则，且父作用域是全局的默认规则，                                                                          this执行window*/
  obj1.fn3()()                   //window，普通函数的默认规则
  obj1.fn3().call(obj2)   //2，普通函数的显示规则
  obj1.fn3.call(obj2)()   //window，普通函数显示后再默认
  obj1.fn4()()                 //1，箭头函数的父作用域为obj1的隐式规则，name为1
  obj1.fn4().call(obj2)  /* 1，箭头函数没有显示规则，且父作用域为obj1的隐式规则，name                                          为1 */
  obj1.fn4.call(obj2)()  //2，普通函数显示后，箭头函数的父级作用域的隐式

# 五、0.1+0.2为什么不等于0.3

- 原因：
  
  js的浮点数有精度，0.1和0.2在内存中存的并不是0.1和0.2，可能是0.10000001 0.2000001所以相加就不等于0.3

- 如何判断相等：
  0.1+0.2和0.3相减，得到的结果的绝对值若小于如0.0000001，则就相等

# 六、防抖与节流

- 防抖与节流的作用都是为了减少函数不必要的执行，限制执行次数，比如在网络请求中如果有大量不必要的请求时非常损耗性能的。又比如滚动事件的调用是非常频繁的，而实际并不需要这阿么多次的调用。

- 在含有网络请求的业务中，为了用户体验，应当在第一次执行时不适用防抖节流

- 既然都是减少执行次数，那它们的区别是：

       防抖是在限定的时间内，只需要执行一次

      节流是在限定的时间内，限制执行n次，一秒执行 delay/1000 次

## 1.防抖

- 实例
  
  - 场景
    
    一个表单的功能是当输入完成后，显示内容，若不是要防抖，则每输入一个字符都会显示内容，而实际上只需要在输入完成后再显示就能达到需求，中间有大量的无意义的函数执行。
    
    是要防抖，每次输入时给一个延时s，若：
    
    - 未超过s，则清空s重新计时，且不显示内容，说明还未输入完成
    
    - 超过s，则输出内容，说明输入完成
  
  - 代码
    
    ```
    <body>
        <input type="text">
      </body>
      <script>
        let inp = document.querySelector('input')
        inp.oninput = debunce(function(){
          console.log(this.value)
        },1000)
        function debunce(fn,delay=1000){
          //这里使用了闭包，使得t不会被销毁
          let t = null
          return function(){
            if(t != null)  clearTimeout(t)
            t = setTimeout(() => {
              //此处为内嵌函数的独立调用，this指向window，需要call()改变指向
              let That = this
              fn.call(That) 
            },delay)
          }
        }
      </script>
    ```

## 2.节流

- 实例
  
  - 场景：
    
    滚动事件的触发非常频繁，实际上不需要这么多，现在要求减少它的触发次数
  
  - 代码：
    
    ```
    window.onscroll = throttle(function(){
      console.log('123')
    },1000)
    function throttle(fn,delay=1000){
      let flag = true
      return function(){
        if(flag){
          setTimeout(() => {
            let That = this
            fn.call(That)
            flag = true
          },delay)
          flag = false
        }
      }
    }
    ```

# 

# 七、JSON格式

JSON格式是JavaScript对象的表示形式，但是在格式上严格一些

- value为字符串时，用双引号就包裹

- key要用双引号包裹

- 最后一个属性结束不能加逗号

# 

# 八、对象拷贝

- 数组判空
  
  arr.length == 0

- 对象判空
  
  不能用  obj == {}  判断，因为这是比较两个对象的地址
  
  JSON.stringify(obj) == ''
  
  Object.keys(obj).length == 0

- 浅拷贝与深拷贝的区别- 
  
     基本数据类型类型直接赋值拷贝酒香，而引用数据类型(对象)则要考虑浅拷贝与深拷贝
  
  - 浅拷贝是拷贝地址，拷贝出的新对象和被拷贝的对象指向堆内存的同一个地址，这样修改一个对象，另一个对象也同时修改，因为它们实际都是一个对象。像对象直接赋值给新对象，就是浅拷贝
    
    ```
    let obj = {
        name: 'lgx'
    }
    let newObj = obj  //浅拷贝
    ```
  
  - 深拷贝则是新申请一个内存地址，再拷贝，这样两个对象的修改就互不影响，完全就是两个不同的对象，有两种方法实现深拷贝
    
    1. 方法一
       
       遍历旧对象的的属性，给新对象添加对应的属性，若该属性又是一个对象，则要使用递归。
       
       ```
       function deepCopy(obj){
         let newObj = {}
         for(let i in obj){
           if(obj[i] instanceof Object)  newObj[i] = deepCopy(obj[i])
           else  newObj[i] = obj[i]
         }
         return newObj
       }
       ```
    
    2. 方法二
       
       利用JSON的api，将对象转为字符串再转为对象
       
       ```
       function deepCopy(obj){
         let newObj = JSON.stringify(obj)
         return JSON.parse(newObj)
       }
       ```

# 九、原型

JS中每个对象和函数都有自己的原型对象，可以调用，添加原型对象的属性和方法。

- 原型是什么
  
  - 只要是函数（包括构造函数），都有 fun.prototype 叫显示原型属性
    
    只要是对象，包括构造函数new出的一个实例对象d,就有 obj.__proto__ 隐式原型属性(注意是双下划线)，即构造函数的prototype和new出的对象的__proto__指向同一个原型对象。
  
  - 原型对象也是对象，也有__proto__属性，指向它的缔造者Object的原型对象Object.protype，而Object.prototype的__proto__指向null

- 原型怎么用
  
  - 给原型添加属性和方法噶
    
    fun.prototype.xxx = val / function(){}
    
    obj.__proto__.xxx = val / function(){}
  
  - 调用原型的属性和方法
    
    fun.prototype.xxx
    
    obj.__proto__.xxx          访问原型对象的xxx，__proto__可以省略（省略后，先在对象自己内部找xxx，找不到到_proto_找，再找不到继续往上，最终到Object）

- 构造函数的原型继承
  
  对象可以调原型的属性方法很像继承，在ES6中有class及继承，但是ES5只有构造函数，想要实现构造函数继承需要借助原型
  
  ```
  function User(username,password){
    this.username = username
    this.password = password
    this.login = function(){
      console.log('登陆了')
    }
  }
  function Admin(){
    this.deleteUser = function(){
      console.log('删除用户')
    }
  }
  Admin.prototype = new User('管理员',123456) //继承就这一行代码
  let admin = new Admin()
  console.log(admin.username) //省略了__proto__
  //  admin.login()admin--.__proto__-->原型:new User()--.__proto__-->原型:User().prototype--__.proto__-->Object
  ```

# 十 事件流

HTML是一个树结构，html标签是根结点，事件处理包括事件捕获和事件冒泡两个阶段。默认情况下，事件在冒泡阶段触发。

- 事件捕获：从根结点出发到叶子结点捕获事件

- 事件冒泡：从粗发事件的对象出发到根结点，若该事件对象的祖先有定义相同事件，则也会触发。

- 冒泡情况，输出small，mid，big
  
  ```
  <body>
    <div class="big">
      <div class="mid">
        <div class="small"></div>
      </div>
    </div>
  </body>
  <script>
  let small = document.getElementsByClassName('small')
  let mid = document.getElementsByClassName('mid')
  let big = document.getElementsByClassName('big')
  small[0].onclick = function(){
    console.log('small')
  }
  mid[0].onclick = function(){
    console.log('mid')
  }
  big[0].onclick = function(){
    console.log('big')
  }
  ```

事件冒泡有好有坏，一般需要关闭冒泡，但有时也可以利用冒泡实现事件委托

- 事件委托：将子元素的时间委托到父元素

- 实例
  
  给ul的每个li绑定点击事件，点击console.log()
  
  如果给每个li都绑定事件，则不利于后期维护，代码也复杂。
  
  只给ul绑定点击事件，当点击li时，通过冒泡触发ul的点击事件，事件对象为该li
  
  ```
  <body>
    <ul>
      <li>1</li>
      <li>2</li>
      <li>3</li>
    </ul>
  </body>
  <script>
  let ul = document.querySelector('ul')
  ul.onclick = function(e){
    console.log(this)    //因为一直都是ul的事件，所有this指向ul
    console.log(e.target.innerText) //当前事件对象为被点击的li
  }
  </script>
  ```

# 十一、异常处理

当代码出错时，会报错并终止运行，可以使用异常处理使报错后不终止运行。

```
try {
  console.log(a)   //a未定义，使用异常处理后，不报错，将报错信息在catch处理，可以理解为报错变为了程序运行的一部分
}
catch(err) {
  console.log(err)
}
```

throw抛出异常，在一些业务中，可能需要手动抛出异常，在处理具有大量代码的项目bug时，是很难根据报错来找到bug的，可以利用抛出异常来方便检查是哪里出了问题

throw一般与try，catch配合使用。

```
let inp = document.getElementById('inp')
let btn = document.getElementById('btn')

btn.onclick = function(){
  try {
    if(inp.value == '') throw '输入框1不能为空'
  }
  catch(err) {
    alert(err)
  }
}
```



# 十二、
