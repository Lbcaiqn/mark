# 一、基本

1. 与PC端的不同：
   
   - 不用设置版心，px与物理像素一一样。
   
   - 移动端浏览器基本没有兼容性问题，可以放心使用H5C3新特性。
   
   - 一些标签在移动端各浏览器都有各自样式，为了统一各浏览器的标签样式，通常使用github上的normalize.css进行初始化。
   
   - 为了防止用户过渡缩放，移动端页面要设置最小/最大宽度，一般最小宽度为320px，最大宽度看需求
   
   - body {
     
       min-width: 320px;
     
       max-width: 640px;
     
     }

2. 分辨率：
   屏幕真实的分辨率是物理分辨率，px是逻辑分辨率，PC端是1:1的，而移动端中，物理:px都是n:1，这叫物理像素比，
   window.devicePixelRatio  获取当前的物理像素比
   
   因此，图片放到移动端中，会放大n倍而模糊，所以在开发中，拿到图片先要将它缩小n倍再放到页面中，它会自动方放大n倍，就能不营销图片清晰度。因此，准备图片应当按照物理像素比来，叫n倍图。
   
   缩小图片是用软件工具缩小，而不是写代码

3. 移动端单位
   
   除了pc端的px和 %，移动端还有em，rem，vh，vw单位
   x em 数值是最近且有该属性的祖元素字体大小的x倍
   x rem 数值是html标签的对应样式属性的x倍，若html标签未指定样式，则是浏览器样式的x倍
   vw/vh，可视窗口的宽/高分成100份，1个vw/vh占一份，如100vw就是与可视窗口一样宽，50vw就是一半宽（可视窗口就是整个手机屏幕）

4. 视口
   
   视口是浏览器显示页面的屏幕区域。手机默认都有一个布局视口，是尽量显示整个PC端页面，手指缩放的形式，很不方便，后来就有了视觉视口，显示部分PC端页面，手指左右滑动的形式。
   
   现在使用的是理想视口，页面宽度即视口宽度，通过视口标签指定：
   
   ```
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   ```
   
   指定视口宽度为设备宽度，其他属性可以设置缩放比例以及是否可缩放

5. 开发方案：
   独立页面：流式布局，flex布局，rem布局
   同个页面：响应式布局
   
   流式布局（百分比布局）：
   
   现在很少用了。
   将宽度都设置为百分比，这样宽度就会随屏幕大小而变化。
   一般要设置最小宽度（320px）和最大宽度
   一般将body宽度设置为100%，最小320px，最大根据需要，为了方便PC端还要设置水平居中。

# 二、flex布局

又叫弹性布局，伸缩布局等

1. 基本使用
   
   - 子元素不管是行内元素还是块级元素，都能设置宽度。
   
   - 效果是水平展示，flex:1;是均分视口宽度（各占一份的意思，可不写）。
   
   - 不脱标。
   
   - flex布局是在剩余空间中，给子项分配空间，减去margin，边框和有宽度的盒子就是剩余空间
   
   - display:felx;使得float,clear,vertical-align属性失效，flex:1;使得width失效
   
   - flex布局缺点：一般高度定死，字体大小无法岁屏幕缩放，而这些可以通过适配方案解决。
   
   - 由于设置了flex: 1; 后width失效，所以在需要flex:1;同时需要设置下划线长度或背景色宽度等需求时，可以在里面再放一个div，来设置div的width
   
   ```
   ul {
     display: flex;
   }
   li {
     flex: 1;
   }
   ```

2. 属性
   
   flex父元素叫弹性容器，子元素叫弹性盒子
   
   主轴和侧轴，默认x轴为主轴，y轴为侧轴，若设置y为主轴，则x为侧轴
   
   flex默认不换行，若超过长度会改变子项大小强行塞入一行
   
   * 父元素属性
     
     1. display: flex;   所有子元素在主轴上排列显示且不换行
     
     2. 设置子元素在主轴上的排列方式
        
        justify-content: xxx;
        
        | flex-start    | 默认，左边开始                  |
        | ------------- | ------------------------ |
        | flex-end      | 右边开始                     |
        | center        | 实现水平居中                   |
        | space-around( | 均分主轴，缝隙各自用所以中间缝隙是两侧缝隙两倍大 |
        | space-between | 两个子项到边缘，两侧无缝隙，剩余子项平分剩余空间 |
        | space-evenly  | 均分主轴，共用缝隙一样大             |
     
     3. 设置侧轴上子项的位置（限单行）
        
        align-items: xxx;
        
        | strech     | 默认，若没有设置子元素高度，子元素会拉伸父元素一样高 |
        | ---------- | -------------------------- |
        | flex-start | 上边开始                       |
        | flex-end   | 下边开始                       |
        | center     | 垂直居中                       |
     
     4. 设置侧轴上子项的位置（限多行）
        
        属性与justify-content一样，多了个strech(默认)与align-items的一样
     
     5. 设置主轴方向
        
        flex-direction: row(默认) | column | row-reverse | column-reverse
     
     6. 设置换行
        
        flex-wrap: nowrap(默认) | wrap
        
        flex默认不换行，子项太多会压缩宽度以保证在一行显示。且每行的所有元素高度相同
        
        一行两列：
        
        外；display:flex; flex-wrap:wrap;
        
        里：width:48% //注意此时不要加 flex:1;否则width无效
     
     7. 主轴方向，换行复合写法
        
        flex-flow: column wrap
     
     子元素属性
     
     1. flex: 1;   伸缩比属性，让子元素占一份
        
        如有三个孩子a，b，c，flex分别设置为1,2,1，就共4份，a c各占一份，b占2份
        
        注意：flex优先级比width高，会使width失效
        
        利用flex是分配剩余空间的特性，实现圣杯布局（两侧固定px，中间自适应）：
        
        两侧给固定宽度px，只给中间设置flex:1; 剩余空间分成1份而中间独占这一份，同时为了避免过多的缩小，可以给父元素设置min-width，max-width
     
     2. align-self: xxx;  xxx与父元素的align-items一样，单独设置子项的侧轴排列方式
     
     3. order: 正负整数(默认0);  设置该子项的排列顺序，数值越大越靠前，相同数值哦按原本顺序
     
     常用例子：
     
     ```
     /*圣杯布局，左右固定宽度，中间flex:1自动适配*/
     .left, .right {
       width: 100px;
     }
     .middle {
       flex: 1;
     }
     
     /*分栏布局，一行x个元素，width: (100/x)% */
     .father {
       display: flex;
       justify-content: center;
       flex-wrap: wrap;
     }
     .son {
       width: 50%;
     }
     /*分栏布局，每个item有图片+文字(如商品列表)，若图片大小不同，可以使用下面的方案*/
     .box {
       display: flex;
       justify-content: space-around;
       flex-wrap: wrap;
     }
     .item {
       display: flex;
       align-items: center;
       position: relative;
       width: 45%;
       .img {
         width: 100%;
         padding-bottom: 30vw;
       }
       .info {
         position; absolute;
         bottom: 0;
       }
     }
     ```

# 三.适配方案

1. rem适配
   
   - 基本
     
     rem是单位，x rem 数值是html标签的字体大小的x倍，若html标签未指定样式，则是浏览器样式的x倍。
     
     rem适配就是通过只给html标签的字体大小设置px，给其他元素样式设置rem，当屏幕大小变化时只需要修改html标签的px，rem就能根据html标签的样式自动适配。
     
     注意，不管是em还是rem，html都只设置font-size，其他css属性都是根据这个适配，如width，height
   
   ```
   html {
       font-size: 15px;
     }
     选择器 {
       xxx: 2rem;
     }
   ```
   
   - 多媒体查询
     
     要实现不同屏幕大小来修改html标签的字体大小，需要使用多媒体查询（CSS3）
     
     @media 媒体类型 and (媒体特性){//css}
     当设备符合条件时就适用里面的css代码
     
     媒体类型有：all（全部），screen（屏幕），print（打印机）
     
     媒体特性即条件，screen媒体特性有：width，min-width（相当于>=），max-width（相当于<=）
     
     注意根据css的层叠性来决定多媒体查询的顺序
     
     如：当宽度小于320px时
     @media screen and (max-width:320px){
      选择器 {
      //css
      }
     }
     screen可省略，简写：
     @media (...){
       //css
     }
     多个条件可用and链接：
     @media (...) and (...){}
   
   - 引入资源
     
     rem和多媒体查询可以实现字体，高度等的适配，也可以实现不同屏幕适用不同的布局，如果适配的样式太多，可以将不同屏幕给不同的css文件，再引入资源：
     
     link标签里面的属性： mediatype="media screen and (min-width:320px)"  复合条件就使用对应的css文件。
   
   - rem适配方案
     
     - 方案一：rem+多媒体查询+less，例：
       
       设计稿宽750px，需求分15份，最小屏幕320px
       
       1.less文件a，编写多媒体查询，分为x个屏幕区间，字体大小为 屏幕宽px / 15
       
       2.less文件b，引入a，按照屏幕750px进行开发，如设计稿图片宽100px，则将   其宽度（100/(750/15)=2），设置为 width: 2rem;
       
       3.这样，各个屏幕就能根据2rem进行适配
     
     - 方案二：rem+flexible.js+vscode插件cssrem/less
       
       不用再写多媒体查询，flexible.js已经给各种大小的屏幕的html字体大小设置为：屏幕宽px / 10
       
       按750px设计稿设置100px宽的图片时，100/(750/10)=1.33  width: 1.33rem
       
       如果不适用less，可以用cssrem，在写代码的px时就可以代码提示成对应的rem，但是注意，remcss默认是html的font-size是16，需要在首选项中设置为（750/10）=75

2. vw,vh适配（推荐）
   
   它们是相对于视口的单位（宽，高），将视口划分成100粉，如5vw即5%的视口宽度
   
   与流式布局的百分比区别：流式布局的百分比是相对于父元素，而vw，vh是相对于当前视口。
   
   由于是根据视口给的宽高，这样不管屏幕怎样变化都会自动适配，比rem方便太多了。
   
   - 只适用于移动端，PC端完全不兼容
   
   - 由于缩放一般都是缩放宽度而不缩放高度，所以vh很少用，一般不管width还是height，都是用vw。
   
   - 设计稿转化成vw，vh
     
     设计稿一般给750px，它是二倍图，需要缩小原来的1/2，缩小后，如图中的一个盒子宽度为37.5px，则 37.5/375*100=10，所以 width: 10vw;   也可以借助一些工具直接量出来，由于有大量除法也可以用less计算或vscode插件px2vw

# 四、响应式布局

使一套页面根据不同终端屏幕大小（PC,pad,phone）响应式的改变布局。不需要另外开发移动端页面。但是这种布局方式很少用了，但需要了解。

- 原理
  
  通过多媒体查询实现，根据屏幕大小划分为四个档位，<768px(超小屏幕，如手机)，>=768px && <992px(小型屏幕，如pad)，>=992px && <1200px(中等屏幕，如PC显示器)，>=1200px(宽屏，如宽屏显示器)

- 响应式布局容器
  
  为了简便，用一个父元素包裹需要响应式的子元素，用多媒体查询来改变该容器的宽度（四个档位宽度分别改为 100%，750px，970px，1170px），子元素也可以响应式的修改。

- 移动端框架——bootstrap
  
  常用于开发响应式页面，也能做移动端页面
  
  bootstrap有响应式容器，通过栅格系统实现响应式，不需要多媒体查询来修改容器宽度
  
  基本使用：
  
  bootstrap的每行共分为12列
  
  ```
  <!-- 分别在宽屏，中屏，小屏，超小屏中，每个元素占3，4,6,12份，使得一行显示4,3,2,1个元素 -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 col-md-4 col-sm-6 col-xs-12">1</div>
        <div class="col-lg-3 col-md-4 col-sm-6 col-xs-12">2</div>
        <div class="col-lg-3 col-md-4 col-sm-6 col-xs-12">3</div>
        <div class="col-lg-3 col-md-4 col-sm-6 col-xs-12">4</div>
      </div>
    </div>
    <!-- 列可以嵌套列，被嵌套的列又分为12份 -->
    <div class="container">
      <div class="row">
        <div class="col-md-6">
          <div class="col-md-4">1</div>
          <div class="col-md-4">2</div>
          <div class="col-md-4">3</div>
        </div>
      </div>
    </div>
    <!-- 设置列偏移（左偏），偏移会占用份数，如下是实现各占3份的两个元素贴向两侧 -->
    <div class="container">
      <div class="row">
        <div class="col-md-3">1</div>
        <div class="col-md-3 col-md-offset-6">2</div>
      </div>
    </div>
    <!-- 列排序，改变排列顺序 -->
    <div class="container">
      <div class="row">
        <div class="col-md-4 col-md-push-8">本来是左，后面会推到右</div>
        <div class="col-md-8 col-md-pull-4">本来是右，后面会拉到左</div>
      </div>
    </div>
    <!-- 响应式工具，实现显示隐藏，若隐藏了，则不再占用份数 -->
    <div class="container">
      <div class="row">
        <div class="col-md-4 hidden-md">我只在中屏时隐藏</div>
        <div class="col-lg-6 visible-lg">我只在宽屏时显示</div>
      </div>
    </div>
  ```
  
  其他使用详见文档。

# 五、移动端的遗留问题

1 移动端点击事件300ms延迟：
原因：移动端浏览器一般都有双击缩放或双击xxx，为了监听出双击，在点击第一次后，若300ms内再次点击，就是双击。
但是大部分情况下，300ms都是很难被用户接受的

```
解决：有很多方法，其中一种
npm install fastclick --save
//main.js
import FastClick from 'fastclick'
FastClick.attack(document.body)
```

2 移动端滚动

移动端浏览器滚动会有一些问题，所以滚动会使用第三方库，如better-scroll

npm install better-scroll --save //若是引用的better-scroll.js文件，是new bscroll()

基本使用

```
/*
使用规则：
1.大盒子里放有且只能一个小盒子，在小盒子里放滚动的元素
2.大盒子设置高度以此限定滚动区域，并设置over-flow:hidden;隐藏超出
3.import bscroll from 'better-scroll'
4.vue中因为以下代码需要在有模板才生效，所以需要写在创建模板结束的生命周期函数mounted()内
5.这里使用ref而不推荐dcument.querySelector('.类名')，因为有多个scroll时会冲突
*/

const scroll = new bscroll(this.$refs.refname,{    //大盒子需要属性 ref="refname"
  //可选属性
  //参数1，默认为0， 0/1不监听位置，2监听，但脱手惯性时不监听，3惯性时也监听
  probeType: 0 | 1 | 2 | 3,    
  //参数2，默认false一些点击事件会失效，所以最好true
  click: false | true,        
  //参数3，上拉，默认false
pullUpLoad: false | true    
})
//监听坐标，需要probeType:2 | 3  position为位置信息
scroll.on('scroll',position => {})     
//监听上拉到底部，需要pullUpLoad:true  拉到最底部时的事件，默认执行一次，与scroll.finishPullUp()配合可以多次
scroll.on('pullingUp',() => {
  scroll.finishPullUp()
})        
//ms可不传默认0，在ms内到x，y位置，0,0为顶部    
scroll.scrollTo(x,y,ms)    
```

进行封装

```
/*
1.与axios一样依赖性很强，为了方便以后管理维护代码，将以上代码封装成.vue文件，使用时注册该组件使用
2.probeType和pullUpLoad需要传入
3.外部调用scroll对象时最好先判断scroll对象是否为空
*/
<template>
  <div class="wrapper" ref="wrapper">
    <div class="content">
      <slot></slot>
    </div>
  </div>
</template>

<script>
  import bscroll from 'better-scroll'

  export default {
    data(){
      return {
        scroll: null
      }
    },
    props: {
      probeType:Number,
      pullUpLoad:Boolean
    },
    mounted(){
      this.scroll = new bscroll(this.$refs.wrapper,{
        probeType: this.probeType,
        click: true,
        pullUpLoad: this.pullUpLoad
      }),
      this.scroll.on('scroll',position => {
        this.$emit('showBackTop',position)
      }),
      this.scroll.on('pullingUp',() => {
        this.$emit('pullUpLoad')

      })
    }
  }
</script>

<style scoped>
  .wrapper {
    position: absolute;
    top: navbar高度
    bottom: tabbar高度;

    left: 0;
    right: 0;
    overflow:hidden;
  }
</style>
//父组件中获取滚动组件实例对象，来调用scrollTo，refresh
```

注意事项

1. 无法滚动bug
   由于scroll对象创建后会根据网页内容有一个初始高度，而发生网络请求后显示请求的图片，高度变高，但scroll高度不会刷新，就会无法滚动。
   
   解决方法：一旦加载一张图片，就使用scroll.refresh()刷新高度
   在显示图片的组件里，img标签绑定事件 @load="" 并定义自定义事件，home组件刷新高度 ，但是此时home组件和该组件会涉及到非父子组件之间的通信，可以用vuex或事件总线解决。
   优化：防抖动，不用每次加载完图片都调用refresh()

2. 跳转bug，与1同理，都是图片未加载完，高度需要refresh，跳转的位置才会正确

3. better-scroll的滚动是基于自身的可滚动区域，scroll.on('scroll',e=>{})坐标e随自己的可滚动区域而不是window

4. betterscroll的高度是整个可滚动区域的高度而不是当前展示的滚动区域高度，设置top、bottom时需注意

5. better-scroll组件内的子组件的绝对定位、固定定位和黏性定位会有bug（相对定位正常）
   
   * 绝对定位，就算scroll组件没有相对定位，绝对定位也是以scroll组件为父元素，而更下一级以后的组件则正常，但都以scroll组件为根
   
   * 固定定位完全失效，不再以浏览器视口为父，而是以scrill组件为父，所以会随着滚动而滚动
   
   * 黏性定位完全失效，解决方法：多弄一个该子组件在scroll组件外，绝对定位到顶部，需要时再显示

6. offsetTop不准问题（不是betterscroll带来的问题，本身就有），原因是上面有图片未加载完，需要@load监听才能获得最终的offsetTop

7. betterscroll结核<keep-alive>的bug，数据确实保存了，但是滚动位置与原来不同：
   
   首先要知道betterscroll的两个特点，一是脱手会惯性滚动，二是滚到顶部或底部会有弹簧效果的滚动
   
   使用了<keep-alive>且监听scroll事件，出现的问题：
   
   1. 当手指滑动/惯性滚动/弹簧滚动的同时切换路由时，scroll事件会一直调用且Y坐标为0（activated()和beforeRouteLeave()获取到的也是0），所以路由再切换回来时，就会自己滚到顶部。
   
   2. 当上拉加载更多的同时切换路由，若还在加载中，则scroll会一直调用直到加载完成，与情况1不同的是Y是正确的当前位置，但是路由切换回来时还是会回到顶部
   
   解决思路：
   
   * 用变量a保存Y值，scroll事件函数获取Y值时，如果得到了0，就不赋值给a，否则就把Y值赋值给a
   
   * deactivated()中，scrollTo(0,a)，使滚动停止；但是处于弹簧效果时没用，因为此时a的值还是在弹簧效果内，所以scrollTo(0,0)，以确保Y不处于弹簧效果
   
   * activated()中，scrollTo(0,a)，但是必须在前面refresh一下，否则还是会缓慢滚动顶部
   
   ```
   ...
   deactivatedY: 0
   ...
   onMounted(){
     let scroll = new bscroll({
       probeType: 3,
       click: true,
       pullUpLoad: true  
     })
     scroll.on('scroll',e => {
       this.deactivatedY = e.y == 0 ? this.deactivated : e.y  
     })
     ...
   }
   activated(){
     scroll.refresh()
     scroll.scrollTo(0,deactivatedY)
   }
   deactivated(){
     scrollTo(0,0)
   }
   ```

8. 若betterscroll内的组件有切换展示数据的功能，每类数据有多有少，展示出来的高度就不同且滚动过的距离也不同，为了用户体验，应当监听scroll事件，给每类数据都保存一个Y值，切换数据的同时scrollTo()，典型应用如多种类型的商品列表
   
   或者另一种更好的方案，每次切换都滚动到数据最开始展示的地方，实现比较简单

9. 回滚bug，当在图片未加载完成前滚动或scrollTo到该图片后面，则当图片加载完后，此时滚动区域refresh后被撑高，就会回滚一段距离，距离就是图片的高度，目前无法解决。

10. 不要重复new bscroll，除非是需要使用多个betterscroll
