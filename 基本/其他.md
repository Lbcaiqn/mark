# 一、正则表达式

abc    匹配abc

若要匹配的字符是正则表达式内置的，则需要\转义，如 \+

1. 限定符
   
   | a?  | a出现0次或1次 |
   | --- | -------- |
   | a*  | a出现0次或多次 |
   | a+  | a出现1次或多次 |
   
   a{}，花括号的内容左闭右闭，可以是0，第一个参数不能省略
   
   | a{6}   | a出现6次    |
   | ------ | -------- |
   | a{2,6} | a出现2次到6次 |
   | a{3,}  | a出现3次及以上 |
   
   (ab)限定符    限定ab出现的次数

   贪婪匹配：正则表达式会默认尽可能多的字符

   懒惰匹配：限定正则表达式在能匹配成功时就结束匹配

   如匹配所有标签，结果如下：

| <.+>  | 贪婪匹配，从<html>一直匹配到</html>，即一直匹配到最后一个> |
| ----- | ------------------------------------ |
| <.+?> | 懒惰匹配，只匹配<标签>，即<到第一个>就结束匹配            |

   全部限定符的懒惰匹配：

| ??     | 若0个能复合结果就0个        |
| ------ | ------------------ |
| +?     | 若n个复合结果就n个         |
| *?     | 若n个复合结果就n个，比如1个就1个 |
| {2,6}? | 就可能向少的匹配，比如3个就3个   |

2. 或运算符
   
   | a\|b           | a或b         |
   |:-------------- | ----------- |
   | (ab)\|(cd)     | ab或cd       |
   | a (cat)\|(dog) | a cat或a dog |

3. 字符类（也叫原子表），中括号包裹
   
   原子表中   ()  .  +  就是普通的字符   ^是取反
   
   | [abc]       | a或b或c         |
   | ----------- | ------------- |
   | [a-c]       | 同上            |
   | [a-zA-Z0-9] | 大写或小写或数字      |
   | [^0-9]      | 除了数字之外（包括换行符） |

4. 元字符
   
   | \d            | 数字                |
   | ------------- | ----------------- |
   | \w            | 单词字符（字母，数字，下划线）   |
   | \s            | 空白（空格、TAB、换行符）    |
   | \D \W \S \s\S | 除了数字/单词/空白之外/所有字符 |
   | .             | 任意字符（不包括换行符）      |
   | \b            | 限制边界，防止过多匹配       |
   | ^a            | 行收的a              |
   | a$            | 行尾的a              |

5. 字符属性
   
   不同类型的字符有不同的属性，若要根据字符类型不同来匹配，则需要修饰符u和字符类\p，例子如下，其他查阅文档
   
   | /宽字符/u        | 匹配宽字符，如数学公式 |
   | ------------- | ----------- |
   | /\p{P}/       | 匹配标点符号      |
   | /\p{sc=Han}/u | 匹配中文        |

6. 分组
   
   用小括号包裹部分表达式使其变成子表达式（也叫院子组），最基本的使用时与四则运算一样改变正则运算顺序，和分割|的内容。
   
   捕获：院子组的内容会被缓存到内存中，这种行为叫做捕获
   
   反向引用：通过反向引用可以使用被捕获的院子组的内容，相当于别名
   
   1. 原正则表达式内使用： \1 \2 \3  依次类推表示第几个院子组
   
   2. str.replace(reg,'$2')    str.replace(reg,(reg,p1,p2) => {})  同上
   
   3. 嵌套院子组的情况就从左括号开始数，来判断第几个
   
   4. js的match和exec会返回每个原子组的匹配结果（提取）
   
   5. 左括号之后加上?:表示该院子组不记录，不能再使用上述情况，但括号之外的?:就是普通字符

7. 断言（环视）
   
   给某部分正则表达式前后增加附加条件，匹配的结果不包含断言
   
   下表的中括号应是英文，以  'workingandsingsing' 为例，[a-zA-Z]img  匹配出working和singsing
   
   | 正向先行断言【a-zA-Z】+(?=ing)      | 匹配出work和sing                        |
   | --------------------------- | ----------------------------------- |
   | 负向先行断言【a-zA-Z】+(?!ing)\w{3} | 这里的\w{3}也可以换成$  匹配出and              |
   | 正向后行断言 (?>=wo)【a-zA-Z】+     | 匹配出rking                            |
   | 负向后行断言 \w{2}(?!wo)【a-zA-Z】+ | 这里的\w{2}也可以换成^  匹配出rkingandsingsing |
   
   几个注意点：
   
   1. 断言虽然被小括号包括，但断言不是分组；如果断言内有小括号，则小括号是分组，但断言依旧不是分组
   
   2. 断言只是条件，不会作为匹配结果；如working  /w+ing和/w+(?=ing)的匹配结果分别为working和work
   
   3. 使用负向先行/后行断言时，由于条件不作为匹配结果，所以需要在前/后加上相应的东西；如匹配结尾补不为ng的单词，字符串为working sing的匹配
      
      | /w+(?!ing)      | working和sing |
      | --------------- | ------------ |
      | /w+(?!ing)\w{3} | sing         |
      | /w+(?!ing)$     | sing         |
